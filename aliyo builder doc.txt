Quick Start
Welcome to the Aleo Quickstart. This quickstart will guide you through the core concepts of building on Aleo. You will be guided through the process of deploying and interacting with your own Aleo program directly on the web via the Leo Playground.

What You'll Learn
Aleo Accounts: Learn how to create an Aleo account and create private and public data.
Aleo Programs: Learn how to interact with the Aleo network by deploying and executing your own program.
Private and Public State: Learn how to manage both private and public data on Aleo in order to create privacy preserving apps.
1. Generate a New Aleo Account
The first step in building on Aleo is to create an Aleo account. An Aleo account is a unique identifier that allows you to interact with the Aleo network. With it you can execute program functions, create your own private and public data, and deploy new programs. You can create an account using the Leo Playground or by using one of the ecosystem wallets.

1.1 Using the Leo Playground Widget
Click on the Account Widget to generate a new Aleo Account.


note
Save your Address, View Key, and Private Key in a safe place, you'll need them later.

1.2 Using an Ecosystem Wallet
An account can be created using one of the wallets below. After installing any of the wallets below, you will be prompted to create an Aleo account.

Puzzle Wallet
Fox Wallet
Soter Wallet
2. Seed Your Wallet With Testnet Credits
2.1 Get Credits from an Ecosystem Faucet
To seed your wallet, you can request from the official faucet https://faucet.aleo.org/.

The credits received from the faucet will be public credits, which means they are publicly visible on the Aleo network.

2.2 Verify Receipt of Your Testnet Credits
After receiving a successful confirmation from one of the faucets above, you can check your account balance by selecting Get Account Balance from the list of options in the query widget. Simply paste your wallet address in and press Get. Don't worry if they don't appear right away as your testnet credits may take a few minutes to arrive.


When the credits arrive, you should see the following output in the query widget after pressing Get.


Alternatively you can search for the transaction ID provided by the faucets on any one of the ecosystem's block explorers.

Provable Explorer
Aleoscan
tip
While waiting for the credits to be sent to your wallet, you can proceed to the next step.

3. Deploy Your First Aleo program
3.1 The Token Program
In this section, you'll learn how to deploy a sample Token program to the Aleo Testnet from the Leo Playground. By the end of this section you'll be familiar with how to deploy your own privacy preserving program to Aleo.

info
The Token program provides a simple example how to build a program with both public and private features by creating a token that allows users to hold both public and private balances. This program will show you how to use encrypted data structures called Records to represent private data and public on-chain datastores called mappings to represent public data.

3.2 Customize the Name of Your Program
To begin deploying, select the Token program from the Examples dropdown menu on the Leo Playground.


Next, customize the the name of the program in line 1 of src/main.leo to use a unique identifier and then update the program field in the program.json file to match the new name.

 
tip
The length of the application name should be at least 10 characters. Deployment costs are higher for names shorter than 10 characters.

You are now ready to deploy your first Aleo program to the Testnet! Before proceeding, make sure that your account is funded with sufficient Testnet credits to deploy to the network.

3.3 Deploy Your Program to Testnet
Click on the deploy widget to bring up the deployment window. Enter your program name in the Program ID field and then enter your Private Key. You can view an estimate for the deployment cost by clicking Estimate Fee. When you are ready to deploy, click Deploy.


When you click Deploy, the Leo Playground will build a Deployment Transaction and submit to the Aleo Network. This process may take a while. When it is finished, you should see a confirmation that your Aleo application was deployed in a pop-up containing the transaction ID.


Copy the transaction ID to view the details of your deployment transaction on any of the Aleo block explorers:

Provable Explorer
Aleoscan
info
Depending on the size of your program, you may not have sufficient credits to deploy your program if you are using an account funded with only one faucet transaction. If that's the case, you can still interact with a program already deployed to the Testnet.

4. Execute Public and Private Program Functions
You can now use your deployed token program by executing its functions!

tip
If you did not have enough funds to deploy a program, you can use the token_quickstart.aleo program to test the execution of the token program methods.

4.1 Building Execution Transactions
When you call one of your program's functions, the logic is executed locally and a zero-knowledge proof is built. This proof attests to the correctness of the program execution and its corresponding outputs while keeping hidden inputs or outputs encrypted. After a function is executed, an Execution Transaction is submitted to the Aleo Network that contains a summary of the execution and a proof of its correctness. This transaction will be accepted when a network validator validates the proof and that the proper fee was paid.

4.2 Mint a Token Privately
Below we will mint a private token using the mint_private function. This function will create an Aleo Record which represents the new token. Records are encrypted data structures stored on-chain as ciphertexts that can only be decrypted by the owner of the record (using the owner's View key). This ensures that only the owner of the record knows its content, thus keeping the token private.

To mint a private token, navigate to the Execute widget in the Leo Playground and enter the name of your program in the Program ID tab. Alternatively, you can use the deployed token program 'token_quickstart.aleo`.

tip
Click the magnifying glass icon to confirm that the Program ID corresponds to a deployed program.


Next, enter your Private Key and select the mint_private method from the Function drop-down menu. In the Inputs tab, enter your Account Address and a u64 integer.

["ALEO_ADDRESS_HERE", "50u64"]

Click Estimate Fee followed by Execute. As before with the deploy transaction, you can copy and paste your transaction ID in a block explorer. You should see something resembling the following:


info
The output of the transaction is a Record. In order to decrypt the Record, you need to copy and paste the ciphertext, navigate to the Records widget in the Leo Playground, enter the Record ciphertext along with the View Key that corresponds to your Account's Private Key, and click Decrypt. The decrypted Record should resemble the following:

{
  owner: aleo1kypwp5m7qtk9mwazgcpg0tq8aal23mnrvwfvug65qgcg9xvsrqgspyjm6n.private,
  amount: 50u64.private,
  _nonce: 3175255370513411091535466147458245312227668453916963245036391157478647265587group.public
}


To learn more about Records, click here

4.3 Mint a Token Publicly
In the Token program, public balances are stored in program mappings. Mappings are public key-value stores on Aleo Network nodes which store long term persistent public state onchain.

Below we will mint a public token using the mint_public function. When this function is run, it will update the balance in the account mapping corresponding to the specified Aleo address.

Navigate back to the Execute widget and repeat the steps in the previous section for minting a public token. The transaction summary from the block explorer should resemble the following:


Unlike the mint_private function, the mint_public function creates an execution transaction that contains a Future instead of a Record. A Future contains a set of instructions for validators to execute on-chain which can read or update mappings. If the mint_public execution transaction is valid, it will be accepted by the validators which will run the instructions in the mint_public Future that update the account mapping.

Mapping values can be queried by selecting the Get Mapping Value By Key option in the query widget. You will need to enter the Program ID, mapping name, and mapping key in their respective fields. For the Token program, the mapping key is the Aleo address that owns the public tokens.


info
Awesome! You have successfully deployed a Leo program and executed transactions on the Testnet üéâ

To get started with local development, navigate to the installation guide to install the necessary tools to deploy your Leo programs locally.


Installation
Install the following tools in order to develop and test programs locally:

1. Installing Leo ü¶Å
1.1 Install Git
bit.ly/start-git

1.2 Install Rust
bit.ly/start-rust

1.3 Install Leo
Installing Leo by building from the source code as follows:

# Download the source code and initialize the submodules
git clone --recurse-submodules https://github.com/ProvableHQ/leo
cd leo

# Install 'leo'
cargo install --path .


1.4 Verify Installation
To verify if you have Leo, open your terminal and type leo. You should be able to see the following:

Leo

1.5 Check Version and Update Leo
To check the version of leo, in your terminal, run:

leo --version

You can update Leo to the latest version using the following command:

leo update

The Leo CLI guide provides descriptions for all of the CLI commands.

The Leo Language guide provides an overview of the syntax and semantics of the Leo programming language.

1.6 Optional: IDE Syntax Highlighting
Aleo maintains syntax highlighting implementations for various popular code editors. This can significantly enhance your development experience by providing visual cues and making your Leo code more readable. Here's a brief overview of the supported editors:

Visual Studio Code
Sublime Text
Intellij
For detailed instructions on how to set up syntax highlighting for these editors, please refer to the Tooling for Leo guide.

2. Installing snarkOS
2.1 Prerequisites
Before beginning, please ensure your machine has Rust v1.79+ installed. Instructions to install Rust can be found here.

[For Windows users] Additional dependencies if usual installation path does not works:

Install C++ Clang tools for Windows via the Visual Studio Installer
Set the LIBCLANG_PATH environment variable to the location of the installed libclang.dll file, typically found at:
Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Tools\Llvm\x64\bin


2.2 Clone the snarkOS repository
git clone --branch mainnet --single-branch https://github.com/ProvableHQ/snarkOS.git


[For Ubuntu users] A helper script to install dependencies is available. From the snarkOS directory, run:

./build_ubuntu.sh

2.3 Install snarkOS
cd snarkOS
cargo install --locked --path .

2.4 Verify Installation
To verify if you have snarkOS, open your terminal and type snarkos. You should be able to see the following: snarkOS

3. Next Steps
tip
We recommend starting with the Quick Start Guide. This guide will walk you through creating your first Aleo application, deploying it to the network, and executing program functions. This hands-on experience will give you a practical understanding of the Aleo platform's core features and workflow.

You now have all of the tools to build and test Leo programs locally. Before deploying to the Testnet, we recommend testing your program using a local network. The following guide explains how to initialize and deploy programs to a local network.

Aleo instructions and snarkVM
Welcome to the Aleo instructions guide. Aleo instructions is the intermediate representation of Aleo programs. All Leo programs compile to Aleo instructions which compile to bytecode. We recommend learning and using Aleo instructions if your goal is fine-grained circuit design or if you are implementing a compiler that reads in a high-level language other than Leo and want your programs to run on Aleo.

Aleo programs are files with a .aleo extension. Aleo programs contain Aleo instructions - an assembly-like programming language. Aleo instructions are compiled into AVM opcodes that can be executed by the Aleo Virtual Machine.

Install snarkVM to compile and execute Aleo instructions.

info
snarkVM is currently in active development. Please monitor the repository on GitHub for possibly breaking changes.

Installing snarkVM
Proceed to Installation for information on how to install snarkVM.

Hello Aleo Instructions
Develop your first Hello Aleo Aleo instructions program.

Aleo Instructions Guide
Learn the core concepts and syntax of Aleo instructions.

Read the full list of supported AVM opcodes.

Formal Language Documentation
Check your program or compiler implementation against the Aleo instructions grammar.

Study the formal ABNF grammar specification for the full formal syntax of Aleo instructions.

Additional Material
Install Aleo instructions for your favorite code editor.

Installation
1. Install the Prerequisites
1.1 Install Git:
bit.ly/start-git

1.2 Install Rust:
bit.ly/start-rust

1.3 Check the Prerequisites
git --version
cargo --version

2. Build Source Code
You can install snarkVM by building from the source code as follows:

# Download the source code
git clone https://github.com/AleoNet/snarkVM
cd snarkvm

# Build in release mode
$ cargo install --path .

This will generate the executable ~/.cargo/bin/snarkvm.

Now to use the snarkVM CLI, in your terminal, run:

snarkvm

info
Dive into some code with Hello Aleo.

Hello Aleo Instructions
1. Create and build a new project
To create a new project, we'll use the new command. Our project:

snarkvm new foo

This will create foo directory and the files with the basic structure of the project:

README.md having the skeleton of a README with instructions on how to compile.
main.aleo the main file of the source code.
program.json containing the identification of the project in JSON format. Particularly, a dev address and its private key for the program.
The main.aleo file should have contents like this:

// The 'foo.aleo' program.
program foo.aleo;

function hello:
    input r0 as u32.public;
    input r1 as u32.private;
    add r0 r1 into r2;
    output r2 as u32.private;


You can run a program with the snarkvm run command, followed by the function name you want to run and its input parameters:

snarkvm run hello 2u32 3u32

You will see output like this:

 ‚Ä¢ Loaded universal setup (in 1478 ms)

‚õì  Constraints

 ‚Ä¢  'foo.aleo/hello' - 33 constraints (called 1 time)

‚û°Ô∏è  Output

 ‚Ä¢ 5u32

‚úÖ Finished 'foo.aleo/hello' (in "/Users/collin/code/snarkVM/foo")


As you can see, the output has the 5u32 value, representing the sum of the inputs.

2. Executing a program
You can execute a program with the snarkvm execute command, followed by the function name you want to execute and its input parameters:

snarkvm execute hello 2u32 3u32

When the execution is finished, you should see the following output:

 ‚Ä¢ Loaded universal setup (in 1478 ms)

‚õì  Constraints

 ‚Ä¢  'foo.aleo/hello' - 33 constraints (called 1 time)

‚û°Ô∏è  Output

 ‚Ä¢ 5u32
 
  {"type":"execute","id":"at1 ... (transaction object truncated for brevity)

‚úÖ Executed 'foo.aleo/hello' (in "/Users/collin/code/snarkVM/foo")


As you can see, the output has the 5u32 value, representing the sum of the inputs.

A "universal setup" is loaded into your environment. You can read more about this in the Marlin paper.

Once the universal setup is ready, every function in your main.aleo file is built, generating this in the output folder:

hello.prover the prover for the hello function.
hello.verifier the verifier for the hello function.
main.avm the bytecode of your aleo program to be run by the VM.
As you can already guess, we have only one .avm file for the whole program, but a prover and verifier for every function.

3. Overview of a program
Let's examine the foo program inside the main.aleo file:

// The 'foo.aleo' program.
program foo.aleo;

function hello:
    input r0 as u32.public;
    input r1 as u32.private;
    add r0 r1 into r2;
    output r2 as u32.private;


First, we need to declare the program as the following:

program foo.aleo;

Afterwards, we can start writing its functions (or other Aleo structures such as structs, records, closures, as we will see later).

In the case of functions we have it very easy:

function [function_name]:

The functions are composed of three main parts:

The input section

Here we declare its input parameters:

    input r0 as u32.public;
    input r1 as u32.private;

Everything in Aleo instructions are declared/stored inside a register with a type (i8,field,bool, etc.) and a visibility option (public or private), registers are named as r0, r1, ..., rn.

In this case we use r0 and r1 to store the inputs passed in sequential order to a program as u32 values, where we can store 32-bit unsigned integers to perform our sum operation.

The instructions section

The next section consists of the core of our function: here we call the Aleo Instructions we need to make our program do what we want. For example, performing an addition operation:

    add r0 r1 into r2;

Every aleo instruction is followed by its input parameters with its specific types, and the result is stored in the register specified after into.

You can find all the available Aleo instruction opcodes here.

The output section

Similar to the input section, the output section does the same for the output of the program. It's the return of the function.

    output r2 as u32.private;

4. Types
Aleo uses a strongly-typed syntax. The language supports 16 primitive types, and allows users to define custom types.

The Aleo primitive types include:

address
boolean
field
group
i8
i16
i32
i64
i128
u8
u16
u32
u64
u128
scalar

Users can define custom types using the struct or record keywords. We will explore these in the next few sections.

4.1 Registers
Registers are the places where you store data to then be able to modify it.

4.2 Structs
Structs are user-defined data structures. They are very much like traditional structs in conventional programming languages. You can store structs into registers, like with any other Aleo data types.

For example, let's build a struct representing a fixed-size array of 3 elements. Add this at the bottom of the main.aleo file:

struct array3:
    a0 as u32;
    a1 as u32;
    a2 as u32;


Now, just for example purposes, let's code a function that adds one to each element of a register with an array3 data type stored in it.

function sum_one_to_array3:
    input r0 as array3.private;
    add r0.a0 1u32 into r1;
    add r0.a1 1u32 into r2;
    add r0.a2 1u32 into r3;
    cast r1 r2 r3 into r4 as array3;
    output r4 as array3.private;


As you can see, we can input a struct into register r0 and access struct elements with the . syntax. We perform the add instruction on every element, storing the results in registers r1, r2 and r3 and, finally, we make use of the cast command to create a new array3 struct into r4.

Now, let's run it. In this case, the only new thing you need to know is that structs are passed to the cli in the following format:

"{a0: 1u32, a1: 2u32, a2: 3u32}"

Now we can execute the snarkvm run command. We will clean the project to pick up the new code:

snarkvm clean && snarkvm run sum_one_to_array3 "{a0: 0u32, a1: 1u32, a2: 2u32}"


And we get the new array3 element as output:

‚û°Ô∏è  Output
 ‚Ä¢ {
  a0: 1u32,
  a1: 2u32,
  a2: 3u32
}
‚úÖ Executed 'foo.aleo/sum_one_to_array3' (in "[...]/foo")


4.3 Records
A record is a fundamental data structure for encoding user assets and application state. Records are very similar to structs, but they have one required component:

record token:
    owner as address.private


The owner refers to the Aleo address that owns the record.

Records are important because they represent the basic Aleo structure to handle state in your application.

When running an Aleo function, only registers that belong to the application address can be passed as input registers. Otherwise, an error is raised and the application doesn't run.

You can find your development application address inside the .env file:

{
    NETWORK=testnet
    PRIVATE_KEY=APrivateKey1zkpFsQNXJwdvjKs9bRsM91KcwJW1gW4CDtF3FJbgVBAvPds
}


4.4 Aleo State
In Aleo, the state of an application is managed through records. An Aleo account can create a transaction to consume a record and produce a new record in its place. Records in Aleo are encrypted to the record owner address, ensuring that all records in Aleo are fully private.

5. Your first Aleo Program: Making a transfer
Consider this program:

// The 'foo.aleo' program.
program foo.aleo;

record token:
    owner as address.private;
    amount as u64.private;

function mint:
    input r0 as u64.private;
    cast self.signer r0 into r1 as token.record;
    output r1 as token.record;

function transfer_amount:
    //  sender token record
    input r0 as token.record;
    // receiver address
    input r1 as address.private;
    // amount to transfer
    input r2 as u64.private;
    // final balance of sender
    sub r0.amount r2 into r3;
    // final balance of receiver
    add 0u64 r2 into r4;
    // sender token record after the transfer
    cast r0.owner r3 into r5 as token.record;
    // receiver token record after the transfer
    cast r1 r4 into r6 as token.record;
    // sender new token record
    output r5 as token.record;
    // receiver new token record
    output r6 as token.record;


First, we define our own record data type called token, that has the required parameter owner and a user-defined parameter called amount, representing the amount of tokens we have.

This transfer_amount function receives 3 input parameters (sender record, receiver record and amount) and stores them in 3 registers (r0, r1 and r2). After that, it computes the final balance for both of them and stores it in r3 and r4 (using sub and add instructions to compute the subtraction and addition respectively). With those final amounts, it creates the output records for sender and receiver, storing them in r5 and r6. Finally, both records are sent out of the function with the output instruction.

To run this function, the first parameter is the input record of the program. The format of this parameter is the same as for struct types:

{
  owner: aleo1x5nz5u4j50w482t5xtqc3jdwly9s8saaxlgjz0wvmuzmxv2l5q9qmypx09.private,
  amount: 50u64.private
}


Where:

owner: the public address of the program, as found in the PRIVATE_KEY of the .env file.
other parameters: depending on the program itself (in this example, we used the parameter amount with the value 50).
Let's run the transfer_amount function (if you are following along, remember to use the address found in the program.json for the owner field):

snarkvm clean && snarkvm run transfer_amount "{
owner: aleo1x5nz5u4j50w482t5xtqc3jdwly9s8saaxlgjz0wvmuzmxv2l5q9qmypx09.private,
amount: 50u64.private,
_nonce: 0group.public
}" aleo1h3gu7fky36y8r7v2x9phc434fgf20g8qd7c7u45v269jfw6vmugqjegcvp 10u64


We get the following output records:


‚õì  Constraints

 ‚Ä¢  'foo.aleo/transfer_amount' - 4,172 constraints (called 1 time)
 
‚û°Ô∏è  Outputs
 ‚Ä¢ {
  owner: aleo1x5nz5u4j50w482t5xtqc3jdwly9s8saaxlgjz0wvmuzmxv2l5q9qmypx09.private,
  amount: 40u64.private
  _nonce: 2293253577170800572742339369209137467208538700597121244293392265726446806023group.public
}
 ‚Ä¢ {
  owner: aleo1h3gu7fky36y8r7v2x9phc434fgf20g8qd7c7u45v269jfw6vmugqjegcvp.private,
  amount: 10u64.private
  _nonce: 2323253577170856894742339369235137467208538700597121244293392765726742543235group.public
}
‚úÖ Finished 'foo.aleo/transfer_amount' (in "[...]/foo")


And that's it. You have transferred your first owner-defined tokens in Aleo!

Note: the _nonce is not written in Aleo instructions. The compiler outputs the _nonce in record outputs. The user needs to provide it as input when using a record.

Aleo Instructions Language Guide
Statically Typed
Aleo instructions is a statically typed language, which means we must know the type of each variable before executing a circuit.

Explicit Types Required
There is no undefined or null value in Aleo instructions. When assigning a new variable, the type of the value must be explicitly stated.

Pass by Value
Expressions in Aleo instructions are always passed by value, which means their values are always copied when they are used as function inputs or in right sides of assignments.

Register based
There are no variable names in Aleo instructions. All variables are stored in registers denoted rX where X is a non-negative whole number starting from 0 r0, r1, r2, etc..

Data Types and Values
Booleans
Aleo instructions supports the traditional true or false boolean values. The explicit boolean type for booleans in statements is required.

function main:
    input r0: boolean.private;

Integers
Aleo instructions supports signed integer types i8, i16, i32, i64, i128 and unsigned integer types u8, u16, u32, u64, u128.

function main:
    input r0: u8.public;

info
Higher bit length integers generate more constraints in the circuit, which can slow down computation time.

Field Elements
Aleo instructions supports the field type for elements of the base field of the elliptic curve. These are unsigned integers less than the modulus of the base field, so the largest field element is 8444461749428370424248824938781546531375899335154063827935233455917409239040field.

function main:
    input r0: field.private;

Group Elements
The set of affine points on the elliptic curve passed into the Aleo instructions compiler forms a group. The curve is a Twisted Edwards curve with a = -1 and d = 3021. Aleo instructions supports a subgroup of the group, generated by a generator point, as a primitive data type. A group element is denoted by the x-coordinate of its point; for example, 2group means the point (2, 5553594316923449299484601589326170487897520766531075014687114064346375156608). The generator point is 1540945439182663264862696551825005342995406165131907382295858612069623286213group.

function main:
    input r0: group.private;

Scalar Elements
Aleo instructions supports the scalar type for elements of the scalar field defined by the elliptic curve subgroup. These are unsigned integers less than the modulus of the scalar field, so the largest scalar is 2111115437357092606062206234695386632838870926408408195193685246394721360382scalar.

function main:
    input r0: scalar.private;

Addresses
Addresses are defined to enable compiler-optimized routines for parsing and operating over addresses.

function main:
    input r0: address.private;

Signatures
Aleo uses a Schnorr signatures scheme to sign messages with an Aleo private key. Signatures can be verified in Aleo instructions using the sign.verify instruction.

sign.verify sign069ju4e8s66unu25celqycvsv3k9chdyz4n4sy62tx6wxj0u25vqp58hgu9hwyqc63qzxvjwesf2wz0krcvvw9kd9x0rsk4lwqn2acqhp9v0pdkhx6gvkanuuwratqmxa3du7l43c05253hhed9eg6ppzzfnjt06fpzp6msekdjxd36smjltndmxjndvv9x2uecsgngcwsc2qkns4afd r1 r2 into r3;


Layout of an Aleo Program
An Aleo program contains declarations of a Program ID, Imports, Functions, Closures, Structs, Records, Mappings, and Finalize. Ordering is only enforced for imports which must be at the top of file. Declarations are locally accessible within a program file. If you need a declaration from another program file, you must import it.

Program ID
A program ID is declared as {name}.{network}. The first character of a name must be lowercase. name can contain lowercase letters, numbers, and underscores. Currently, aleo is the only supported network domain.

program hello.aleo; // valid

program Foo.aleo;   // invalid
program baR.aleo;   // invalid
program 0foo.aleo;  // invalid
program 0_foo.aleo; // invalid
program _foo.aleo;  // invalid


Import
An import is declared as import {ProgramID};.
Imports fetch other declarations by their program ID and bring them into the current file scope. You can import dependencies that are downloaded to the imports directory.

import foo.aleo; // Import the `foo.aleo` program into the `hello.aleo` program.

program hello.aleo;


Function
A function is declared as function {name}:.
Functions contain instructions that can compute values. Functions must be in a program's current scope to be called.

function foo:
    input r0 as field.public;
    input r1 as field.private;
    add r0 r1 into r2;
    output r2 as field.private;


Function Inputs
A function input is declared as input {register} as {type}.{visibility};.
Function inputs must be declared just after the function name declaration.

// The function `foo` takes a single input `r0` with type `field` and visibility `public`.
function foo:
    input r0 as field.public;


Function Outputs
A function output is declared as output {register} as {type}.{visibility};.
Function outputs must be declared at the end of the function definition.

...
    output r0 as field.public;


Call a Function
In the Aleo protocol, calling a function creates a transition that can consume and produce records on-chain. Use the aleo run CLI command to pass inputs to a function and execute the program.
In Testnet, program functions cannot call other internal program functions. If you would like to develop "helper functions" that are called internally within a program, try writing a closure.

Call an Imported Function
Aleo programs can externally call other Aleo programs using the call {program}/{function} {register} into {register} instruction.

import foo.aleo;

program bar.aleo;

function call_external:
    input r0 as u64.private;
    call foo.aleo/baz r0 into r1; // Externally call function `baz` in foo.aleo with argument `r0` and store the result in `r1`.
    output r1 as u64.private;


Closure
A closure is declared as closure {name}:.
Closures contain instructions that can compute values. Closures are helper functions that cannot be executed directly. Closures may be called by other local or external functions, but cannot return records, nor do calls nor do awaits.

closure foo:
    input r0 as field;
    input r1 as field;
    add r0 r1 into r2;
    output r2 as field;


Call a Closure
Aleo programs can internally call other Aleo closures using the call {name} {register} into {register} instruction.

program bar.aleo;

function call_internal:
    input r0 as u64.private;
    call foo r0 into r1; // Internally call closure `foo` with argument `r0` and store the result in `r1`.
    output r1 as u64.private;


Struct
A struct is a data type declared as struct {name}:.
Structs contain component declarations {name} as {type}.

struct array3:
    a0 as u32;
    a1 as u32;
    a2 as u32;


To instantiate a struct in a program use the cast instruction.

function new_array3:
    input r0 as u32.private;
    input r1 as u32.private;
    input r2 as u32.private;
    cast r0 r1 r2 into r3 as array3;
    output r3 as array3.private;


Array
An array literal is written as [{value}, {value}, ..], where all the values are the same type. For example,

[true, false, true]

The type of an array includes the type of the elements and the length of the array [{type}; {length}]. The type of this example is

[boolean; 3u32]

Arrays can be initialized using the cast opcode.

function new_array:
    input r0 as boolean.private;
    input r1 as boolean.private;
    input r2 as boolean.private;
    cast r0 r1 r2 into r3 as [boolean; 3u32];
    output r3 as [boolean; 3u32].private;


Arrays can be indexed using {name}[{index}].

function get_array_element:
    input r0 as [boolean; 4u32].public;
    input r1 as u32.public;
    r0[r1] into r2;
    output r2 as boolean.public;


Arrays can be nested.

[[true, false, true, false], [false, true, false, true]]


function get_nested_array_element:
    input r0 as [[boolean; 4u32]; 2u32].public;
    r0[0u32][1u32] into r1;
    output r1 as boolean.public;


info
Aleo instructions currently only support fixed-length static arrays.

Record
A record type is declared as record {name}:.
Records contain component declarations {name} as {type}.{visibility};.
Record data structures must contain the owner declaration as shown below.
When passing a record as input to a program function the _nonce as group.{visibility} declaration is also required.

record token:
    // The token owner.
    owner as address.private;
    // The token amount.
    amount as u64.private;


To instantiate a record in a program use the cast instruction.

function new_token:
    input r0 as address.private;
    input r1 as u64.private;
    input r2 as u64.private;
    cast r0 r1 r2 into r3 as token.record;
    output r3 as token.record;


Special Operands
self.signer
The self.signer operand returns the user address that originated the transition.
This is particularly useful in intermediate programs that need to modify the state of the original caller rather than their own state.

In the example below, the transfer_public_as_signer function uses self.signer to decrement the balance from the original user's account rather than from the intermediate program's account.

// The `transfer_public_as_signer` function sends the specified amount
// from the signer's `account` to the receiver's `account`.
function transfer_public_as_signer:
    // Input the receiver.
    input r0 as address.public;
    // Input the amount.
    input r1 as u64.public;
    // Transfer the credits publicly.
    async transfer_public_as_signer self.signer r0 r1 into r2;
    // Output the finalize future.
    output r2 as credits.aleo/transfer_public_as_signer.future;

finalize transfer_public_as_signer:
    // Input the signer.
    input r0 as address.public;
    // Input the receiver.
    input r1 as address.public;
    // Input the amount.
    input r2 as u64.public;
    // Decrements `account[r0]` by `r2`.
    // If `account[r0] - r2` underflows, `transfer_public_as_signer` is reverted.
    get account[r0] into r3;
    sub r3 r2 into r4;
    set r4 into account[r0];
    // Increments `account[r1]` by `r2`.
    // If `account[r1]` does not exist, 0u64 is used.
    // If `account[r1] + r2` overflows, `transfer_public_as_signer` is reverted.
    get.or_use account[r1] 0u64 into r5;
    add r5 r2 into r6;
    set r6 into account[r1];


self.caller
The self.caller operand returns the address of the immediate caller of the program.

Mapping
A mapping is declared as mapping {name}:. Mappings contain key-value pairs and must be defined within a program.
Mappings are stored publicly on-chain. It is not possible to store data privately in a mapping.

// On-chain storage of an `account` map, with `owner` as the key,
// and `amount` as the value.
mapping account:
    // The token owner.
    key as address.public;
    // The token amount.
    value as u64.public;


Contains
A contains command that checks if a key exists in a mapping, e.g. contains accounts[r0] into r1;.

Get
A get command that retrieves a value from a mapping, e.g. get accounts[r0] into r1;.

Get or Use
A get command that uses the provided default in case of failure, e.g. get.or_use account[r1] 0u64 into r5;.

// The `transfer_public` function sends the specified amount
// from the caller's `account` to the receiver's `account`.
function transfer_public:
    // Input the receiver.
    input r0 as address.public;
    // Input the amount.
    input r1 as u64.public;
    // Transfer the credits publicly.
    async transfer_public self.caller r0 r1 into r2;
    // Output the finalize future.
    output r2 as credits.aleo/transfer_public.future;

finalize transfer_public:
    // Input the caller.
    input r0 as address.public;
    // Input the receiver.
    input r1 as address.public;
    // Input the amount.
    input r2 as u64.public;
    // Decrements `account[r0]` by `r2`.
    // If `account[r0] - r2` underflows, `transfer_public` is reverted.
    get account[r0] into r3;
    sub r3 r2 into r4;
    set r4 into account[r0];
    // Increments `account[r1]` by `r2`.
    // If `account[r1]` does not exist, 0u64 is used.
    // If `account[r1] + r2` overflows, `transfer_public` is reverted.
    get.or_use account[r1] 0u64 into r5;
    add r5 r2 into r6;
    set r6 into account[r1];


Set
A set command that sets a value in a mapping, e.g. set r0 into accounts[r0];.

Remove
A remove command that removes a key-value pair from a mapping, e.g. remove accounts[r0];.

Reading external program's mapping value
A program can also read an external program's mapping value. This enables your program to access and utilize data maintained by another program, making composability possible. e.g.:

// Import the external program whose mapping you want to read.
import credits.aleo;
program another_program.aleo;

function main:
    async main into r0;
    output r0 as another_program.aleo/main.future;

finalize main:
    // Read value from 'account' mapping in the external 'credits.aleo' program for the specified key.
    get credits.aleo/account[aleo1...] into r0;
    // Read value from 'account' mapping in the external 'credits.aleo' program for the specified key,
    // or use the default value 0u64 if the mapping does not exist.
    get.or_use credits.aleo/account[aleo1...] 0u64 into r1;


Finalize
A finalize is declared as finalize {name}:.
A finalize must immediately follow a function, and must have the same name;

// The `transfer_public_to_private` function turns a specified amount
// from the mapping `account` into a record for the specified receiver.
//
// This function publicly reveals the sender, the receiver, and the specified amount.
// However, subsequent methods using the receiver's record can preserve the receiver's privacy.
function transfer_public_to_private:
    // Input the receiver.
    input r0 as address.private;
    // Input the amount.
    input r1 as u64.public;
    // Construct a record for the receiver.
    cast r0 r1 into r2 as credits.record;
    // Decrement the balance of the sender publicly.
    async transfer_public_to_private self.caller r1 into r3;
    // Output the record of the receiver.
    output r2 as credits.record;
    // Output the finalize future.
    output r3 as credits.aleo/transfer_public_to_private.future;

finalize transfer_public_to_private:
    // Input the sender.
    input r0 as address.public;
    // Input the amount.
    input r1 as u64.public;
    // Retrieve the balance of the sender.
    get account[r0] into r2;
    // Decrements `account[r0]` by `r1`.
    // If `r2 - r1` underflows, `transfer_public_to_private` is reverted.
    sub r2 r1 into r3;
    // Updates the balance of the sender.
    set r3 into account[r0];


note
A finalize function is executed on chain after the zero-knowledge proof of the execution of the associated function is verified. If the finalize function succeeds, the program logic is executed.
If the finalize function fails, the program logic is reverted.

Futures
A future is equivalent to the call graph of the on-chain execution and is explicitly used when finalizing an execution. Instead of constructing the call graph implicitly from the code, the transition/circuit explicitly outputs a future, specifying which code blocks to run on-chain and how to run them.

future type
A user can declare a future type by specifying a Locator followed by the tag .future. For example, credits.aleo/mint_public.future. A function can only output a future and a finalize block can only take a future in as input. A closure cannot output a future or take a future in as input.

async call
A user can make an asynchronous call to the finalize block via the async keyword. For example, async mint_public r0 r1 into r2;. Note that the associated function must be specified. This operation produces a Future as output. async takes the place of the finalize command, which was allowed in the body of a function after the output statements.

await command
A user can evaluate a future inside of a finalize block using the await command. For example, await r0;. An await command can only be used in a finalize block. The operand must be a register containing a Future.

Indexing a future.
A register containing a future can be indexed using the existing index syntax. For example, r0[0u32]. This would get the input of the future at that specific index. Accesses can be nested to match the nested structure of a future.

Future example
program basic_math.aleo;

mapping uses:
    key user as address.public;
    value count as i64.public;

function add_and_count:
    input r0 as i64.private;
    input r1 as i64.private;
    add r0 r1 into r2;
    async add_and_count self.caller into r3;
    output r2 as i64.private;
    output r3 as basic_math.aleo/add_and_count.future;

finalize add_and_count:
    input r0 as address.public;
    get.or_use uses[r0] 0i64 into r1;
    add r1 1i64 into r2;
    set r2 into uses[r0];

function sub_and_count:
    input r0 as i64.private;
    input r1 as i64.private;
    sub r0 r1 into r2;
    async sub_and_count self.caller into r3;
    output r2 as i64.private;
    output r3 as basic_math.aleo/sub_and_count.future;

finalize sub_and_count:
    input r0 as address.public;
    get.or_use uses[r0] 0i64 into r1;
    add r1 1i64 into r2;
    set r2 into uses[r0];

/////////////////////////////////////////////////

import basic_math.aleo;

program count_usages.aleo;

function add_and_subtract:
    input r0 as i64.private;
    input r1 as i64.private;
    call basic_math.aleo/add_and_count r0 r1 into r2 r3;
    call basic_math.aleo/sub_and_count r2 r1 into r4 r5;
    assert.eq r0 r4;
    assert.eq r3[0u32] r5[0u32];
    async add_and_subtract r3 r5 into r6;
    output r0 as i64.private;
    output r6 as count_usages.aleo/add_and_subtract.future;

finalize add_and_subtract:
    input r0 as basic_math.aleo/add_and_count.future;
    input r1 as basic_math.aleo/sub_and_count.future;
    await r0;
    assert.eq r0[0u32] r1[0u32];
    await r1;


There are a number of rules associated with using these components.

If a function has a finalize block, it must have exactly one async instruction.
If a function has a finalize block, it's last output must be a future.
If a function does not have a finalize block, it cannot have an async instruction`.
All futures created by calls need to be input to the async instruction in the order they were produced.
An async call must reference the same function.
All calls must be made before invoking async.
The input futures types in a finalize block must match the order in which they were created in the function.
All futures in a finalize must be await-ed and in the order in which they were specified.
Instructions can be interleaved between invocations of call, async, and await.
Finalize Commands
The following commands are supported in Aleo Instructions to provide additional program functionality.

block.height
The block.height command returns the height of the block in which the program is executed (latest block height + 1).
This can be useful for managing time-based access control to a program.
The block.height command must be called within a finalize block.

assert.eq block.height 100u64;

block.timestamp
The block.timestamp command returns the unix timestamp of the current block within the finalize scope.
This can be useful for managing time-based access control to a program.
The block.timestamp command must be called within a finalize block.
The type returned is i64.

assert.eq block.timestamp 1767976339i64;

network.id
The network.id command returns the ID of the network on which the program is executed.
This can be useful for managing network-specific program behavior.
The network.id command must be called within a finalize block.

Currently supported network IDs are:

0: Mainnet
1: Testnet
2: Canarynet
rand.chacha
The rand.chacha command returns a random number generated by the ChaCha20 algorithm.
This command supports sampling a random address, boolean, field, group, i8, i16, i32, i64, i128, u8, u16, u32, u64, u128, and scalar.
Up to two additional seeds can be provided to the rand.chacha command.
Currently, only ChaCha20 is supported, however, in the future, other random number generators may be supported.

rand.chacha into r0 as field;
rand.chacha r0 into r1 as field;
rand.chacha r0 r1 into r2 as field;

Hash
Aleo Instructions supports the following syntax for hashing to standard types.

hash.bhp256 r0 into r1 as address;
hash.bhp256 r0 into r1 as field;
hash.bhp256 r0 into r1 as group;
hash.bhp256 r0 into r1 as i8;
hash.bhp256 r0 into r1 as i16;
hash.bhp256 r0 into r1 as i32;
hash.bhp256 r0 into r1 as i64;
hash.bhp256 r0 into r1 as i128;
hash.bhp256 r0 into r1 as u8;
hash.bhp256 r0 into r1 as u16;
hash.bhp256 r0 into r1 as u32;
hash.bhp256 r0 into r1 as u64;
hash.bhp256 r0 into r1 as u128;
hash.bhp256 r0 into r1 as scalar;
hash.bhp512 ...;
hash.bhp768 ...;
hash.bhp1024 ...;
hash.ped64 ...;
hash.ped128 ...;
hash.psd2 ...;
hash.psd4 ...;
hash.psd8 ...;

Checkout the Aleo Instructions opcodes for a full list of supported hashing algorithms.

Commit
Aleo Instructions supports the following syntax for committing to standard types.
Note that the commit command requires any type as the first argument, and a scalar as the second argument.

commit.bhp256 r0 r1 into r2 as address;
commit.bhp256 r0 r1 into r2 as field;
commit.bhp256 r0 r1 into r2 as group;
commit.bhp512 ...;
commit.bhp768 ...;
commit.bhp1024 ...;
commit.ped64 ...;
commit.ped128 ...;

Checkout the Aleo Instructions opcodes for a full list of supported commitment algorithms.

position, branch.eq, branch.neq
The position command, e.g. position exit, indicates a point to branch execution to.
The branch.eq command, e.g. branch.eq r0 r1 to exit, which branches execution to the position indicated by exit if r0 and r1 are equal.
The branch.neq command, e.g. branch.neq r0 r1 to exit, which branches execution to the position indicated by exit if r0 and r1 are not equal.

** Example ** The finalize block exits successfully if the input is 0u8 and fails otherwise.

program test_branch.aleo;

function run_test:
    input r0 as u8.public;
    finalize r0;

finalize run_test:
    input r0 as u8.public;
    branch.eq r0 0u8 to exit;
    assert.eq true false;
    position exit;

Program Interoperability
The examples in this section will use the following environment.

.env
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkpE37QxQynZuEGg3XxYrTuvhzWbkVaN5NgzCdEGzS43Ms5 # user private key
ADDRESS=aleo1p2h0p8mr2pwrvd0llf2rz6gvtunya8alc49xldr8ajmk3p2c0sqs4fl5mm # user address


Child and Parent Program
The following example demonstrates how a program parent.aleo can call another program child.aleo.

./imports/child.aleo
program child.aleo;

function foo:
    output self.caller as address.public;
    output self.signer as address.public;


./parent.aleo
import child.aleo;

program parent.aleo;

// Make an external program call from `parent.aleo` to `function foo` in `child.aleo`.
function foo:
    call child.aleo/foo into r0 r1;
    output r0 as address.public;
    output r1 as address.public;
    output self.caller as address.public;
    output self.signer as address.public;


$ snarkvm execute foo

‚õì  Constraints

 ‚Ä¢  'test.aleo/foo' - 2,025 constraints (called 1 time)
 ‚Ä¢  'child.aleo/foo' - 0 constraints (called 1 time)

‚û°Ô∏è  Outputs

 # The address of the caller of `child.aleo/foo` => `program.aleo`
 ‚Ä¢ aleo18tpu6k9g6yvp7uudmee954vgsvffcegzez4y8v8pru0m6k6zdsqqw6mx3t 
 
 # The address that originated the sequence of calls leading up to `child.aleo/foo` => user address
 ‚Ä¢ aleo1p2h0p8mr2pwrvd0llf2rz6gvtunya8alc49xldr8ajmk3p2c0sqs4fl5mm
 
 # The address of the caller of `program.aleo/foo` => user address
 ‚Ä¢ aleo1p2h0p8mr2pwrvd0llf2rz6gvtunya8alc49xldr8ajmk3p2c0sqs4fl5mm
 
 # The address that originated the sequence of calls leading up to `program.aleo/foo` => user address
 ‚Ä¢ aleo1p2h0p8mr2pwrvd0llf2rz6gvtunya8alc49xldr8ajmk3p2c0sqs4fl5mm


User Callable Program
By asserting assert.eq self.caller self.signer; on line 4, a developer can restrict their function such that it can only be called by users.

./imports/child.aleo
program child.aleo;

function foo:
    assert.eq self.caller self.signer; // This check should fail if called by another program.
    output self.caller as address.public;
    output self.signer as address.public;


./parent.aleo
import child.aleo;

program parent.aleo;

// Make an external program call from `parent.aleo` to `function foo` in `child.aleo`.
function foo:
    call child.aleo/foo into r0 r1;
    output r0 as address.public;
    output r1 as address.public;
    output self.caller as address.public;
    output self.signer as address.public;



$ snarkvm execute foo

‚ö†Ô∏è  Failed to evaluate instruction (call child.aleo/foo into r0 r1;):
Failed to evaluate instruction (assert.eq self.caller self.signer ;):
'assert.eq' failed: 
'aleo18tpu6k9g6yvp7uudmee954vgsvffcegzez4y8v8pru0m6k6zdsqqw6mx3t' 
is not equal to 
'aleo1p2h0p8mr2pwrvd0llf2rz6gvtunya8alc49xldr8ajmk3p2c0sqs4fl5mm' 
(should be equal)


Program Callable Program
By asserting assert.neq self.caller self.signer; on line 4, a developer can restrict their function such that it can only be called by other programs.

restrict.aleo
program restrict.aleo;

function foo:
    assert.neq self.caller self.signer; 
    output self.caller as address.public;
    output self.signer as address.public;


$ snarkvm execute foo

‚ö†Ô∏è  Failed to evaluate instruction (assert.neq self.caller self.signer ;):
'assert.neq' failed: 
'aleo1p2h0p8mr2pwrvd0llf2rz6gvtunya8alc49xldr8ajmk3p2c0sqs4fl5mm'
is equal to 
'aleo1p2h0p8mr2pwrvd0llf2rz6gvtunya8alc49xldr8ajmk3p2c0sqs4fl5mm'
(should not be equal)

Aleo Opcodes Reference
The following lists show the standard and cryptographic opcodes supported by Aleo instructions.

Table of Standard Opcodes
Name	Description
abs	Absolute value operation
abs.w	Wrapping absolute value operation
add	Addition operation
add.w	Wrapping addition operation
and	AND operation
assert.eq	Assert equality
assert.neq	Assert non-equality
branch.eq	Branches to a position if the arguments are equal
branch.neq	Branches to a position if the arguments are not equal
cast	Cast between literals
cast.lossy	Cast between literals with lossy truncation
div	Division operation
div.w	Wrapping division operation
double	Double operation
gt	Greater than comparison
gte	Greater than or equal to comparison
inv	Multiplicative inverse operation
is.eq	Equality comparison
is.neq	Not equal comparison
lt	Less than comparison
lte	Less than or equal to comparison
mod	Arithmetic modulo operation
mul	Multiplication operation
mul.w	Wrapping multiplication operation
nand	Boolean NAND operation
neg	Additive inverse operation
nor	Boolean NOR operation
not	NOT operation
or	OR Operation
position	The position command
pow	Exponentiation operation
pow.w	Wrapping exponentiation operation
rand.chacha	Generates a random value within the finalize scope.
rem	Remainder operation
rem.w	Wrapping remainder operation
shl	Shift left operation
shl.w	Wrapping shift left operation
shr	Shift right operation
shr.w	Wrapping shift right operation
sqrt	Square root operation
square	Square operation
sub	Subtraction operation
sub.w	Wrapping subtraction operation
ternary	Ternary select operation
xor	XOR operation
serialize.bits	Serialize value to bits array (Aleo variant bits)
serialize.bits.raw	Serialize value to bits array (raw bits)
deserialize.bits	Deserialize from bits array to value (Aleo variant bits)
deserialize.bits.raw	Deserialize from bits array to value (raw bits)
Table of Cryptographic Opcodes
Name	Description
commit.bhp256	256-bit input BHP commitment
commit.bhp512	512-bit input BHP commitment
commit.bhp768	768-bit input BHP commitment
commit.bhp1024	1024-bit input BHP commitment
commit.ped64	64-bit input Pedersen commitment
commit.ped128	128-bit input Pedersen commitment
hash.bhp256	256-bit input BHP hash
hash.bhp512	512-bit input BHP hash
hash.bhp768	768-bit input BHP hash
hash.bhp1024	1024-bit input BHP hash
hash.keccak256	256-bit input Keccak hash
hash.keccak384	384-bit input Keccak hash
hash.keccak512	512-bit input Keccak hash
hash.ped64	64-bit input Pedersen hash
hash.ped128	128-bit input Pedersen hash
hash.psd2	Poseidon hash with input rate 2
hash.psd4	Poseidon hash with input rate 4
hash.psd8	Poseidon hash with input rate 8
hash.sha3_256	256-bit input SHA3 hash
hash.sha3_384	384-bit input SHA3 hash
hash.sha3_512	512-bit input SHA3 hash
hash.bhp256.raw	256-bit input BHP hash (raw bits)
hash.bhp512.raw	512-bit input BHP hash (raw bits)
hash.bhp768.raw	768-bit input BHP hash (raw bits)
hash.bhp1024.raw	1024-bit input BHP hash (raw bits)
hash.keccak256.raw	256-bit input Keccak hash (raw bits)
hash.keccak384.raw	384-bit input Keccak hash (raw bits)
hash.keccak512.raw	512-bit input Keccak hash (raw bits)
hash.ped64.raw	64-bit input Pedersen hash (raw bits)
hash.ped128.raw	128-bit input Pedersen hash (raw bits)
hash.psd2.raw	Poseidon hash with input rate 2 (raw bits)
hash.psd4.raw	Poseidon hash with input rate 4 (raw bits)
hash.psd8.raw	Poseidon hash with input rate 8 (raw bits)
hash.sha3_256.raw	256-bit input SHA3 hash (raw bits)
hash.sha3_384.raw	384-bit input SHA3 hash (raw bits)
hash.sha3_512.raw	512-bit input SHA3 hash (raw bits)
hash.keccak256.native	256-bit input Keccak hash (outputs bit array)
hash.keccak256.native.raw	256-bit input Keccak hash (raw bits, outputs bit array)
hash.keccak384.native	384-bit input Keccak hash (outputs bit array)
hash.keccak384.native.raw	384-bit input Keccak hash (raw bits, outputs bit array)
hash.keccak512.native	512-bit input Keccak hash (outputs bit array)
hash.keccak512.native.raw	512-bit input Keccak hash (raw bits, outputs bit array)
hash.sha3_256.native	256-bit input SHA3 hash (outputs bit array)
hash.sha3_256.native.raw	256-bit input SHA3 hash (raw bits, outputs bit array)
hash.sha3_384.native	384-bit input SHA3 hash (outputs bit array)
hash.sha3_384.native.raw	384-bit input SHA3 hash (raw bits, outputs bit array)
hash.sha3_512.native	512-bit input SHA3 hash (outputs bit array)
hash.sha3_512.native.raw	512-bit input SHA3 hash (raw bits, outputs bit array)
sign.verify	Verify a Schnorr signature
ecdsa.verify.digest	Verify an ECDSA signature with pre-computed digest
ecdsa.verify.digest.eth	Verify an ECDSA signature with pre-computed digest (Ethereum 20-byte address)
ecdsa.verify.keccak256	Verify an ECDSA signature with Keccak-256 (Aleo variant bits)
ecdsa.verify.keccak256.raw	Verify an ECDSA signature with Keccak-256 (raw bits)
ecdsa.verify.keccak256.eth	Verify an ECDSA signature with Keccak-256 (raw bits + Ethereum 20-byte address)
ecdsa.verify.keccak384	Verify an ECDSA signature with Keccak-384 (Aleo variant bits)
ecdsa.verify.keccak384.raw	Verify an ECDSA signature with Keccak-384 (raw bits)
ecdsa.verify.keccak384.eth	Verify an ECDSA signature with Keccak-384 (raw bits + Ethereum 20-byte address)
ecdsa.verify.keccak512	Verify an ECDSA signature with Keccak-512 (Aleo variant bits)
ecdsa.verify.keccak512.raw	Verify an ECDSA signature with Keccak-512 (raw bits)
ecdsa.verify.keccak512.eth	Verify an ECDSA signature with Keccak-512 (raw bits + Ethereum 20-byte address)
ecdsa.verify.sha3_256	Verify an ECDSA signature with SHA3-256 (Aleo variant bits)
ecdsa.verify.sha3_256.raw	Verify an ECDSA signature with SHA3-256 (raw bits)
ecdsa.verify.sha3_256.eth	Verify an ECDSA signature with SHA3-256 (raw bits + Ethereum 20-byte address)
ecdsa.verify.sha3_384	Verify an ECDSA signature with SHA3-384 (Aleo variant bits)
ecdsa.verify.sha3_384.raw	Verify an ECDSA signature with SHA3-384 (raw bits)
ecdsa.verify.sha3_384.eth	Verify an ECDSA signature with SHA3-384 (raw bits + Ethereum 20-byte address)
ecdsa.verify.sha3_512	Verify an ECDSA signature with SHA3-512 (Aleo variant bits)
ecdsa.verify.sha3_512.raw	Verify an ECDSA signature with SHA3-512 (raw bits)
ecdsa.verify.sha3_512.eth	Verify an ECDSA signature with SHA3-512 (raw bits + Ethereum 20-byte address)
Specification
The following is the specification for each opcode in the Aleo Virtual Machine (AVM).

abs
Back to Top

Description
Computes the absolute value of the input, checking for overflow, storing the result in the destination register.

For integer types, a constraint is added to check for underflow. For cases where wrapping semantics are needed, see the abs.w instruction. This underflow happens when the input is the minimum value of a signed integer type. For example, abs -128i8 would result in underflow, since 128 cannot be represented as an i8.

Example Usage
abs r0 into r1;

Supported Types
Input	Destination
I8	I8
I16	I16
I32	I32
I64	I64
I128	I128
abs.w
Back to Top

Description
Compute the absolute value of the input, wrapping around at the boundary of the type, and storing the result in the destination register.

Example Usage
abs.w r0 into r1;

Supported Types
Input	Destination
I8	I8
I16	I16
I32	I32
I64	I64
I128	I128
add
Back to Top

Description
Adds first with second, storing the outcome in destination.

For integer types, a constraint is added to check for overflow. For cases where wrapping semantics are needed for integer types, see the add.w instruction.

Example Usage
add r0 r1 into r2;

Supported Types
First	Second	Destination
Field	Field	Field
Group	Group	Group
I8	I8	I8
I16	I16	I16
I32	I32	I32
I64	I64	I64
I128	I128	I128
U8	U8	U8
U16	U16	U16
U32	U32	U32
U64	U64	U64
U128	U128	U128
Scalar	Scalar	Scalar
add.w
Back to Top

Description
Adds first with second, wrapping around at the boundary of the type, and storing the outcome in destination.

Example Usage
add.w r0 r1 into r2;

Supported Types
First	Second	Destination
I8	I8	I8
I16	I16	I16
I32	I32	I32
I64	I64	I64
I128	I128	I128
U8	U8	U8
U16	U16	U16
U32	U32	U32
U64	U64	U64
U128	U128	U128
and
Back to Top

Description
Performs an AND operation on integer (bitwise) or boolean first and second, storing the outcome in destination.

Example Usage
and r0 r1 into r2;

Supported Types
First	Second	Destination
Boolean	Boolean	Boolean
I8	I8	I8
I16	I16	I16
I32	I32	I32
I64	I64	I64
I128	I128	I128
U8	U8	U8
U16	U16	U16
U32	U32	U32
U64	U64	U64
U128	U128	U128
assert.eq
Back to Top

Description
Checks whether first and second are equal, halting if they are not equal.

Example Usage
assert.eq r0 r1;

Supported Types
First	Second
Address	Address
Boolean	Boolean
Field	Field
Group	Group
I8	I8
I16	I16
I32	I32
I64	I64
I128	I128
U8	U8
U16	U16
U32	U32
U64	U64
U128	U128
Scalar	Scalar
Signature	Signature
Struct	Struct
Record	Record
assert.neq
Back to Top

Description
Checks whether first and second are not equal, halting if they are equal.

Example Usage
assert.neq r0 r1;

Supported Types
First	Second
Address	Address
Boolean	Boolean
Field	Field
Group	Group
I8	I8
I16	I16
I32	I32
I64	I64
I128	I128
U8	U8
U16	U16
U32	U32
U64	U64
U128	U128
Scalar	Scalar
Signature	Signature
Struct	Struct
Record	Record
branch.eq
Back to Top

Description
The command branch.eq <first> <second> to <destination> branches execution to the position indicated by destination if first and second are equal. This command is restricted to the finalize scope, and the destination must follow the command. Backward branches are not currently supported.

Example Usage
branch.eq r0 r1 to skip;

First	Second	Destination
Address	Address	Position
Boolean	Boolean	Position
Field	Field	Position
Group	Group	Position
I8	I8	Position
I16	I16	Position
I32	I32	Position
I64	I64	Position
I128	I128	Position
U8	U8	Position
U16	U16	Position
U32	U32	Position
U64	U64	Position
U128	U128	Position
Scalar	Scalar	Position
Struct	Struct	Position
Record	Record	Position
branch.neq
Back to Top

Description
The command branch.neq <first> <second> to <destination> branches execution to the position indicated by destination if first and second are not equal. This command is restricted to the finalize scope, and the destination must follow the command. Backward branches are not currently supported.

Example Usage
branch.neq r0 r1 to process;

First	Second	Destination
Address	Address	Position
Boolean	Boolean	Position
Field	Field	Position
Group	Group	Position
I8	I8	Position
I16	I16	Position
I32	I32	Position
I64	I64	Position
I128	I128	Position
U8	U8	Position
U16	U16	Position
U32	U32	Position
U64	U64	Position
U128	U128	Position
Scalar	Scalar	Position
Struct	Struct	Position
Record	Record	Position
cast
Back to Top

Description
Enables casting between different literals.

Example Usage
input r0 as field.private;
cast r0 into r1 as group;
cast r0 into r2 as u8;
cast r3 r4 r5 r6 into r7 as [boolean; 4u32];
cast r7 into r8 as [[boolean; 4u32]; 1u32];

Supported Types
From	To
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Elements	To
Address	Array, Struct
Boolean	Array, Struct
Field	Array, Struct
Group	Array, Struct
I8	Array, Struct
I16	Array, Struct
I32	Array, Struct
I64	Array, Struct
I128	Array, Struct
U8	Array, Struct
U16	Array, Struct
U32	Array, Struct
U64	Array, Struct
U128	Array, Struct
Scalar	Array, Struct
cast.lossy
Back to Top

Description
Perform casting with lossy truncation.

Example Usage
input r0 as field.private;
cast r0 into r1 as group;
cast r0 into r2 as u8;
cast.lossy r0 into r3 as u8; // The bottom 8 bits of the r0 are extracted into a u8 and placed into r3


Supported Types
From	To
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
commit.bhp256
Back to Top

Description
Computes a Bowe-Hopwood-Pedersen commitment on inputs of 256-bit chunks in first, and some randomness in second, storing the commitment in destination. Randomness should always be a Scalar value, and the produced commitment will always be an Address, Field, or Group value, as specified via as at the end of the instruction.

The compiler will throw an error if the given input is smaller than 129 bits.

Example Usage
commit.bhp256 r0 r1 into r2 as address;

Supported Types
First	Second	Destination
Address	Scalar	Address, Field, Group
Boolean	Scalar	Address, Field, Group
Field	Scalar	Address, Field, Group
Group	Scalar	Address, Field, Group
I8	Scalar	Address, Field, Group
I16	Scalar	Address, Field, Group
I32	Scalar	Address, Field, Group
I64	Scalar	Address, Field, Group
I128	Scalar	Address, Field, Group
U8	Scalar	Address, Field, Group
U16	Scalar	Address, Field, Group
U32	Scalar	Address, Field, Group
U64	Scalar	Address, Field, Group
U128	Scalar	Address, Field, Group
Scalar	Scalar	Address, Field, Group
Struct	Scalar	Address, Field, Group
Array	Scalar	Address, Field, Group
commit.bhp512
Back to Top

Description
Computes a Bowe-Hopwood-Pedersen commitment on inputs of 512-bit chunks in first, and some randomness in second, storing the commitment in destination. Randomness should always be a Scalar value, and the produced commitment will always be an Address, Field, or Group value, as specified via as at the end of the instruction.

The compiler will throw an error if the given input is smaller than 171 bits.

Example Usage
commit.bhp512 r0 r1 into r2 as field;

Supported Types
First	Second	Destination
Address	Scalar	Address, Field, Group
Boolean	Scalar	Address, Field, Group
Field	Scalar	Address, Field, Group
Group	Scalar	Address, Field, Group
I8	Scalar	Address, Field, Group
I16	Scalar	Address, Field, Group
I32	Scalar	Address, Field, Group
I64	Scalar	Address, Field, Group
I128	Scalar	Address, Field, Group
U8	Scalar	Address, Field, Group
U16	Scalar	Address, Field, Group
U32	Scalar	Address, Field, Group
U64	Scalar	Address, Field, Group
U128	Scalar	Address, Field, Group
Scalar	Scalar	Address, Field, Group
Struct	Scalar	Address, Field, Group
Array	Scalar	Address, Field, Group
commit.bhp768
Back to Top

Description
Computes a Bowe-Hopwood-Pedersen commitment on inputs of 768-bit chunks in first, and some randomness in second, storing the commitment in destination. Randomness should always be a Scalar value, and the produced commitment will always be an Address, Field, or Group value, as specified via as at the end of the instruction.

The compiler will throw an error if the given input is smaller than 129 bits.

Example Usage
commit.bhp768 r0 r1 into r2 as group;

Supported Types
First	Second	Destination
Address	Scalar	Address, Field, Group
Boolean	Scalar	Address, Field, Group
Field	Scalar	Address, Field, Group
Group	Scalar	Address, Field, Group
I8	Scalar	Address, Field, Group
I16	Scalar	Address, Field, Group
I32	Scalar	Address, Field, Group
I64	Scalar	Address, Field, Group
I128	Scalar	Address, Field, Group
U8	Scalar	Address, Field, Group
U16	Scalar	Address, Field, Group
U32	Scalar	Address, Field, Group
U64	Scalar	Address, Field, Group
U128	Scalar	Address, Field, Group
Scalar	Scalar	Address, Field, Group
Struct	Scalar	Address, Field, Group
Array	Scalar	Address, Field, Group
commit.bhp1024
Back to Top

Description
Computes a Bowe-Hopwood-Pedersen commitment on inputs of 1024-bit chunks in first, and some randomness in second, storing the commitment in destination. Randomness should always be a Scalar value, and the produced commitment will always be an Address, Field, or Group value, as specified via as at the end of the instruction.

The compiler will throw an error if the given input is smaller than 171 bits.

Example Usage
commit.bhp1024 r0 r1 into r2 as address;

Supported Types
First	Second	Destination
Address	Scalar	Address, Field, Group
Boolean	Scalar	Address, Field, Group
Field	Scalar	Address, Field, Group
Group	Scalar	Address, Field, Group
I8	Scalar	Address, Field, Group
I16	Scalar	Address, Field, Group
I32	Scalar	Address, Field, Group
I64	Scalar	Address, Field, Group
I128	Scalar	Address, Field, Group
U8	Scalar	Address, Field, Group
U16	Scalar	Address, Field, Group
U32	Scalar	Address, Field, Group
U64	Scalar	Address, Field, Group
U128	Scalar	Address, Field, Group
Scalar	Scalar	Address, Field, Group
Struct	Scalar	Address, Field, Group
Array	Scalar	Address, Field, Group
commit.ped64
Back to Top

Description
Computes a Pedersen commitment up to a 64-bit input in first, and some randomness in second, storing the commitment in destination. Randomness should always be a Scalar value, and the produced commitment is an Address, Field, or Group value, as specified via as at the end of the instruction.

The compiler will throw an error if the given Struct value exceeds the 64-bit limit.

Example Usage
commit.ped64 r0 r1 into r2 as field;

Supported Types
First	Second	Destination
Boolean	Scalar	Address, Field, Group
I8	Scalar	Address, Field, Group
I16	Scalar	Address, Field, Group
I32	Scalar	Address, Field, Group
U8	Scalar	Address, Field, Group
U16	Scalar	Address, Field, Group
U32	Scalar	Address, Field, Group
Struct	Scalar	Address, Field, Group
Array	Scalar	Address, Field, Group
commit.ped128
Back to Top

Description
Computes a Pedersen commitment up to a 128-bit input in first, and some randomness in second, storing the commitment in destination. Randomness should always be a Scalar value, and the produced commitment is an Address, Field, or Group value, as specified via as at the end of the instruction.

The compiler will throw an error if the given Struct value exceeds the 128-bit limit.

Example Usage
commit.ped128 r0 r1 into r2 as group;

Supported Types
First	Second	Destination
Boolean	Scalar	Address, Field, Group
I8	Scalar	Address, Field, Group
I16	Scalar	Address, Field, Group
I32	Scalar	Address, Field, Group
I64	Scalar	Address, Field, Group
U8	Scalar	Address, Field, Group
U16	Scalar	Address, Field, Group
U32	Scalar	Address, Field, Group
U64	Scalar	Address, Field, Group
Struct	Scalar	Address, Field, Group
Array	Scalar	Address, Field, Group
div
Back to Top

Description
Divides first by second, storing the outcome in destination. Halts on division by zero.

For integer types, this operation performs truncated division. Furthermore, a constraint is added to check for underflow. This underflow happens when dividing the minimum value of a signed integer type by -1. For example, div -128i8 -1i8 would result in underflow, since 128 cannot be represented as an i8.

For cases where wrapping semantics are needed for integer types, see the div.w instruction.

Example Usage
div r0 r1 into r2;

Supported Types
First	Second	Destination
Field	Field	Field
I8	I8	I8
I16	I16	I16
I32	I32	I32
I64	I64	I64
I128	I128	I128
U8	U8	U8
U16	U16	U16
U32	U32	U32
U64	U64	U64
U128	U128	U128
div.w
Back to Top

Description
Divides first by second, wrapping around at the boundary of the type, and storing the outcome in destination.

Example Usage
div.w r0 r1 into r2;

Supported Types
First	Second	Destination
I8	I8	I8
I16	I16	I16
I32	I32	I32
I64	I64	I64
I128	I128	I128
U8	U8	U8
U16	U16	U16
U32	U32	U32
U64	U64	U64
U128	U128	U128
double
Back to Top

Description
Doubles the input, storing the outcome in destination.

Example Usage
double r0 into r1;

Supported Types
Input	Destination
Field	Field
Group	Group
gt
Back to Top

Description
Checks if first is greater than second, storing the result in destination.

Example Usage
gt r0 r1 into r2;

Supported Types
First	Second	Destination
Field	Field	Boolean
I8	I8	Boolean
I16	I16	Boolean
I32	I32	Boolean
I64	I64	Boolean
I128	I128	Boolean
U8	U8	Boolean
U16	U16	Boolean
U32	U32	Boolean
U64	U64	Boolean
U128	U128	Boolean
Scalar	Scalar	Boolean
gte
Back to Top

Description
Checks if first is greater than or equal to second, storing the result in destination.

Example Usage
gte r0 r1 into r2;

Supported Types
First	Second	Destination
Field	Field	Boolean
I8	I8	Boolean
I16	I16	Boolean
I32	I32	Boolean
I64	I64	Boolean
I128	I128	Boolean
U8	U8	Boolean
U16	U16	Boolean
U32	U32	Boolean
U64	U64	Boolean
U128	U128	Boolean
Scalar	Scalar	Boolean
hash.bhp256
Back to Top

Description
Computes a Bowe-Hopwood-Pedersen hash on inputs of 256-bit chunks in first, storing the hash in destination. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

The compiler will throw an error if the given input is smaller than 129 bits.

Example Usage
hash.bhp256 r0 into r1 as address;

Supported Types
First	Destination
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.bhp512
Back to Top

Description
Computes a Bowe-Hopwood-Pedersen hash on inputs of 512-bit chunks in first, storing the hash in destination. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

The compiler will throw an error if the given input is smaller than 171 bits.

Example Usage
hash.bhp512 r0 into r1 as field;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.bhp768
Back to Top

Description
Computes a Bowe-Hopwood-Pedersen hash on inputs of 768-bit chunks in first, storing the hash in destination. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

The compiler will throw an error if the given input is smaller than 129 bits.

Example Usage
hash.bhp768 r0 into r1 as group;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.bhp1024
Back to Top

Description
Computes a Bowe-Hopwood-Pedersen hash on inputs of 1024-bit chunks in first, storing the hash in destination. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

The compiler will throw an error if the given input is smaller than 171 bits.

Example Usage
hash.bhp1024 r0 into r1 as scalar;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.keccak256
Back to Top

Description
Performs a Keccak hash on first, storing a 256-bit digest in destination. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

Example Usage
hash.keccak256 r0 into r1 as address;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.keccak384
Back to Top

Description
Performs a Keccak hash on first, storing a 384-bit digest in destination. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

Example Usage
hash.keccak384 r0 into r1 as field;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.keccak512
Back to Top

Description
Performs a Keccak hash on first, storing a 512-bit digest in destination. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

Example Usage
hash.keccak512 r0 into r1 as group;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.ped64
Back to Top

Description
Computes a Pedersen hash up to a 64-bit input in first, storing the hash in destination. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

The compiler will throw an error if the given Struct value exceeds the 64-bit limit.

Example Usage
hash.ped64 r0 into r1 as address;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.ped128
Back to Top

Description
Computes a Pedersen hash up to a 128-bit input in first, storing the hash in destination. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

The compiler will throw an error if the given Struct value exceeds the 128-bit limit.

Example Usage
hash.ped128 r0 into r1 as field;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.psd2
Back to Top

Description
Calculates a Poseidon hash with an input rate of 2, from an input in first, storing the hash in destination. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

Example Usage
hash.psd2 r0 into r1 as group;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.psd4
Back to Top

Description
Calculates a Poseidon hash with an input rate of 4, from an input in first, storing the hash in destination. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

Example Usage
hash.psd4 r0 into r1 as scalar;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.psd8
Back to Top

Description
Calculates a Poseidon hash with an input rate of 8, from an input in first, storing the hash in destination. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

Example Usage
hash.psd8 r0 into r1 as address;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.sha3_256
Back to Top

Description
Calculates a SHA3-256 hash, from an input in first, storing the 256-bit digest in destination. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

Example Usage
hash.sha3_256 r0 into r1 as field;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.sha3_384
Back to Top

Description
Calculates a SHA3-384 hash, from an input in first, storing the 384-bit digest in destination. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

Example Usage
hash.sha3_384 r0 into r1 as group;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.sha3_512
Back to Top

Description
Calculates a SHA3-512 hash, from an input in first, storing the 512-bit digest in destination. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

Example Usage
hash.sha3_512 r0 into r1 as scalar;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.bhp256.raw
Back to Top

Description
Computes a Bowe-Hopwood-Pedersen hash on inputs of 256-bit chunks in first, storing the hash in destination. This variant uses raw bit form without Aleo variant bits. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

The compiler will throw an error if the given input is smaller than 129 bits.

Example Usage
hash.bhp256.raw r0 into r1 as address;

Supported Types
First	Destination
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.bhp512.raw
Back to Top

Description
Computes a Bowe-Hopwood-Pedersen hash on inputs of 512-bit chunks in first, storing the hash in destination. This variant uses raw bit form without Aleo variant bits. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

The compiler will throw an error if the given input is smaller than 171 bits.

Example Usage
hash.bhp512.raw r0 into r1 as address;

Supported Types
First	Destination
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.bhp768.raw
Back to Top

Description
Computes a Bowe-Hopwood-Pedersen hash on inputs of 768-bit chunks in first, storing the hash in destination. This variant uses raw bit form without Aleo variant bits. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

The compiler will throw an error if the given input is smaller than 213 bits.

Example Usage
hash.bhp768.raw r0 into r1 as address;

Supported Types
First	Destination
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.bhp1024.raw
Back to Top

Description
Computes a Bowe-Hopwood-Pedersen hash on inputs of 1024-bit chunks in first, storing the hash in destination. This variant uses raw bit form without Aleo variant bits. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

The compiler will throw an error if the given input is smaller than 255 bits.

Example Usage
hash.bhp1024.raw r0 into r1 as address;

Supported Types
First	Destination
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.keccak256.raw
Back to Top

Description
Performs a Keccak hash on first, storing a 256-bit digest in destination. This variant uses raw bit form without Aleo variant bits. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

Example Usage
hash.keccak256.raw r0 into r1 as address;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.keccak384.raw
Back to Top

Description
Performs a Keccak hash on first, storing a 384-bit digest in destination. This variant uses raw bit form without Aleo variant bits. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

Example Usage
hash.keccak384.raw r0 into r1 as field;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.keccak512.raw
Back to Top

Description
Performs a Keccak hash on first, storing a 512-bit digest in destination. This variant uses raw bit form without Aleo variant bits. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

Example Usage
hash.keccak512.raw r0 into r1 as field;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.ped64.raw
Back to Top

Description
Computes a Pedersen hash up to a 64-bit input in first, storing the hash in destination. This variant uses raw bit form without Aleo variant bits. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

The compiler will throw an error if the given Struct value exceeds the 64-bit limit.

Example Usage
hash.ped64.raw r0 into r1 as address;

Supported Types
First	Destination
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.ped128.raw
Back to Top

Description
Computes a Pedersen hash up to a 128-bit input in first, storing the hash in destination. This variant uses raw bit form without Aleo variant bits. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

The compiler will throw an error if the given Struct value exceeds the 128-bit limit.

Example Usage
hash.ped128.raw r0 into r1 as address;

Supported Types
First	Destination
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.psd2.raw
Back to Top

Description
Calculates a Poseidon hash with an input rate of 2, from an input in first, storing the hash in destination. This variant uses raw bit form without Aleo variant bits. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

Example Usage
hash.psd2.raw r0 into r1 as group;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.psd4.raw
Back to Top

Description
Calculates a Poseidon hash with an input rate of 4, from an input in first, storing the hash in destination. This variant uses raw bit form without Aleo variant bits. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

Example Usage
hash.psd4.raw r0 into r1 as group;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.psd8.raw
Back to Top

Description
Calculates a Poseidon hash with an input rate of 8, from an input in first, storing the hash in destination. This variant uses raw bit form without Aleo variant bits. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

Example Usage
hash.psd8.raw r0 into r1 as address;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.sha3_256.raw
Back to Top

Description
Calculates a SHA3-256 hash, from an input in first, storing the 256-bit digest in destination. This variant uses raw bit form without Aleo variant bits. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

Example Usage
hash.sha3_256.raw r0 into r1 as field;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.sha3_384.raw
Back to Top

Description
Calculates a SHA3-384 hash, from an input in first, storing the 384-bit digest in destination. This variant uses raw bit form without Aleo variant bits. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

Example Usage
hash.sha3_384.raw r0 into r1 as group;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.sha3_512.raw
Back to Top

Description
Calculates a SHA3-512 hash, from an input in first, storing the 512-bit digest in destination. This variant uses raw bit form without Aleo variant bits. The produced hash will always be an arithmetic (U8, U16, U32, U64, U128, I8, I16, I32,I64,I128, Field, Group, or Scalar) or Address value, as specified via as at the end of the instruction.

Example Usage
hash.sha3_512.raw r0 into r1 as scalar;

Supported Types
First	Destination
Array	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Address	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Boolean	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Field	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Group	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
I128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U8	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U16	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U32	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U64	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
U128	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Scalar	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
Struct	Address, Field, Group, Scalar, I8, I16, I32,I64,I128, U8, U16, U32, U64, U128
hash.keccak256.native
Back to Top

Description
Performs a Keccak hash on first, storing a 256-bit digest as a bit array in destination. This variant performs the underlying hash returning a bit array [bool; 256].

Example Usage
hash.keccak256.native r0 into r1;

Supported Types
First	Destination
Array	[bool; 256]
Address	[bool; 256]
Boolean	[bool; 256]
Field	[bool; 256]
Group	[bool; 256]
I8	[bool; 256]
I16	[bool; 256]
I32	[bool; 256]
I64	[bool; 256]
I128	[bool; 256]
U8	[bool; 256]
U16	[bool; 256]
U32	[bool; 256]
U64	[bool; 256]
U128	[bool; 256]
Scalar	[bool; 256]
Struct	[bool; 256]
hash.keccak256.native.raw
Back to Top

Description
Performs a Keccak hash on first, storing a 256-bit digest as a bit array in destination. This variant uses raw bit form without Aleo variant bits and performs the underlying hash returning a bit array [bool; 256].

Example Usage
hash.keccak256.native.raw r0 into r1;

Supported Types
First	Destination
Array	[bool; 256]
Address	[bool; 256]
Boolean	[bool; 256]
Field	[bool; 256]
Group	[bool; 256]
I8	[bool; 256]
I16	[bool; 256]
I32	[bool; 256]
I64	[bool; 256]
I128	[bool; 256]
U8	[bool; 256]
U16	[bool; 256]
U32	[bool; 256]
U64	[bool; 256]
U128	[bool; 256]
Scalar	[bool; 256]
Struct	[bool; 256]
hash.keccak384.native
Back to Top

Description
Performs a Keccak hash on first, storing a 384-bit digest as a bit array in destination. This variant performs the underlying hash returning a bit array [bool; 384].

Example Usage
hash.keccak384.native r0 into r1;

Supported Types
First	Destination
Array	[bool; 384]
Address	[bool; 384]
Boolean	[bool; 384]
Field	[bool; 384]
Group	[bool; 384]
I8	[bool; 384]
I16	[bool; 384]
I32	[bool; 384]
I64	[bool; 384]
I128	[bool; 384]
U8	[bool; 384]
U16	[bool; 384]
U32	[bool; 384]
U64	[bool; 384]
U128	[bool; 384]
Scalar	[bool; 384]
Struct	[bool; 384]
hash.keccak384.native.raw
Back to Top

Description
Performs a Keccak hash on first, storing a 384-bit digest as a bit array in destination. This variant uses raw bit form without Aleo variant bits and performs the underlying hash returning a bit array [bool; 384].

Example Usage
hash.keccak384.native.raw r0 into r1;

Supported Types
First	Destination
Array	[bool; 384]
Address	[bool; 384]
Boolean	[bool; 384]
Field	[bool; 384]
Group	[bool; 384]
I8	[bool; 384]
I16	[bool; 384]
I32	[bool; 384]
I64	[bool; 384]
I128	[bool; 384]
U8	[bool; 384]
U16	[bool; 384]
U32	[bool; 384]
U64	[bool; 384]
U128	[bool; 384]
Scalar	[bool; 384]
Struct	[bool; 384]
hash.keccak512.native
Back to Top

Description
Performs a Keccak hash on first, storing a 512-bit digest as a bit array in destination. This variant performs the underlying hash returning a bit array [bool; 512].

Example Usage
hash.keccak512.native r0 into r1;

Supported Types
First	Destination
Array	[bool; 512]
Address	[bool; 512]
Boolean	[bool; 512]
Field	[bool; 512]
Group	[bool; 512]
I8	[bool; 512]
I16	[bool; 512]
I32	[bool; 512]
I64	[bool; 512]
I128	[bool; 512]
U8	[bool; 512]
U16	[bool; 512]
U32	[bool; 512]
U64	[bool; 512]
U128	[bool; 512]
Scalar	[bool; 512]
Struct	[bool; 512]
hash.keccak512.native.raw
Back to Top

Description
Performs a Keccak hash on first, storing a 512-bit digest as a bit array in destination. This variant uses raw bit form without Aleo variant bits and performs the underlying hash returning a bit array [bool; 512].

Example Usage
hash.keccak512.native.raw r0 into r1;

Supported Types
First	Destination
Array	[bool; 512]
Address	[bool; 512]
Boolean	[bool; 512]
Field	[bool; 512]
Group	[bool; 512]
I8	[bool; 512]
I16	[bool; 512]
I32	[bool; 512]
I64	[bool; 512]
I128	[bool; 512]
U8	[bool; 512]
U16	[bool; 512]
U32	[bool; 512]
U64	[bool; 512]
U128	[bool; 512]
Scalar	[bool; 512]
Struct	[bool; 512]
hash.sha3_256.native
Back to Top

Description
Calculates a SHA3-256 hash, from an input in first, storing the 256-bit digest as a bit array in destination. This variant performs the underlying hash returning a bit array [bool; 256].

Example Usage
hash.sha3_256.native r0 into r1;

Supported Types
First	Destination
Array	[bool; 256]
Address	[bool; 256]
Boolean	[bool; 256]
Field	[bool; 256]
Group	[bool; 256]
I8	[bool; 256]
I16	[bool; 256]
I32	[bool; 256]
I64	[bool; 256]
I128	[bool; 256]
U8	[bool; 256]
U16	[bool; 256]
U32	[bool; 256]
U64	[bool; 256]
U128	[bool; 256]
Scalar	[bool; 256]
Struct	[bool; 256]
hash.sha3_256.native.raw
Back to Top

Description
Calculates a SHA3-256 hash, from an input in first, storing the 256-bit digest as a bit array in destination. This variant uses raw bit form without Aleo variant bits and performs the underlying hash returning a bit array [bool; 256].

Example Usage
hash.sha3_256.native.raw r0 into r1;

Supported Types
First	Destination
Array	[bool; 256]
Address	[bool; 256]
Boolean	[bool; 256]
Field	[bool; 256]
Group	[bool; 256]
I8	[bool; 256]
I16	[bool; 256]
I32	[bool; 256]
I64	[bool; 256]
I128	[bool; 256]
U8	[bool; 256]
U16	[bool; 256]
U32	[bool; 256]
U64	[bool; 256]
U128	[bool; 256]
Scalar	[bool; 256]
Struct	[bool; 256]
hash.sha3_384.native
Back to Top

Description
Calculates a SHA3-384 hash, from an input in first, storing the 384-bit digest as a bit array in destination. This variant performs the underlying hash returning a bit array [bool; 384].

Example Usage
hash.sha3_384.native r0 into r1;

Supported Types
First	Destination
Array	[bool; 384]
Address	[bool; 384]
Boolean	[bool; 384]
Field	[bool; 384]
Group	[bool; 384]
I8	[bool; 384]
I16	[bool; 384]
I32	[bool; 384]
I64	[bool; 384]
I128	[bool; 384]
U8	[bool; 384]
U16	[bool; 384]
U32	[bool; 384]
U64	[bool; 384]
U128	[bool; 384]
Scalar	[bool; 384]
Struct	[bool; 384]
hash.sha3_384.native.raw
Back to Top

Description
Calculates a SHA3-384 hash, from an input in first, storing the 384-bit digest as a bit array in destination. This variant uses raw bit form without Aleo variant bits and performs the underlying hash returning a bit array [bool; 384].

Example Usage
hash.sha3_384.native.raw r0 into r1;

Supported Types
First	Destination
Array	[bool; 384]
Address	[bool; 384]
Boolean	[bool; 384]
Field	[bool; 384]
Group	[bool; 384]
I8	[bool; 384]
I16	[bool; 384]
I32	[bool; 384]
I64	[bool; 384]
I128	[bool; 384]
U8	[bool; 384]
U16	[bool; 384]
U32	[bool; 384]
U64	[bool; 384]
U128	[bool; 384]
Scalar	[bool; 384]
Struct	[bool; 384]
hash.sha3_512.native
Back to Top

Description
Calculates a SHA3-512 hash, from an input in first, storing the 512-bit digest as a bit array in destination. This variant performs the underlying hash returning a bit array [bool; 512].

Example Usage
hash.sha3_512.native r0 into r1;

Supported Types
First	Destination
Array	[bool; 512]
Address	[bool; 512]
Boolean	[bool; 512]
Field	[bool; 512]
Group	[bool; 512]
I8	[bool; 512]
I16	[bool; 512]
I32	[bool; 512]
I64	[bool; 512]
I128	[bool; 512]
U8	[bool; 512]
U16	[bool; 512]
U32	[bool; 512]
U64	[bool; 512]
U128	[bool; 512]
Scalar	[bool; 512]
Struct	[bool; 512]
hash.sha3_512.native.raw
Back to Top

Description
Calculates a SHA3-512 hash, from an input in first, storing the 512-bit digest as a bit array in destination. This variant uses raw bit form without Aleo variant bits and performs the underlying hash returning a bit array [bool; 512].

Example Usage
hash.sha3_512.native.raw r0 into r1;

Supported Types
First	Destination
Array	[bool; 512]
Address	[bool; 512]
Boolean	[bool; 512]
Field	[bool; 512]
Group	[bool; 512]
I8	[bool; 512]
I16	[bool; 512]
I32	[bool; 512]
I64	[bool; 512]
I128	[bool; 512]
U8	[bool; 512]
U16	[bool; 512]
U32	[bool; 512]
U64	[bool; 512]
U128	[bool; 512]
Scalar	[bool; 512]
Struct	[bool; 512]
inv
Back to Top

Description
Computes the multiplicative inverse of the input, storing the outcome in destination.

Example Usage
inv r0 into r1;

Supported Types
Input	Destination
Field	Field
is.eq
Back to Top

Description
Compares first and second, storing the result in destination.

Example Usage
is.eq r0 r1 into r2;

Supported Types
First	Second	Destination
Address	Address	Boolean
Boolean	Boolean	Boolean
Field	Field	Boolean
Group	Group	Boolean
I8	I8	Boolean
I16	I16	Boolean
I32	I32	Boolean
I64	I64	Boolean
I128	I128	Boolean
U8	U8	Boolean
U16	U16	Boolean
U32	U32	Boolean
U64	U64	Boolean
U128	U128	Boolean
Scalar	Scalar	Boolean
Signature	Signature	Boolean
Struct	Struct	Boolean
Record	Record	Boolean
is.neq
Back to Top

Description
Returns true if first is not equal to second, storing the result in destination.

Example Usage
is.neq r0 r1 into r2;

Supported Types
First	Second	Destination
Address	Address	Boolean
Boolean	Boolean	Boolean
Field	Field	Boolean
Group	Group	Boolean
I8	I8	Boolean
I16	I16	Boolean
I32	I32	Boolean
I64	I64	Boolean
I128	I128	Boolean
U8	U8	Boolean
U16	U16	Boolean
U32	U32	Boolean
U64	U64	Boolean
U128	U128	Boolean
Scalar	Scalar	Boolean
Signature	Signature	Boolean
Struct	Struct	Boolean
Record	Record	Boolean
lt
Back to Top

Description
Checks if first is less than second, storing the outcome in destination.

Example Usage
lt r0 r1 into r2;

Supported Types
First	Second	Destination
Field	Field	Boolean
I8	I8	Boolean
I16	I16	Boolean
I32	I32	Boolean
I64	I64	Boolean
I128	I128	Boolean
U8	U8	Boolean
U16	U16	Boolean
U32	U32	Boolean
U64	U64	Boolean
U128	U128	Boolean
Scalar	Scalar	Boolean
lte
Back to Top

Description
Checks if first is less than or equal to second, storing the outcome in destination.

Example Usage
lte r0 r1 into r2;

Supported Types
First	Second	Destination
Field	Field	Boolean
I8	I8	Boolean
I16	I16	Boolean
I32	I32	Boolean
I64	I64	Boolean
I128	I128	Boolean
U8	U8	Boolean
U16	U16	Boolean
U32	U32	Boolean
U64	U64	Boolean
U128	U128	Boolean
Scalar	Scalar	Boolean
mod
Back to Top

Description
Takes the modulus of first with respect to second, storing the outcome in destination. Halts if second is zero.

The semantics of this operation are consistent with the mathematical definition of modulo operation.

Example Usage
mod r0 r1 into r2;

Supported Types
First	Second	Destination
U8	U8	U8
U16	U16	U16
U32	U32	U32
U64	U64	U64
U128	U128	U128
mul
Back to Top

Description
Multiplies first with second, storing the outcome in destination.

For integer types, a constraint is added to check for overflow/underflow. For cases where wrapping semantics are needed for integer types, see the mul.w instruction.

Example Usage
mul r0 r1 into r2;

Supported Types
First	Second	Destination
Field	Field	Field
Group	Scalar	Group
Scalar	Group	Group
I8	I8	I8
I16	I16	I16
I32	I32	I32
I64	I64	I64
I128	I128	I128
U8	U8	U8
U16	U16	U16
U32	U32	U32
U64	U64	U64
U128	U128	U128
mul.w
Back to Top

Description
Multiplies first with second, wrapping around at the boundary of the type, and storing the outcome in destination.

Example Usage
mul.w r0 r1 into r2;

Supported Types
First	Second	Destination
I8	I8	I8
I16	I16	I16
I32	I32	I32
I64	I64	I64
I128	I128	I128
U8	U8	U8
U16	U16	U16
U32	U32	U32
U64	U64	U64
U128	U128	U128
nand
Back to Top

Description
Returns false only if first and second are true, storing the outcome in destination.

Example Usage
nand r0 r1 into r2;

Supported Types
First	Second	Destination
Boolean	Boolean	Boolean
neg
Back to Top

Description
Negates first, storing the outcome in destination.

For signed integer types, calling neg on the minimum value is an invalid operation. For example, the input -128i8 would not be valid since 128 cannot be represented as an i8.

Example Usage
neg r0 into r1;

Supported Types
Input	Destination
Field	Field
Group	Group
I8	I8
I16	I16
I32	I32
I64	I64
I128	I128
nor
Back to Top

Description
Returns true when neither first nor second is true, storing the outcome in destination.

Example Usage
nor r0 r1 into r2;

Supported Type
First	Second	Destination
Boolean	Boolean	Boolean
not
Back to Top

Description
Perform a NOT operation on an integer (bitwise) or boolean input, storing the outcome in destination.

Example Usage
not r0 into r1;

Supported Types
Input	Destination
Boolean	Boolean
I8	I8
I16	I16
I32	I32
I64	I64
I128	I128
U8	U8
U16	U16
U32	U32
U64	U64
U128	U128
or
Back to Top

Description
Performs an OR operation on integer (bitwise) or boolean first and second, storing the outcome in destination.

Example Usage
or r0 r1 into r2;

Supported Types
First	Second	Destination
Boolean	Boolean	Boolean
I8	I8	I8
I16	I16	I16
I32	I32	I32
I64	I64	I64
I128	I128	I128
U8	U8	U8
U16	U16	U16
U32	U32	U32
U64	U64	U64
U128	U128	U128
position
Back to Top

Description
The position declaration, e.g. position <name>, which indicates a location name in the program to branch execution to.
Positions must be a lowercase alphanumeric string.

Example Usage
position skip;

pow
Back to Top

Description
Raises first to the power of second, storing the outcome in destination.

For integer types, a constraint is added to check for overflow/underflow. For cases where wrapping semantics are needed for integer types, see the pow.w instruction.

Example Usage
pow r0 r1 into r2;

Supported Types
Magnitude can be a U8, U16, or U32.

First	Second	Destination
Field	Field	Field
I8	Magnitude	I8
I16	Magnitude	I16
I32	Magnitude	I32
I64	Magnitude	I64
I128	Magnitude	I128
U8	Magnitude	U8
U16	Magnitude	U16
U32	Magnitude	U32
U64	Magnitude	U64
U128	Magnitude	U128
pow.w
Back to Top

Description
Raises first to the power of second, wrapping around at the boundary of the type, storing the outcome in destination.

Example Usage
pow.w r0 r1 into r2;

Supported Types
Magnitude can be a U8, U16, or U32.

First	Second	Destination
I8	Magnitude	I8
I16	Magnitude	I16
I32	Magnitude	I32
I64	Magnitude	I64
I128	Magnitude	I128
U8	Magnitude	U8
U16	Magnitude	U16
U32	Magnitude	U32
U64	Magnitude	U64
U128	Magnitude	U128
rand.chacha
Description
The rand.chacha opcode is used to generate random values within the finalize scope. It supports a wide range of types for the random value.

Example Usage
rand.chacha into r0 as field;
rand.chacha r0 into r1 as field;
rand.chacha r0 r1 into r2 as field;
rand.chacha 1u8 2i16 into r27 as u32;

Supported Types
Single can be any of the following types Address, Boolean, Field, Group, I8, I16, I32, I64, I128, U8, U16, U32, U64, U128, or Scalar. Composite data types such as structs and mappings are not allowed.

First	Second	Destination
Single	Single	Single
rem
Back to Top

Description
Computes the truncated remainder of first divided by second, storing the outcome in destination. Halts on division by zero.

A constraint is added to check for underflow. This underflow happens when the associated division operation, div, underflows.

For cases where wrapping semantics are needed for integer types, see the rem.w instruction.

Example Usage
rem r0 r1 into r2;

Supported Types
First	Second	Destination
I8	I8	I8
I16	I16	I16
I32	I32	I32
I64	I64	I64
I128	I128	I128
U8	U8	U8
U16	U16	U16
U32	U32	U32
U64	U64	U64
U128	U128	U128
rem.w
Back to Top

Description
Computes the truncated remainder of first divided by second, wrapping around at the boundary of the type, and storing the outcome in destination.

Example Usage
rem.w r0 r1 into r2;

Supported Types
First	Second	Destination
I8	I8	I8
I16	I16	I16
I32	I32	I32
I64	I64	I64
I128	I128	I128
U8	U8	U8
U16	U16	U16
U32	U32	U32
U64	U64	U64
U128	U128	U128
sign.verify
Back to Top

Description
Verifies the signature first against the address public key second and the message third, storing the outcome in destination.

Example Usage
sign.verify r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
Signature	Address	Array of Field	Boolean
ecdsa.verify.digest
Back to Top

Description
Verifies an ECDSA signature against a 33-byte ECDSA address and a pre-computed message digest, storing the outcome in destination. Both the address and digest are already in raw form. The digest must be a 32-byte array.

Example Usage
ecdsa.verify.digest r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 33]	[u8; 32]	Boolean
ecdsa.verify.digest.eth
Back to Top

Description
Verifies an ECDSA signature against a 20-byte Ethereum address and a pre-computed message digest, storing the outcome in destination. Both the address and digest are already in raw form. The digest must be a 32-byte array.

Example Usage
ecdsa.verify.digest.eth r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 20]	[u8; 32]	Boolean
ecdsa.verify.keccak256
Back to Top

Description
Verifies an ECDSA signature against a public key and message using Keccak-256 hash, storing the outcome in destination. This is the Aleo variant bits form.

Example Usage
ecdsa.verify.keccak256 r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 33]	Address	Boolean
[u8; 65]	[u8; 33]	Field	Boolean
[u8; 65]	[u8; 33]	Group	Boolean
[u8; 65]	[u8; 33]	Scalar	Boolean
[u8; 65]	[u8; 33]	I8	Boolean
[u8; 65]	[u8; 33]	I16	Boolean
[u8; 65]	[u8; 33]	I32	Boolean
[u8; 65]	[u8; 33]	I64	Boolean
[u8; 65]	[u8; 33]	I128	Boolean
[u8; 65]	[u8; 33]	U8	Boolean
[u8; 65]	[u8; 33]	U16	Boolean
[u8; 65]	[u8; 33]	U32	Boolean
[u8; 65]	[u8; 33]	U64	Boolean
[u8; 65]	[u8; 33]	U128	Boolean
ecdsa.verify.keccak256.raw
Back to Top

Description
Verifies an ECDSA signature against a public key and message using Keccak-256 hash, storing the outcome in destination. This variant uses raw bit form without metadata. The message must be byte-aligned (bit length must be a multiple of 8).

Example Usage
ecdsa.verify.keccak256.raw r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 33]	[Address; 8]	Boolean
[u8; 65]	[u8; 33]	[Field; 8]	Boolean
[u8; 65]	[u8; 33]	[Group; 8]	Boolean
[u8; 65]	[u8; 33]	[Scalar; 8]	Boolean
[u8; 65]	[u8; 33]	I8	Boolean
[u8; 65]	[u8; 33]	I16	Boolean
[u8; 65]	[u8; 33]	I32	Boolean
[u8; 65]	[u8; 33]	I64	Boolean
[u8; 65]	[u8; 33]	I128	Boolean
[u8; 65]	[u8; 33]	U8	Boolean
[u8; 65]	[u8; 33]	U16	Boolean
[u8; 65]	[u8; 33]	U32	Boolean
[u8; 65]	[u8; 33]	U64	Boolean
[u8; 65]	[u8; 33]	U128	Boolean
ecdsa.verify.keccak256.eth
Back to Top

Description
Verifies an ECDSA signature against a 20-byte Ethereum address and message using Keccak-256 hash, storing the outcome in destination. The address is a 20-byte Ethereum address and the message is in raw form. The message must be byte-aligned (bit length must be a multiple of 8).

Example Usage
ecdsa.verify.keccak256.eth r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 20]	[Address; 8]	Boolean
[u8; 65]	[u8; 20]	[Field; 8]	Boolean
[u8; 65]	[u8; 20]	[Group; 8]	Boolean
[u8; 65]	[u8; 20]	[Scalar; 8]	Boolean
[u8; 65]	[u8; 20]	I8	Boolean
[u8; 65]	[u8; 20]	I16	Boolean
[u8; 65]	[u8; 20]	I32	Boolean
[u8; 65]	[u8; 20]	I64	Boolean
[u8; 65]	[u8; 20]	I128	Boolean
[u8; 65]	[u8; 20]	U8	Boolean
[u8; 65]	[u8; 20]	U16	Boolean
[u8; 65]	[u8; 20]	U32	Boolean
[u8; 65]	[u8; 20]	U64	Boolean
[u8; 65]	[u8; 20]	U128	Boolean
ecdsa.verify.keccak384
Back to Top

Description
Verifies an ECDSA signature against a public key and message using Keccak-384 hash, storing the outcome in destination. This is the Aleo variant bits form.

Example Usage
ecdsa.verify.keccak384 r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 33]	Address	Boolean
[u8; 65]	[u8; 33]	Field	Boolean
[u8; 65]	[u8; 33]	Group	Boolean
[u8; 65]	[u8; 33]	Scalar	Boolean
[u8; 65]	[u8; 33]	I8	Boolean
[u8; 65]	[u8; 33]	I16	Boolean
[u8; 65]	[u8; 33]	I32	Boolean
[u8; 65]	[u8; 33]	I64	Boolean
[u8; 65]	[u8; 33]	I128	Boolean
[u8; 65]	[u8; 33]	U8	Boolean
[u8; 65]	[u8; 33]	U16	Boolean
[u8; 65]	[u8; 33]	U32	Boolean
[u8; 65]	[u8; 33]	U64	Boolean
[u8; 65]	[u8; 33]	U128	Boolean
ecdsa.verify.keccak384.raw
Back to Top

Description
Verifies an ECDSA signature against a public key and message using Keccak-384 hash, storing the outcome in destination. This variant uses raw bit form without metadata. The message must be byte-aligned (bit length must be a multiple of 8).

Example Usage
ecdsa.verify.keccak384.raw r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 33]	[Address; 8]	Boolean
[u8; 65]	[u8; 33]	[Field; 8]	Boolean
[u8; 65]	[u8; 33]	[Group; 8]	Boolean
[u8; 65]	[u8; 33]	[Scalar; 8]	Boolean
[u8; 65]	[u8; 33]	I8	Boolean
[u8; 65]	[u8; 33]	I16	Boolean
[u8; 65]	[u8; 33]	I32	Boolean
[u8; 65]	[u8; 33]	I64	Boolean
[u8; 65]	[u8; 33]	I128	Boolean
[u8; 65]	[u8; 33]	U8	Boolean
[u8; 65]	[u8; 33]	U16	Boolean
[u8; 65]	[u8; 33]	U32	Boolean
[u8; 65]	[u8; 33]	U64	Boolean
[u8; 65]	[u8; 33]	U128	Boolean
ecdsa.verify.keccak384.eth
Back to Top

Description
Verifies an ECDSA signature against a 20-byte Ethereum address and message using Keccak-384 hash, storing the outcome in destination. The address is a 20-byte Ethereum address and the message is in raw form. The message must be byte-aligned (bit length must be a multiple of 8).

Example Usage
ecdsa.verify.keccak384.eth r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 20]	[Address; 8]	Boolean
[u8; 65]	[u8; 20]	[Field; 8]	Boolean
[u8; 65]	[u8; 20]	[Group; 8]	Boolean
[u8; 65]	[u8; 20]	[Scalar; 8]	Boolean
[u8; 65]	[u8; 20]	I8	Boolean
[u8; 65]	[u8; 20]	I16	Boolean
[u8; 65]	[u8; 20]	I32	Boolean
[u8; 65]	[u8; 20]	I64	Boolean
[u8; 65]	[u8; 20]	I128	Boolean
[u8; 65]	[u8; 20]	U8	Boolean
[u8; 65]	[u8; 20]	U16	Boolean
[u8; 65]	[u8; 20]	U32	Boolean
[u8; 65]	[u8; 20]	U64	Boolean
[u8; 65]	[u8; 20]	U128	Boolean
ecdsa.verify.keccak512
Back to Top

Description
Verifies an ECDSA signature against a public key and message using Keccak-512 hash, storing the outcome in destination. This is the Aleo variant bits form.

Example Usage
ecdsa.verify.keccak512 r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 33]	Address	Boolean
[u8; 65]	[u8; 33]	Field	Boolean
[u8; 65]	[u8; 33]	Group	Boolean
[u8; 65]	[u8; 33]	Scalar	Boolean
[u8; 65]	[u8; 33]	I8	Boolean
[u8; 65]	[u8; 33]	I16	Boolean
[u8; 65]	[u8; 33]	I32	Boolean
[u8; 65]	[u8; 33]	I64	Boolean
[u8; 65]	[u8; 33]	I128	Boolean
[u8; 65]	[u8; 33]	U8	Boolean
[u8; 65]	[u8; 33]	U16	Boolean
[u8; 65]	[u8; 33]	U32	Boolean
[u8; 65]	[u8; 33]	U64	Boolean
[u8; 65]	[u8; 33]	U128	Boolean
ecdsa.verify.keccak512.raw
Back to Top

Description
Verifies an ECDSA signature against a public key and message using Keccak-512 hash, storing the outcome in destination. This variant uses raw bit form without metadata. The message must be byte-aligned (bit length must be a multiple of 8).

Example Usage
ecdsa.verify.keccak512.raw r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 33]	[Address; 8]	Boolean
[u8; 65]	[u8; 33]	[Field; 8]	Boolean
[u8; 65]	[u8; 33]	[Group; 8]	Boolean
[u8; 65]	[u8; 33]	[Scalar; 8]	Boolean
[u8; 65]	[u8; 33]	I8	Boolean
[u8; 65]	[u8; 33]	I16	Boolean
[u8; 65]	[u8; 33]	I32	Boolean
[u8; 65]	[u8; 33]	I64	Boolean
[u8; 65]	[u8; 33]	I128	Boolean
[u8; 65]	[u8; 33]	U8	Boolean
[u8; 65]	[u8; 33]	U16	Boolean
[u8; 65]	[u8; 33]	U32	Boolean
[u8; 65]	[u8; 33]	U64	Boolean
[u8; 65]	[u8; 33]	U128	Boolean
ecdsa.verify.keccak512.eth
Back to Top

Description
Verifies an ECDSA signature against a 20-byte Ethereum address and message using Keccak-512 hash, storing the outcome in destination. The address is a 20-byte Ethereum address and the message is in raw form. The message must be byte-aligned (bit length must be a multiple of 8).

Example Usage
ecdsa.verify.keccak512.eth r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 20]	[Address; 8]	Boolean
[u8; 65]	[u8; 20]	[Field; 8]	Boolean
[u8; 65]	[u8; 20]	[Group; 8]	Boolean
[u8; 65]	[u8; 20]	[Scalar; 8]	Boolean
[u8; 65]	[u8; 20]	I8	Boolean
[u8; 65]	[u8; 20]	I16	Boolean
[u8; 65]	[u8; 20]	I32	Boolean
[u8; 65]	[u8; 20]	I64	Boolean
[u8; 65]	[u8; 20]	I128	Boolean
[u8; 65]	[u8; 20]	U8	Boolean
[u8; 65]	[u8; 20]	U16	Boolean
[u8; 65]	[u8; 20]	U32	Boolean
[u8; 65]	[u8; 20]	U64	Boolean
[u8; 65]	[u8; 20]	U128	Boolean
ecdsa.verify.sha3_256
Back to Top

Description
Verifies an ECDSA signature against a public key and message using SHA3-256 hash, storing the outcome in destination. This is the Aleo variant bits form.

Example Usage
ecdsa.verify.sha3_256 r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 33]	Address	Boolean
[u8; 65]	[u8; 33]	Field	Boolean
[u8; 65]	[u8; 33]	Group	Boolean
[u8; 65]	[u8; 33]	Scalar	Boolean
[u8; 65]	[u8; 33]	I8	Boolean
[u8; 65]	[u8; 33]	I16	Boolean
[u8; 65]	[u8; 33]	I32	Boolean
[u8; 65]	[u8; 33]	I64	Boolean
[u8; 65]	[u8; 33]	I128	Boolean
[u8; 65]	[u8; 33]	U8	Boolean
[u8; 65]	[u8; 33]	U16	Boolean
[u8; 65]	[u8; 33]	U32	Boolean
[u8; 65]	[u8; 33]	U64	Boolean
[u8; 65]	[u8; 33]	U128	Boolean
ecdsa.verify.sha3_256.raw
Back to Top

Description
Verifies an ECDSA signature against a public key and message using SHA3-256 hash, storing the outcome in destination. This variant uses raw bit form without metadata. The message must be byte-aligned (bit length must be a multiple of 8).

Example Usage
ecdsa.verify.sha3_256.raw r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 33]	[Address; 8]	Boolean
[u8; 65]	[u8; 33]	[Field; 8]	Boolean
[u8; 65]	[u8; 33]	[Group; 8]	Boolean
[u8; 65]	[u8; 33]	[Scalar; 8]	Boolean
[u8; 65]	[u8; 33]	I8	Boolean
[u8; 65]	[u8; 33]	I16	Boolean
[u8; 65]	[u8; 33]	I32	Boolean
[u8; 65]	[u8; 33]	I64	Boolean
[u8; 65]	[u8; 33]	I128	Boolean
[u8; 65]	[u8; 33]	U8	Boolean
[u8; 65]	[u8; 33]	U16	Boolean
[u8; 65]	[u8; 33]	U32	Boolean
[u8; 65]	[u8; 33]	U64	Boolean
[u8; 65]	[u8; 33]	U128	Boolean
ecdsa.verify.sha3_256.eth
Back to Top

Description
Verifies an ECDSA signature against a 20-byte Ethereum address and message using SHA3-256 hash, storing the outcome in destination. The address is a 20-byte Ethereum address and the message is in raw form. The message must be byte-aligned (bit length must be a multiple of 8).

Example Usage
ecdsa.verify.sha3_256.eth r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 20]	[Address; 8]	Boolean
[u8; 65]	[u8; 20]	[Field; 8]	Boolean
[u8; 65]	[u8; 20]	[Group; 8]	Boolean
[u8; 65]	[u8; 20]	[Scalar; 8]	Boolean
[u8; 65]	[u8; 20]	I8	Boolean
[u8; 65]	[u8; 20]	I16	Boolean
[u8; 65]	[u8; 20]	I32	Boolean
[u8; 65]	[u8; 20]	I64	Boolean
[u8; 65]	[u8; 20]	I128	Boolean
[u8; 65]	[u8; 20]	U8	Boolean
[u8; 65]	[u8; 20]	U16	Boolean
[u8; 65]	[u8; 20]	U32	Boolean
[u8; 65]	[u8; 20]	U64	Boolean
[u8; 65]	[u8; 20]	U128	Boolean
ecdsa.verify.sha3_384
Back to Top

Description
Verifies an ECDSA signature against a public key and message using SHA3-384 hash, storing the outcome in destination. This is the Aleo variant bits form.

Example Usage
ecdsa.verify.sha3_384 r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 33]	Address	Boolean
[u8; 65]	[u8; 33]	Field	Boolean
[u8; 65]	[u8; 33]	Group	Boolean
[u8; 65]	[u8; 33]	Scalar	Boolean
[u8; 65]	[u8; 33]	I8	Boolean
[u8; 65]	[u8; 33]	I16	Boolean
[u8; 65]	[u8; 33]	I32	Boolean
[u8; 65]	[u8; 33]	I64	Boolean
[u8; 65]	[u8; 33]	I128	Boolean
[u8; 65]	[u8; 33]	U8	Boolean
[u8; 65]	[u8; 33]	U16	Boolean
[u8; 65]	[u8; 33]	U32	Boolean
[u8; 65]	[u8; 33]	U64	Boolean
[u8; 65]	[u8; 33]	U128	Boolean
ecdsa.verify.sha3_384.raw
Back to Top

Description
Verifies an ECDSA signature against a public key and message using SHA3-384 hash, storing the outcome in destination. This variant uses raw bit form without metadata. The message must be byte-aligned (bit length must be a multiple of 8).

Example Usage
ecdsa.verify.sha3_384.raw r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 33]	[Address; 8]	Boolean
[u8; 65]	[u8; 33]	[Field; 8]	Boolean
[u8; 65]	[u8; 33]	[Group; 8]	Boolean
[u8; 65]	[u8; 33]	[Scalar; 8]	Boolean
[u8; 65]	[u8; 33]	I8	Boolean
[u8; 65]	[u8; 33]	I16	Boolean
[u8; 65]	[u8; 33]	I32	Boolean
[u8; 65]	[u8; 33]	I64	Boolean
[u8; 65]	[u8; 33]	I128	Boolean
[u8; 65]	[u8; 33]	U8	Boolean
[u8; 65]	[u8; 33]	U16	Boolean
[u8; 65]	[u8; 33]	U32	Boolean
[u8; 65]	[u8; 33]	U64	Boolean
[u8; 65]	[u8; 33]	U128	Boolean
ecdsa.verify.sha3_384.eth
Back to Top

Description
Verifies an ECDSA signature against a 20-byte Ethereum address and message using SHA3-384 hash, storing the outcome in destination. The address is a 20-byte Ethereum address and the message is in raw form. The message must be byte-aligned (bit length must be a multiple of 8).

Example Usage
ecdsa.verify.sha3_384.eth r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 20]	[Address; 8]	Boolean
[u8; 65]	[u8; 20]	[Field; 8]	Boolean
[u8; 65]	[u8; 20]	[Group; 8]	Boolean
[u8; 65]	[u8; 20]	[Scalar; 8]	Boolean
[u8; 65]	[u8; 20]	I8	Boolean
[u8; 65]	[u8; 20]	I16	Boolean
[u8; 65]	[u8; 20]	I32	Boolean
[u8; 65]	[u8; 20]	I64	Boolean
[u8; 65]	[u8; 20]	I128	Boolean
[u8; 65]	[u8; 20]	U8	Boolean
[u8; 65]	[u8; 20]	U16	Boolean
[u8; 65]	[u8; 20]	U32	Boolean
[u8; 65]	[u8; 20]	U64	Boolean
[u8; 65]	[u8; 20]	U128	Boolean
ecdsa.verify.sha3_512
Back to Top

Description
Verifies an ECDSA signature against a public key and message using SHA3-512 hash, storing the outcome in destination. This is the Aleo variant bits form.

Example Usage
ecdsa.verify.sha3_512 r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 33]	Address	Boolean
[u8; 65]	[u8; 33]	Field	Boolean
[u8; 65]	[u8; 33]	Group	Boolean
[u8; 65]	[u8; 33]	Scalar	Boolean
[u8; 65]	[u8; 33]	I8	Boolean
[u8; 65]	[u8; 33]	I16	Boolean
[u8; 65]	[u8; 33]	I32	Boolean
[u8; 65]	[u8; 33]	I64	Boolean
[u8; 65]	[u8; 33]	I128	Boolean
[u8; 65]	[u8; 33]	U8	Boolean
[u8; 65]	[u8; 33]	U16	Boolean
[u8; 65]	[u8; 33]	U32	Boolean
[u8; 65]	[u8; 33]	U64	Boolean
[u8; 65]	[u8; 33]	U128	Boolean
ecdsa.verify.sha3_512.raw
Back to Top

Description
Verifies an ECDSA signature against a public key and message using SHA3-512 hash, storing the outcome in destination. This variant uses raw bit form without metadata. The message must be byte-aligned (bit length must be a multiple of 8).

Example Usage
ecdsa.verify.sha3_512.raw r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 33]	[Address; 8]	Boolean
[u8; 65]	[u8; 33]	[Field; 8]	Boolean
[u8; 65]	[u8; 33]	[Group; 8]	Boolean
[u8; 65]	[u8; 33]	[Scalar; 8]	Boolean
[u8; 65]	[u8; 33]	I8	Boolean
[u8; 65]	[u8; 33]	I16	Boolean
[u8; 65]	[u8; 33]	I32	Boolean
[u8; 65]	[u8; 33]	I64	Boolean
[u8; 65]	[u8; 33]	I128	Boolean
[u8; 65]	[u8; 33]	U8	Boolean
[u8; 65]	[u8; 33]	U16	Boolean
[u8; 65]	[u8; 33]	U32	Boolean
[u8; 65]	[u8; 33]	U64	Boolean
[u8; 65]	[u8; 33]	U128	Boolean
ecdsa.verify.sha3_512.eth
Back to Top

Description
Verifies an ECDSA signature against a 20-byte Ethereum address and message using SHA3-512 hash, storing the outcome in destination. The address is a 20-byte Ethereum address and the message is in raw form. The message must be byte-aligned (bit length must be a multiple of 8).

Example Usage
ecdsa.verify.sha3_512.eth r0 r1 r2 into r3;

Supported Types
First	Second	Third	Destination
[u8; 65]	[u8; 20]	[Address; 8]	Boolean
[u8; 65]	[u8; 20]	[Field; 8]	Boolean
[u8; 65]	[u8; 20]	[Group; 8]	Boolean
[u8; 65]	[u8; 20]	[Scalar; 8]	Boolean
[u8; 65]	[u8; 20]	I8	Boolean
[u8; 65]	[u8; 20]	I16	Boolean
[u8; 65]	[u8; 20]	I32	Boolean
[u8; 65]	[u8; 20]	I64	Boolean
[u8; 65]	[u8; 20]	I128	Boolean
[u8; 65]	[u8; 20]	U8	Boolean
[u8; 65]	[u8; 20]	U16	Boolean
[u8; 65]	[u8; 20]	U32	Boolean
[u8; 65]	[u8; 20]	U64	Boolean
[u8; 65]	[u8; 20]	U128	Boolean
shl
Back to Top

Description
Shifts first left by second bits, storing the outcome in destination.

Example Usage
shl r0 r1 into r2;

Supported Types
Magnitude can be a U8, U16, or U32.

First	Second	Destination
I8	Magnitude	I8
I16	Magnitude	I16
I32	Magnitude	I32
I64	Magnitude	I64
I128	Magnitude	I128
U8	Magnitude	U8
U16	Magnitude	U16
U32	Magnitude	U32
U64	Magnitude	U64
U128	Magnitude	U128
shl.w
Back to Top

Description
Shifts first left by second bits, wrapping around at the boundary of the type, storing the outcome in destination.

Example Usage
shl.w r0 r1 into r2;

Supported Types
Magnitude can be a U8, U16, or U32.

First	Second	Destination
I8	Magnitude	I8
I16	Magnitude	I16
I32	Magnitude	I32
I64	Magnitude	I64
I128	Magnitude	I128
U8	Magnitude	U8
U16	Magnitude	U16
U32	Magnitude	U32
U64	Magnitude	U64
U128	Magnitude	U128
shr
Back to Top

Description
Shifts first right by second bits, storing the outcome in destination.

Example Usage
shr r0 r1 into r2;

Supported Types
Magnitude can be a U8, U16, or U32.

First	Second	Destination
I8	Magnitude	I8
I16	Magnitude	I16
I32	Magnitude	I32
I64	Magnitude	I64
I128	Magnitude	I128
U8	Magnitude	U8
U16	Magnitude	U16
U32	Magnitude	U32
U64	Magnitude	U64
U128	Magnitude	U128
shr.w
Back to Top

Description
Shifts first right by second bits, wrapping around at the boundary of the type, storing the outcome in destination.

Example Usage
shr.w r0 r1 into r2;

Supported Types
Magnitude can be a U8, U16, or U32.

First	Second	Destination
I8	Magnitude	I8
I16	Magnitude	I16
I32	Magnitude	I32
I64	Magnitude	I64
I128	Magnitude	I128
U8	Magnitude	U8
U16	Magnitude	U16
U32	Magnitude	U32
U64	Magnitude	U64
U128	Magnitude	U128
square
Back to Top

Description
Squares the input, storing the outcome in destination.

Supported Types
Input	Destination
Field	Field
Example Usage
square r0 into r1;

sqrt
Back to Top

Description
Computes the square root of the input, storing the outcome in destination.

Supported Types
Input	Destination
Field	Field
Example Usage
sqrt r0 into r1;

sub
Back to Top

Description
Computes first - second, storing the outcome in destination.

Example Usage
sub r0 r1 into r2;

Supported Types
First	Second	Destination
Field	Field	Field
Group	Group	Group
I8	I8	I8
I16	I16	I16
I32	I32	I32
I64	I64	I64
I128	I128	I128
U8	U8	U8
U16	U16	U16
U32	U32	U32
U64	U64	U64
U128	U128	U128
sub.w
Back to Top

Description
Computes first - second, wrapping around at the boundary of the type, and storing the outcome in destination.

Example Usage
sub.w r0 r1 into r2;

Supported Types
First	Second	Destination
I8	I8	I8
I16	I16	I16
I32	I32	I32
I64	I64	I64
I128	I128	I128
U8	U8	U8
U16	U16	U16
U32	U32	U32
U64	U64	U64
U128	U128	U128
ternary
Back to Top

Description
Selects first, if condition is true, otherwise selects second, storing the result in destination.

Example: ternary r0 r1 r2 into r3, where r0 is the condition, r1 is first, r2 is second, and r3 is the destination.

Example Usage
ternary r0 r1 r2 into r3;

Supported Types
Condition	First	Second	Destination
Boolean	Boolean	Boolean	Boolean
Boolean	Field	Field	Field
Boolean	Group	Group	Group
Boolean	I8	I8	I8
Boolean	I16	I16	I16
Boolean	I32	I32	I32
Boolean	I64	I64	I64
Boolean	I128	I128	I128
Boolean	U8	U8	U8
Boolean	U16	U16	U16
Boolean	U32	U32	U32
Boolean	U64	U64	U64
Boolean	U128	U128	U128
Boolean	Scalar	Scalar	Scalar
Boolean	Signature	Signature	Signature
xor
Back to Top

Description
Performs a XOR operation on integer (bitwise) or boolean first and second, storing the outcome in destination.

Example Usage
xor r0 r1 into r2;

Supported Types
First	Second	Destination
Boolean	Boolean	Boolean
I8	I8	I8
I16	I16	I16
I32	I32	I32
I64	I64	I64
I128	I128	I128
U8	U8	U8
U16	U16	U16
U32	U32	U32
U64	U64	U64
U128	U128	U128
serialize.bits
Back to Top

Description
Serializes a value into a bits array (boolean array), using Aleo variant bits. The input can be various types, and the output must be a boolean array.

Example Usage
serialize.bits r0 (u32) into r1 ([boolean; 32u32]);

Supported Types
Input	Destination
Address, Field, Group, Scalar, I8, I16, I32, I64, I128, U8, U16, U32, U64, U128, [U8; N], [U16; N], [U32; N], [U64; N], [U128; N], [I8; N], [I16; N], [I32; N], [I64; N], [I128; N]	[bool; M]
serialize.bits.raw
Back to Top

Description
Serializes a value into a bits array (boolean array), using raw bits without Aleo variant bits. The input can be various types, and the output must be a boolean array.

Example Usage
serialize.bits.raw r0 (u32) into r1 ([boolean; 32u32]);


Supported Types
Input	Destination
Address, Field, Group, Scalar, I8, I16, I32, I64, I128, U8, U16, U32, U64, U128, [U8; N], [U16; N], [U32; N], [U64; N], [U128; N], [I8; N], [I16; N], [I32; N], [I64; N], [I128; N]	[bool; M]
deserialize.bits
Back to Top

Description
Deserializes a bits array (boolean array) into a value, using Aleo variant bits. The input must be a boolean array, and the output can be various types.

Example Usage
deserialize.bits r0 ([boolean; 256u32]) into r1 as u8;


Supported Types
Input	Destination
[bool; N]	Address, Field, Group, Scalar, I8, I16, I32, I64, I128, U8, U16, U32, U64, U128, [U8; M], [U16; M], [U32; M], [U64; M], [U128; M], [I8; M], [I16; M], [I32; M], [I64; M], [I128; M]
deserialize.bits.raw
Back to Top

Description
Deserializes a bits array (boolean array) into a value, using raw bits without Aleo variant bits. The input must be a boolean array, and the output can be various types.

Example Usage
deserialize.bits.raw r5 ([boolean; 256u32]) into r6 ([u8; 32u32]);


Supported Types
Input	Destination
[bool; N]	Address, Field, Group, Scalar, I8, I16, I32, I64, I128, U8, U16, U32, U64, U128, [U8; M], [U16; M], [U32; M], [U64; M], [U128; M], [I8; M], [I16; M], [I32; M], [I64; M], [I128; M]

Aleo Special Operands
The following lists show the special operands supported by Aleo instructions.

Table of Special Operands
Name	Description
block.height	Returns height of the block within the finalize scope
block.timestamp	Returns the unix timestamp of the current block within the finalize scope
self.signer	Returns the user address that originated the transition
self.caller	Returns the address of the immediate caller of the program
network.id	Returns the ID of the network on which the program is executed
edition	Returns the program's version number (u16)
checksum	Returns the SHA3-256 hash of the program string
program_owner	Returns the address of the account that submitted the deployment transaction
Specification
The following is the specification for each special operands in the Aleo Virtual Machine (AVM).

network.id
Back to Top

Description
Returns the ID of the network on which the program is executed. This can be useful for managing network-specific program behavior. The network.id command must be called within a finalize block.

Currently supported network IDs are:

0: Mainnet
1: Testnet
2: Canarynet
Example Usage
assert.eq network.id 0u64;  // For mainnet

block.height
Back to Top

Description
Returns the height of the block within the finalize scope.
The block.height command must be called within a finalize block. The type returned is u64.

Example Usage
assert.eq block.height 100u64;

block.timestamp
Back to Top

Description
Returns the unix timestamp of the current block within the finalize scope.
The block.timestamp command must be called within a finalize block.
The type returned is i64.

Example Usage
assert.eq block.timestamp 1767976339i64;

self.signer
Back to Top

Description
Returns the user address that originated the transition.

Example Usage
assert.eq self.signer aleo1...;

self.caller
Back to Top

Description
Returns the address of the immediate caller of the program.

Example Usage
assert.eq self.caller aleo1...;

edition
Back to Top

Description
Returns the program's version number as an unsigned 16-bit integer (u16). The edition must be 0u16 for the initial deployment. For every valid upgrade, it must increment by exactly 1.

This operand is exclusively available within the finalize scope and is used for program upgradability.

Example Usage
assert.eq edition 0u16;  // Check if this is the initial deployment


note
You may also refer to other program's metadata by qualifying the operand with the program name, like Program::edition(credits.aleo), Program::edition(foo.aleo). You will need to import the program in your Leo file to use this syntax.

checksum
Back to Top

Description
Returns a 32-byte array ([u8; 32u32]) representing the SHA3-256 hash of the program string. It's a unique fingerprint of the program's code.

The checksum is required in any deployment of an upgradable program and is used to verify that the deployed code is what was expected.

This operand is exclusively available within the finalize scope.

Example Usage
assert.eq checksum <EXPECTED_CHECKSUM>;  // Verify program code matches expected hash


note
You may also refer to other program's metadata by qualifying the operand with the program name, like Program::checksum(credits.aleo), Program::checksum(foo.aleo). You will need to import the program in your Leo file to use this syntax.

program_owner
Back to Top

Description
Returns the address of the account that submitted the deployment transaction.

The program_owner is required in any deployment of an upgradable program and can be used to enforce access control for program upgrades.

This operand is exclusively available within the finalize scope.

Example Usage
assert.eq program_owner <ADMIN_ADDRESS>;  // Restrict upgrades to specific admin


note
You may also refer to other program's metadata by qualifying the operand with the program name, like Program::program_owner(credits.aleo), Program::program_owner(foo.aleo). You will need to import the program in your Leo file to use this syntax.

warning
Programs deployed before upgradability do not have a program_owner. Attempting to access it will result in a runtime error.

Aleo Instructions Grammar
This chapter contains a high-level grammar of Aleo instructions. A more detailed ABNF grammar can be found here.

program = *import
          "program" program-id ";"
          1*( mapping / struct / record / closure / function )
import = "import" program-id ";"
mapping = "mapping" identifier ":"
          mapping-key
          mapping-value
mapping-key = "key" identifier "as" finalize-type ";"
mapping-value = "value" identifier "as" finalize-type ";"
struct = "struct" identifier ":" 1*tuple
tuple = identifier "as" plaintext-type ";"
record = "record" identifier ":"
         "owner" "as" ( "address.public" / "address.private" ) ";"
         *entry
entry = identifier "as" entry-type ";"
closure = "closure" identifier ":"
          *closure-input
          1*instruction
          *closure-output
closure-input = "input" register "as" register-type ";"
closure-output = "output" operand "as" register-type ";"
function = "function" identifier ":"
           *function-input
           *instruction
           *function-output
           [ finalize-command finalize ]
function-input = "input" register "as" value-type ";"
function-output = "output" operand "as" value-type ";"
finalize = "finalize" identifier ":"
           *finalize-input
           1*command
           *finalize-output
finalize-input = "input" register "as" finalize-type ";"
finalize-output = "output" operand "as" finalize-type ";"
finalize-command = "finalize" *( operand ) ";"
command = contains
        / get
        / get-or-use
        / set
        / remove
        / random
        / position
        / branch
        / instruction
contains = "contains" identifier "[" operand "]" "into" register ";"
get = "get" identifier "[" operand "]" "into" register ";"
get-or-use = "get.or_use" identifier "[" operand "]" operand "into" register ";"
set = "set" operand "into" identifier "[" operand "]" ";"
remove = "remove" identifier "[" operand "]" ";"
random  = "rand.chacha" *2( operand ) "into" register "as" literal-type ";"
label = identifier
position = "position" label ";"
branch-op = "branch.eq" / "branch.neq"
branch = branch-op operand operand label ";"
instruction = ( unary
              / binary
              / ternary
              / is
              / assert
              / commit
              / hash
              / cast
              / call )
              ";"
unary = unary-op ( operand ) "into" register
unary-op = "abs" / "abs.w"
         / "double"
         / "inv"
         / "neg"
         / "not"
         / "square"
         / "sqrt"
binary = binary-op 2( operand ) "into" register
binary-op = "add" / "add.w"
          / "sub" / "sub.w"
          / "mul" / "mul.w"
          / "div" / "div.w"
          / "rem" / "rem.w"
          / "mod"
          / "pow" / "pow.w"
          / "shl" / "shl.w"
          / "shr" / "shr.w"
          / "and"
          / "or"
          / "xor"
          / "nand"
          / "nor"
          / "gt"
          / "gte"
          / "lt"
          / "lte"
ternary = ternary-op 3( operand ) "into" register
ternary-op = "ternary"
is = is-op operand operand "into" register
is-op = "is.eq" / "is.neq"
assert = assert-op operand operand
assert-op = "assert.eq" / "assert.neq"
commit = commit-op operand operand "into" register "as" ( address-type / field-type / group-type )
commit-op = "commit.bhp" ( "256" / "512" / "768" / "1024" )
          / "commit.ped" ( "64" / "128" )
hash = hash-op operand "into" register "as" ( arithmetic-type / address-type )
hash-op = "hash.bhp" ( "256" / "512" / "768" / "1024" )
        / "hash.ped" ( "64" / "128" )
        / "hash.psd" ( "2" / "4" / "8" )
        / "hash_many.psd" ( "2" / "4" / "8" )
cast = cast-op 1*( operand ) "into" register "as" cast-destination
cast-op = "cast"
cast-destination = register-type / "group.x" / "group.y"
call = "call" ( locator / identifier ) *( operand ) "into" 1*( register )
operand = literal
        / "group::GEN"
        / register-access
        / program-id
        / "self.caller"
        / "self.signer"
        / "block.height"
        / "block.timestamp"
literal = arithmetic-literal
        / address-literal
        / boolean-literal
arithmetic-literal = integer-literal
                   / field-literal
                   / group-literal
                   / scalar-literal
integer-literal = signed-literal / unsigned-literal
signed-literal = [ "-" ] 1*( digit *"_" ) signed-type
unsigned-literal = [ "-" ] 1*( digit *"_" ) unsigned-type
field-literal = [ "-" ] 1*( digit *"_" ) field-type
group-literal = [ "-" ] 1*( digit *"_" ) group-type
scalar-literal = [ "-" ] 1*( digit *"_" ) scalar-type
address-literal = "aleo1" 1*( address-char *"_" )
address-char = "0" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9"
             / "a" / "c" / "d" / "e" / "f" / "g" / "h" / "j"
             / "k" / "l" / "m" / "n" / "p" / "q" / "r" / "s"
             / "t" / "u" / "v" / "w" / "x" / "y" / "z"
boolean-literal = "true" / "false"
register = "r" 1*digit
register-access = register *( "." identifier )
unsigned-type = "u8" / "u16" / "u32" / "u64" / "u128"
signed-type = "i8" / "i16" / "i32" / "i64" / "i128"
integer-type = unsigned-type / signed-type
field-type = "field"
group-type = "group"
scalar-type = "scalar"
arithmetic-type = integer-type / field-type / group-type / scalar-type
address-type = "address"
boolean-type = "boolean"
literal-type = arithmetic-type / address-type / boolean-type / string-type
plaintext-type = literal-type / identifier
value-type = plaintext-type ".constant"
           / plaintext-type ".public"
           / plaintext-type ".private"
           / identifier ".record"
           / locator ".record"
finalize-type = plaintext-type ".public"
              / identifier ".record"
              / locator ".record"
entry-type = plaintext-type ( ".constant" / ".public" / ".private" )
register-type = locator ".record"
              / identifier ".record"
              / plaintext-type
digit = "0"-"9"
uppercase-letter = "A"-"Z"
lowercase-letter = "a"-"z"
letter = uppercase-letter / lowercase-letter
identifier = letter *( letter / digit / "_" )
lowercase-identifier = lowercase-letter *( lowercase-letter / digit / "_" )
program-name = lowercase-identifier
program-domain = lowercase-identifier
program-id = program-name "." program-domain
locator = program-id "/" identifier

Tooling for Aleo Instructions
info
If you have installed a Leo syntax plugin. then you should already be able to see syntax highlighting for .aleo Aleo instructions.

Aleo maintains several syntax highlighting implementations across different platforms. If you do not see your favorite editor on this list, please reach out on GitHub.

Sublime Text.
Visual Studio Code.
Intellij.
Sublime Text

Download the editor here: https://www.sublimetext.com/download. Aleo instructions support for Sublime's LSP plugin is provided through a language-server.

Install
Install LSP and LSP-leo from Package Control.
Restart Sublime.
Usage
Follow these steps to toggle the Aleo instructions syntax highlighter.

Open Sublime Text.
From Settings > Select Color Scheme... > LSP-leo
This will also allow you to see syntax highlighting for Aleo instructions.
VSCode
 Download the editor here: https://code.visualstudio.com/download.

Install
Install Leo for VSCode from VSCode marketplace.
The correct extension ID is provablehq.leo-extension, and the description should state "the official VSCode extension for Leo".
Usage
Open VSCode.
Go to Settings > Extensions or use the left side panel Extensions button to enable the Leo plugin.
This will also allow you to see syntax highlighting for Aleo instructions.
IntelliJ
 Download the editor here: https://www.jetbrains.com/idea/download/.

Install
Download the Aleo Developer Plugin from JetBrains marketplace.
Click on the gear icon in the upper right > Plugins > gear icon up top > Install Plugin from Disk > Select the downloaded zip file
This will also allow you to see syntax highlighting for Aleo instructions.

Program Upgrades on Aleo
Traditionally, blockchain development has been defined by immutable, "deploy-once" contracts. This provides security but makes it hard to fix bugs or add features. To solve this, Aleo introduces a framework for program upgradability that is timely, cost-effective, and doesn't disrupt your application's state.

This framework moves Aleo development from a static model to a dynamic one, allowing applications to evolve. It lets you modify program logic after deployment, so you can patch vulnerabilities, improve features, and adapt to user needs without a complex and costly state migration. Developers are required to design upgradability at the start and reason about the lifecycle of their programs.

This guide covers how this feature works, its security implications, and the rules you need to follow.

Constructor
The constructor is a special block of code that acts as the sole gateway for enabling and managing upgrades. Including a constructor in your program's code at its initial deployment is the only way to make it upgradable. Programs deployed after program upgradability is supported must all have non-empty constructors. Developers have the freedom to implement the constructor logic as they see fit, allowing for flexibility in how upgrades are handled.

Its behavior is strictly defined:

Execution Context: The constructor logic runs on-chain by the Aleo Virtual Machine (AVM) only during a deployment event (the initial deployment and every subsequent upgrade). It never runs during a standard function call.
Immutability: The logic inside a constructor is permanent. Once a program is deployed, its constructor can't be modified or removed in an upgrade. This ensures the rules for upgrading your program are stable and can't be bypassed.
Transaction Finality: The constructor is a final check for any deployment or upgrade. If its logic halts (for example, due to a failed assert statement), the entire deployment or upgrade transaction fails. This makes the constructor a powerful tool for enforcing conditions on upgrades.
note
Mutability is a feature you must explicitly design into your program from the start.

Program Metadata Operands
Alongside the constructor, the AVM also provides three new metadata operands. These give you on-chain, verifiable information about the program's state, allowing you to write secure upgrade rules.

**<PROGRAM_ID>/edition | edition **

Description: An unsigned 16-bit integer (u16) that acts as the program's version number.
Rules: The edition must be 0u16 for the initial deployment. For every valid upgrade, it must increment by exactly 1.
Scope: This operand is exclusively available within the finalize scope.
<PROGRAM_ID>/checksum | edition

Description: A 32-byte array ([u8; 32u32]) representing the SHA3-256 hash of the program string. It's a unique fingerprint of the program's code.
Rules: The checksum is required in any deployment of an upgradable program and is used to verify that the deployed code is what was expected.
Scope: This operand is exclusively available within the finalize scope.
<PROGRAM_ID>/program_owner | program_owner

Description: The address of the account that submitted the deployment transaction.
Rules: The program_owner is required in any deployment of an upgradable program.
Scope: This operand is exclusively available within the finalize scope.
info
The finalize-only scope for all three operands is a critical security feature. It forces any logic that authorizes an upgrade‚Äîbased on ownership, version, or content‚Äîto be executed and verified on-chain as part of a public state transition. This prevents these sensitive checks from being spoofed or manipulated in an off-chain proof context.

Cost of Upgradability
Executing a constructor consumes network resources and has a cost. The cost model is the same as for standard finalize blocks but with a significant multiplier applied (currently 100x).

This higher cost serves two purposes. First, it reflects the importance of the deployment transaction. Second, it acts as an economic incentive to keep your constructor logic simple and efficient, which reduces the risk of bugs in this critical, immutable code.

Rules of Upgradability
The Aleo protocol enforces strict rules on what makes a valid program upgrade. These rules balance the need for new logic with the need to protect a program's public interface and data structures, ensuring dependent programs and users aren't affected by breaking changes.

The AVM has clear rules about what you can add, modify, and what you can't change.

An upgrade can:

Modify Logic: Change the internal implementation of any existing function or finalize block. This is the main way to fix bugs or improve performance.
Add New Components: Define new structs, records, mappings, functions, and closures to extend functionality.
Add Imports: Import new external programs.
An upgrade cannot:

Change Interfaces: Modify the input or output signature of any existing function, or the input interface of a finalize block. This maintains backward compatibility.
Modify Closures: Change the logic within an existing closure. Doing so would invalidate all its proving and verifying keys, breaking existing user assets.
Alter Data Structures: Modify or remove any existing struct, record, or mapping. This preserves existing program state.
Delete Components: No program component of any kind can be deleted.
Below is a quick reference table:

Program Component	Delete	Modify	Add
import	‚ùå	‚ùå	‚úÖ
struct	‚ùå	‚ùå	‚úÖ
record	‚ùå	‚ùå	‚úÖ
mapping	‚ùå	‚ùå	‚úÖ
closure	‚ùå	‚ùå	‚úÖ
function	‚ùå	‚úÖ (logic)	‚úÖ
finalize	‚ùå	‚úÖ (logic)	‚úÖ
constructor	‚ùå	‚ùå	‚ùå
On-Chain Validation
When a Deployment transaction is submitted, the AVM runs a series of checks.

1. New Program Deployment (edition is 0): For a new, upgradable program, the AVM verifies [1]:

The program contains a constructor.
The edition is 0u16.
The checksum is present and matches the hash of the program code.
The program_owner is present and matches the transaction signer.
The program ID does not already exist.
2. Program Upgrade (edition > 0): For an upgrade, the validation is more extensive [1]:

The program ID must already exist.
The new edition must be old_edition + 1.
The upgraded code must follow all modification rules (e.g., no changing function signatures).
The existing on-chain program being upgraded must already have a constructor.
This final check is the lynchpin of the system. It ensures that only programs designed for upgradability can ever be changed.

Security and Best Practices
Upgradability is powerful, but it introduces risks around mutability. When you make a program upgradable, you take on the responsibility of managing that power securely. A malicious or compromised developer could push an upgrade that introduces vulnerabilities, drains funds, or freezes user assets.

When a user interacts with an upgradable program, they are trusting both the current code and the governance process that can change it.

Constructor is immutable
The most critical security component of an upgradable program is the constructor itself. Its logic is immutable and cannot be changed by a future upgrade.

A bug in the constructor is permanent and cannot be patched. If you hardcode the wrong admin address or have a flaw in your voting logic, you could be locked out or have your governance bypassed forever. Treat your constructor as mission-critical code and subject it to rigorous audits before deployment.

Design Patterns
You can use several patterns in your constructor to build safer, more trustworthy programs.

Multi-Signature Governance: Require multiple signatures for an upgrade to prevent a single point of failure.
Time-Locked Upgrades: Enforce a delay between announcing an upgrade and executing it. This gives users time to review the changes and opt out.
Program Ossification: Include a mechanism to permanently disable future upgrades, for example by setting the constructor only runs when program edition is 0 but not future edition.
Dependency Pinning: If your program depends on another upgradable program, you can "pin" the dependency to a specific version by asserting its edition in a finalize block (e.g., assert.eq child.aleo/edition 0u16;). This protects you from breaking changes in the dependency but requires you to upgrade your own program to adopt new, legitimate versions of that dependency. Example below.
Examples
The constructor lets you implement a wide range of governance models. Below are practical, commented examples written in Aleo Instructions (the low-level format executed by the AVM) for common upgrade patterns.

To learn how to write these patterns in the Leo language, please refer to the Leo documentation.

Non-upgradable program
A program that can never be upgraded.

program noupgrade_example.aleo;

constructor:
    // This assertion checks if the program's edition is 0.
    // It passes on initial deployment. For any upgrade attempt,
    // the edition will be > 0, causing the assertion to fail and
    // halting the upgrade transaction.
    assert.eq edition 0u16;

//... other program logic...


The constructor ensures the program can only be deployed at edition 0, making upgrades impossible.

Admin-controlled upgrades
Restrict upgrades to a single, hardcoded administrator address.

program admin_example.aleo;

constructor:
    // This asserts that the address deploying this version of the program is the predefined ADMIN_ADDRESS.
    // IMPORTANT: This address is hardcoded and cannot be changed after deployment.
    assert.eq program_owner <ADMIN_ADDRESS>;

//... other program logic...


This pattern uses program_owner operand to check that the deployer is the designated admin. It's simple, but if the admin key is lost, control is lost forever.

Configurable admin & pre-approved upgrades
Allow a changeable admin to pre-authorize specific upgrades by their checksum.

program preapproved_example.aleo;

mapping admin:
    key as boolean.public;
    value as address.public;

mapping expected:
    key as boolean.public;
    value as [u8; 32u32].public;

constructor:
    // If this is the first deployment (edition 0), set the initial admin.
    branch.neq edition 0u16 to upgrade_check;
    set <ADMIN_ADDRESS> into admin[true]; // Replace with the initial admin address.
    branch.eq true true to end;

    // For all upgrades, check the checksum against the pre-approved value.
    position upgrade_check;
    get expected[true] into r0;
    assert.eq checksum r0;

    position end;

// This function allows the current admin to set the checksum for the next upgrade.
function set_expected:
    input r0 as [u8; 32u32].public;
    async set_expected self.caller r0 into r1;
    output r1 as foo.aleo/set_expected.future;

finalize set_expected:
    input r0 as address.public; // The caller.
    input r1 as [u8; 32u32].public; // The expected checksum.
    // Get the current admin.
    get admin[true] into r2;
    // Check that the caller is the admin.
    assert.eq r0 r2;
    // Set the checksum for the next expected upgrade.
    set r1 into expected[true];


This pattern uses on-chain mappings to store the admin and the checksum of the next valid upgrade. A separate function, set_expected, allows the admin to authorize the next upgrade. Another function could be added to change the admin, providing more flexibility than a hardcoded address.

DAO-driven upgrades
Let an external DAO contract governs upgrades.

import governor.aleo;

program dao_example.aleo;

constructor:
    // If edition is 0 (first deployment), skip upgrade checks.
    branch.eq edition 0u16 to end;

    // This assumes 'governor.aleo' is a DAO contract that stores the
    // checksum of an approved upgrade in a mapping.
    get governor.aleo/approved_checksum[true] into r0;

    // Assert that the checksum of the program being deployed
    // matches the checksum approved by the DAO.
    assert.eq checksum r0;

    position end;

//... other program logic...


This pattern delegates upgrade authority to another program. The constructor fetches the valid checksum from the DAO contract, decoupling the application's logic from its governance.

Time-locked upgrade
Goal: Only allow upgrades after a specific block height.

program timelock_example.aleo;

constructor:
    // Checks if the edition is 0 (first deployment); if so, skips the time-lock check.
    gt edition 0u16 into r0;
    branch.eq r0 false to end_then_0_0;

    // Otherwise, it asserts that the current block height is greater than or equal
    // to the defined height, creating a time-lock for upgrades.
    gte block.height <BLOCK_HEIGHT> into r1;
    assert.eq r1 true;
    
    branch.eq true true to end_otherwise_0_1;
    position end_then_0_0;
    position end_otherwise_0_1;

//... other program logic...


Mechanism: This constructor uses block.height to enforce a time-based constraint, which can ensure a "cool-down" period before an upgrade is applied.[1]
Program ossification
Allow an admin to permanently lock a program from future upgrades.

program ossification_example.aleo;

mapping is_locked:
    key as boolean.public;
    value as boolean.public;

constructor:
    // This check runs on every upgrade attempt. If the 'is_locked' flag
    // is true, the assertion fails, halting the upgrade.
    contains is_locked[true] into r0;
    assert.eq r0 false;

    //... other upgrade logic (e.g., admin check) can follow...

//... other logic, including a function for an admin to set is_locked[true] to true.


*This pattern uses a mapping as a one-way flag. Once set to true, the constructor will block all future upgrade attempts.

Managing dependencies
Protect a program from unexpected upgrades in its dependencies by pinning to a specific version.

import child.aleo;

program parent.aleo;

constructor:
    //... Programs that fix dependencies should have an upgrade mechanism
    // in case the dependency made an upgrade.

function some_function:
    //... logic that calls a function from child.aleo
    call child.aleo/some_child_function...;

finalize some_function:
    //...
    // In the finalize scope, assert that the dependency is on the expected edition.
    // This must be in finalize, as the 'edition' operand is only available here.
    assert.eq child.aleo/edition 0u16;
    //...

//... other program logic...


This is a defensive pattern used in a finalize block, not the constructor. It checks the edition of a dependency before interacting with it. This prevents breaking changes but requires an upgrade to parent.aleo to adopt a new, valid version of child.aleo.

important
If using this pattern, we recommend you make your program upgradable, in case your function is locked due to a dependency upgrade.

Quick Reference Summary
Concept	Mechanism	Critical Takeaway
Enabling Upgradability	All new programs must specify how they will handle upgrades.	Know your upgrade.
Legacy Program Status	Programs deployed before the feature lack a constructor.	Permanently non-upgradable.
Upgrade Authority	The immutable logic within the constructor.	Your constructor is your governance. Its logic is permanent.
Core Risk	The constructor logic itself is immutable and cannot be patched.	A bug in the constructor is permanent. Audit this code with extreme care.
Valid Upgrade Changes	Modify logic in functions/finalize; add new components.	Interfaces (function signatures, existing data structures) cannot be changed or removed.
Program Ossification	Logic in the constructor to permanently revoke upgrade authority.	Provide a path to make your program immutable to build long-term user trust.
Pre-Upgradability Programs
All programs deployed to the Aleo network before the upgradability feature was activated are, and will remain, permanently non-upgradable.

The AVM's validation logic requires that an existing program must have a constructor to be upgraded. Since legacy programs were created before the constructor existed, they don't have one. Any attempt to upgrade a legacy program will automatically fail the AVM's checks.

note
A program with a constructor is upgradable.
A program without a constructor is permanently non-upgradable.
The No-Migration Policy
Early proposals discussed a "one-time migration" path that would have allowed owners of legacy programs to add a constructor.

This proposed migration path has been officially rescinded and is not supported by the protocol. There is no way to retroactively add a constructor to a program that has already been deployed.

If you maintain a legacy application and need to add new features or fix bugs, you must deploy an entirely new program and create a migration path for your users to move their state and assets.

Token Registry Program
Overview
The Token Registry Program is a standard program designed for issuing and managing new tokens on the Aleo blockchain. It operates as a singleton program because on Aleo, all imported programs must be known and deployed before the importing program, and dynamic cross-program calls are not currently supported which makes composability difficult to implement. This means that a DeFi program must be compiled with support for all token programs that it will ever interact with. If a new token program is subsequently deployed on-chain, the DeFi program will need to be re-compiled and redeployed on chain in order to interact with that token.

In the near-term, support for dynamic dispatch will resolve this but currently, the issue is circumvented by means of the token registry which can manage balances for many different ARC-20 tokens. This program would be the standard "hub" that all tokens and DeFi programs interface with. Individual ARC-20 tokens can register with the registry and mint new tokens via this program. Transfers of token value will occur by direct call to the registry rather than the ARC-20 program itself. The benefit of this approach is that DeFi programs do not need to be compiled with any special knowledge of individual ARC-20 tokens: their sole dependency will be the registry. Hence the deployment of new tokens does not require re-deployment of DeFi programs. Similarly, individual ARC-20 tokens can also be compiled with dependence on the registry, but no dependence on the DeFi programs. The registry thus allows interoperability between new tokens and DeFi programs, with no need for program re-deployment. As a secondary benefit, the registry will provide privacy benefits (via an improved anonymity set) because all private transfers within the registry will conceal the identity of the specific token being transferred.

This standard is emerged from extensive discussions and the approval of the ARC-21 proposal to enable token interoperability across different applications.

This documentation outlines the functions of the Token Registry Program and provides guidance on how to use it. The original source code can be found here.

How to use the Token Registry Program
Anyone can create a new token on Aleo using the token_registry.aleo program by calling the register_token transition with a unique token ID and specifying any name, symbol, decimals, and maximum supply. An optional external_authorization_required boolean grants extra control over token available to spend by requiring extra approval from an external_authorization_party, the external_authorization_party can unlocks certain amount of balances for spending with expiration over a specific owner's token using prehook_public or prehook_private. The admin can also set external_authorization_party to another address with update_token_management later if needed.

Once a token is registered, the tokens can be minted either publicly using mint_public or privately to a specific recipient using mint_private with roles MINTER_ROLE or SUPPLY_MANAGER_ROLE if not admin. The tokens can also be burned either publicly with burn_public or privately with burn_private with roles BURNER_ROLE or SUPPLY_MANAGER_ROLE if not admin.

The token owner then can transfer the token either publicly using transfer_public or privately to a specific recipient using transfer_private. The token can also be converted from public to private using transfer_public_to_private or from private to public using transfer_private_to_public.

Token Registry Program Data Structures
Token Record
  record Token {
    owner: address,
    amount: u128,
    token_id: field,
    external_authorization_required: bool,
    authorized_until: u32
  }

Token Record Fields
owner: The address of the token owner.
amount: The amount of tokens in the account.
token_id: The unique identifier for the token.
external_authorization_required: Whether or not the token requires external authorization.
authorized_until: The block height until which the token is authorized.
Token Metadata Struct
  struct TokenMetadata {
    token_id: field,
    name: u128, // ASCII text represented in bits, and the u128 value of the bitstring
    symbol: u128, // ASCII text represented in bits, and the u128 value of the bitstring
    decimals: u8,
    supply: u128,
    max_supply: u128,
    admin: address,
    external_authorization_required: bool, // whether or not this token requires authorization from an external program before transferring
    external_authorization_party: address
  }


Token Metadata Struct Fields
token_id: The unique identifier for the token.
name: The name of the token.
symbol: The symbol of the token.
decimals: The number of decimals for the token.
supply: The total supply of the token.
max_supply: The maximum supply of the token.
admin: The address of the token admin.
external_authorization_required: Whether or not the token requires external authorization.
external_authorization_party: The address of the external authorization party.
Token Owner Struct
  struct TokenOwner {
    account: address,
    token_id: field
  }

Token Owner Struct Fields
account: The address of the token owner.
token_id: The unique identifier for the token.
Balance Struct
  struct Balance {
    token_id: field,
    account: address,
    balance: u128,
    authorized_until: u32
  }

Balance Struct Fields
token_id: The unique identifier for the token.
account: The address of the token owner.
balance: The balance of the token.
authorized_until: The block height until which the token is authorized.
Allowance Struct
  struct Allowance {
    account: address,
    spender: address,
    token_id: field
  }

Allowance Struct Fields
account: The address of the token owner.
spender: The address of the spender.
token_id: The unique identifier for the token.
Token Registry Program Mappings
mapping registered_tokens: field => TokenMetadata;
Mapping of token IDs to token metadata structs.

mapping balances: field => Balance;
Mapping of the hash of the token ID and the account address to the balance struct.

mapping allowances: field => Allowance;
Mapping of the hash of the token ID, the account address, and the spender address to the allowance struct.

mapping roles: field => u8;
Mapping of the hash of the token ID and the account address to the role.

Token Registry Program Constants
const CREDITS_RESERVED_TOKEN_ID: field = 3443843282313283355522573239085696902919850365217539366784739393210722344986field;
Token ID reserved for the ALEO credits token.

const MINTER_ROLE: u8 = 1u8;
Role for the minter.

const BURNER_ROLE: u8 = 2u8;
Role for the burner.

const SUPPLY_MANAGER_ROLE: u8 = 3u8;
Role for the supply manager.

Token Registry Program Functions
The Token Registry Program includes the following functions:

initialize()
Description
Initializes the Token Registry Program by registering the ALEO credits token with predefined metadata. The token is initialized with a specific token ID, name "credits", symbol "credits", 6 decimals, and a max supply of 10 quadrillion. The program sets itself (wrapped_credits.aleo) as the admin and disables external authorization requirements to ensure the token metadata cannot be modified after initialization.

Parameters
Parameters are hardcoded in program to safeguard against frontrunning.

Returns
None.

register_token()
Description
Registers a new token with the Token Registry Program.

Parameters
public token_id: field: The unique identifier for the token.
public name: u128: The name of the token.
public symbol: u128: The symbol of the token.
public decimals: u8: The number of decimals for the token.
public max_supply: u128: The maximum supply of the token.
public external_authorization_required: bool: Whether or not the token requires external authorization.
public external_authorization_party: address: The address of the external authorization party.
Returns
Future: A Future to finalize the token registration.
update_token_management()
Description
Updates the token management settings.

Parameters
public token_id: field: The unique identifier for the token.
public admin: address: The address of the admin.
public external_authorization_party: address: The address of the external authorization party.
Returns
Future: A Future to finalize the token management update.
set_role()
Description
Sets the role for a specific token ID.

Parameters
public token_id: field: The unique identifier for the token.
public account: address: The address of the account.
public role: u8: The role to set.
Returns
Future: A Future to finalize the role set.
remove_role()
Description
Removes the role for a specific token ID.

Parameters
public token_id: field: The unique identifier for the token.
public account: address: The address of the account.
Returns
Future: A Future to finalize the role removal.
mint_public()
Description
Mints a new token publicly by the specific token ID's admin.

Parameters
public token_id: field: The unique identifier for the token.
public recipient: address: The address of the recipient.
public amount: u128: The amount of tokens to mint.
public authorized_until: u32: The block height until which the token is authorized.
Returns
Future: A Future to finalize the mint.
mint_private()
Description
Mints a new token privately by the specific token ID's admin.

Parameters
public token_id: field: The unique identifier for the token.
recipient: address: The address of the recipient that is not visible to the public.
public amount: u128: The amount of tokens to mint.
public external_authorization_required: bool: Whether or not the token requires external authorization.
public authorized_until: u32: The block height until which the token is authorized.
Returns
Token: The token record.
Future: A Future to finalize the mint.
burn_public()
Description
Burns a token publicly by the specific token ID's admin.

Parameters
public token_id: field: The unique identifier for the token.
public owner: address: The address of the owner.
public amount: u128: The amount of tokens to burn.
Returns
Future: A Future to finalize the burn.
burn_private()
Description
Burns a token privately by the specific token ID's admin.

Parameters
input_record: Token: The token record.
public amount: u128: The amount of tokens to burn.
Returns
Token: The token record with remaining balance.
Future: A Future to finalize the burn.
prehook_public()
Description
A function for the authorized party to modify authorized amount and new expiration publicly.

Parameters
public owner: address: The address of the owner.
public amount: u128: The amount of tokens to prehook.
public authorized_until: u32: The block height until which the token is authorized.
Returns
Future: A Future to finalize the prehook.
prehook_private()
Description
A function for the authorized party to modify authorized amount and new expiration privately.

Parameters
input_record: Token: The token record.
amount: u128: The amount of tokens to prehook.
authorized_until: u32: The block height until which the token is authorized.
Returns
Token: The unauthorized token record.
Token: The authorized token record.
Future: A Future to finalize the prehook.
transfer_public()
Description
Transfers a token publicly by the token owner.

Parameters
public token_id: field: The unique identifier for the token.
public recipient: address: The address of the recipient.
public amount: u128: The amount of tokens to transfer.
Returns
Future: A Future to finalize the transfer.
transfer_public_as_signer()
Description
Transfers a token publicly by the token owner as the transaction signer in any arbitrary program calls.

Parameters
public token_id: field: The unique identifier for the token.
public recipient: address: The address of the recipient.
public amount: u128: The amount of tokens to transfer.
Returns
Future: A Future to finalize the transfer.
approve_public()
Description
Approves a token for a spender to be able to transfer the token on behalf of the owner.

Parameters
public token_id: field: The unique identifier for the token.
public spender: address: The address of the spender.
public amount: u128: The amount of tokens to approve.
Returns
Future: A Future to finalize the approval.
unapprove_public()
Description
Revokes or reduces the approval for a spender to transfer the token on behalf of the owner.

Parameters
public token_id: field: The unique identifier for the token.
public spender: address: The address of the spender.
public amount: u128: The amount of tokens to unapprove.
Returns
Future: A Future to finalize the unapproval.
transfer_from_public()
Description
Transfers a token from the owner to the recipient after getting approval from the owner.

Parameters
public token_id: field: The unique identifier for the token.
public owner: address: The address of the owner.
public recipient: address: The address of the recipient.
public amount: u128: The amount of tokens to transfer.
Returns
Future: A Future to finalize the transfer.
transfer_public_to_private()
Description
Convert public token to private token by its owner.

Parameters
public token_id: field: The unique identifier for the token.
recipient: address: The address of the recipient that is not visible to the public.
public amount: u128: The amount of tokens to transfer.
public external_authorization_required: bool: Whether or not the token requires external authorization.
Returns
Token: The token record.
Future: A Future to finalize the transfer.
transfer_from_public_to_private()
Description
Convert public token to private token on behalf of the token owner after getting approval from the owner.

Parameters
public token_id: field: The unique identifier for the token.
public owner: address: The address of the owner.
recipient: address: The address of the recipient that is not visible to the public.
public amount: u128: The amount of tokens to transfer.
public external_authorization_required: bool: Whether or not the token requires external authorization.
Returns
Token: The token record.
Future: A Future to finalize the transfer.
transfer_private()
Description
Transfers a token privately by the token owner.

Parameters
recipient: address: The address of the recipient that is not visible to the public.
amount: u128: The amount of tokens to transfer.
input_record: Token: The token record.
Returns
Token: The remaining token record.
Token: The receiving token record.
Future: A Future to finalize the transfer.
transfer_private_to_public()
Description
Convert private token to public token by the token owner.

Parameters
public recipient: address: The address of the recipient that is visible to the public.
public amount: u128: The amount of tokens to transfer.
input_record: Token: The token record.
Returns
Token: The remaining token record.
Future: A Future to finalize the transfer.
join()
Description
Joins two private token records and become one single record. Does not change the total amount of the tokens.

Parameters
private token_1: Token: The first token record.
private token_2: Token: The second token record.
Returns
Token: The joined token record.
split()
Description
Splits a private token record into two new token records. Does not change the total amount of the tokens.

Parameters
private token: Token: The token record.
private amount: u128: The amount of tokens to split.
Returns
Token: The splitted token record.
Token: The remaining token record.

NFT Standards
Overview
The NFT Standards document outlines the specifications for implementing Non-Fungible Tokens (NFTs) on the Aleo blockchain. This standard emerged from the ARC-0721 proposal and was officially approved through community voting on Aleo Governance.

Similar to the Token Registry Program, the NFT standard faces challenges with program composability due to Aleo's current limitations on dynamic cross-program calls. To address this, an NFT Registry Program (ARC-722) has been proposed, which would serve as a central hub for NFT collections and enable better interoperability between NFTs and DeFi applications.

Key Features
The standard leverages Aleo's unique privacy features to provide:

Private or public token owner visibility
Private or public data associated with the token
Flexible on-chain and off-chain data storage options
Data Storage Options
On-chain vs Off-chain Data
The standard allows for NFT data to be stored in three ways:

On-chain Data

Direct storage of data on the blockchain
Can be either the complete data or a hash of the data
Off-chain Data

Reduces storage fees on the network
Typically stored as URIs pointing to external metadata
Can be combined with on-chain data for hybrid approaches
Hybrid Approach

Combination of on-chain and off-chain storage
Data can be public is stored on-chain (NFT ownership for example)
Private data is stored off-chain (NFT data for example)
Data Structures
NFT Record
record NFT {
    private owner: address,
    private data: data,
    private edition: scalar,
}

NFT Record Fields
owner: The private address of the NFT owner
data: The private data associated with the NFT
edition: A scalar value used for uniqueness and privacy
NFT View Record
record NFTView {
    private owner: address,
    private data: data,
    private edition: scalar,
    private is_view: bool
}

NFT View Record Fields
owner: The private address of the NFT owner
data: The private data associated with the NFT
edition: A scalar value used for uniqueness and privacy
is_view: A boolean flag to differentiate NFTView from NFT (always true)
Data Structure
struct attribute {
    trait_type: [field; 4],
    _value: [field; 4],
}

struct data {
    metadata: [field; 4], // URI of offchain metadata JSON
    // (optional) name: [field; 4],
    // (optional) image: [field; 16],
    // (optional) attributes: [attribute; 4],
    // (optional) ...
}


Data Structure Fields
metadata: URI pointing to off-chain metadata JSON
name: Optional name of the NFT
image: Optional image data
attributes: Optional array of attributes
An example of such an off-chain metadata JSON can be found here.

NFT Content Struct
struct nft_content {
    data: data,
    edition: scalar
}

NFT Content Struct Fields
data: The data associated with the NFT
edition: The edition number of the NFT
Mappings
mapping nft_commits: field => bool;
Mapping of NFT commits to their existence status.

mapping nft_owners: field => address;
Mapping of NFT commits to their public owners.

mapping nft_contents: field => nft_content;
Mapping of NFT commits to their public content.

Functions
commit_nft()
Description
Creates a unique identifier for an NFT by committing its data and edition to a field.

Parameters
nft_data: data: The data of the NFT
nft_edition: scalar: The edition number of the NFT
Returns
field: The NFT commit identifier
transfer_private_to_public()
Description
Converts a privately owned NFT to public ownership.

Parameters
private nft: NFT: The NFT record to convert
public to: address: The public recipient address
Returns
NFTView: The NFT view record
Future: A Future to finalize the transfer
publish_nft_content()
Description
Publishes NFT content to make it publicly accessible.

Parameters
public nft_data: data: The NFT data to publish
public nft_edition: scalar: The edition number to publish
Returns
Future: A Future to finalize the publication
update_edition_private()
Description
Updates the edition of a private NFT to re-obfuscate its content.

Parameters
private nft: NFT: The NFT record to update
private new_edition: scalar: The new edition number
Returns
NFT: The updated NFT record
Future: A Future to finalize the update
String Encoding
NFTs heavily rely on the use of strings, either for URL to off-chain data or for data itself. The standard specifies the following encoding for strings:

// Leo
string: [field; 4],

// Aleo instructions
string as [field; 4u32];

The length of the array can be freely adapted to match the maximum amount of characters required by the collection. The choice of fields type is motivated by the fact that they offer close to twice the amount of data for the same constraints as u128.

For JavaScript/TypeScript applications, an example for converting between JavaScript strings and Aleo plaintexts is available in the ARC-721 implementation.

Privacy Features
The standard implements privacy through several mechanisms:

Ownership Privacy
Private ownership is achieved through Aleo records
Public ownership can be enabled via the nft_owners mapping
Programs can own NFTs without revealing their data
Data Privacy
NFT data is kept private by default in records
The edition scalar ensures uniqueness without revealing data
NFT commits serve as unique identifiers without exposing underlying data
Re-obfuscation
NFTs can be re-obfuscated through a two-step process:

Transfer back to private ownership
Update the edition using update_edition_private()
async transition update_edition_private(
    private nft: NFT,
    private new_edition: scalar,
) -> (NFT, Future) {
    let out_nft: NFT = NFT {
        owner: nft.owner,
        data: nft.data,
        edition: new_edition,
    };
    let nft_commit: field = commit_nft(nft.data, new_edition);

    let update_edition_private_future: Future = finalize_update_edition_private(
        nft_commit
    );
    return (out_nft, update_edition_private_future);
}

async function finalize_update_edition_private(
    nft_commit: field,
) {
    assert(nft_commits.contains(nft_commit).not());
    nft_commits.set(nft_commit, true);
}


Important privacy considerations:

Previous NFT commits remain in the mapping to prevent revealing data relationships
New editions must be unique
Process maintains data privacy while creating new public identifiers
Approvals
The standard includes an approval mechanism that allows designated addresses to transfer NFTs on behalf of the owner. The approval system supports both collection-wide and individual NFT approvals:

struct approval {
    approver: address,
    spender: address
}

mapping for_all_approvals: field => bool; 
// Approval hash => Is approved

mapping nft_approvals: field => field;
// NFT commit => Approval hash

The approval system provides two main functions:

set_for_all_approval: Allows an owner to approve a spender for all NFTs in the collection
approve_public: Allows an owner to approve a spender for a specific NFT
Once approved, the spender can use transfer_from_public to transfer the NFT from the approver to a recipient address.

Settings
Collection-level settings are managed through a mapping:

mapping general_settings: u8 => field;
// Setting index => Setting value

Available settings indices and their purposes:

0u8: Amount of mintable NFTs (all editions)
1u8: Number of total NFTs (first-editions) that can be minted
2u8: Symbol for the NFT
3u8: Base URI for NFT, part 1
4u8: Base URI for NFT, part 2
5u8: Base URI for NFT, part 3
6u8: Base URI for NFT, part 4
7u8: Admin address hash
These settings allow for fine-grained control over the NFT collection's properties, including minting limits, metadata location, and administrative controls.

Implementation Notes
The standard is compatible with ARC21 standard for name and symbol of fungible tokens.

For collections where data can become public ("publishable collections"), the standard provides mechanisms to publish and manage public content while maintaining the option to re-obfuscate data when needed.

The NFT Registry Program (ARC-722) is proposed to address program composability challenges, similar to how the Token Registry Program works for fungible tokens. This registry would allow multiple implementations with different data structures, identified by the unique pair (registry_program_id, collection_id).


Aleo Name Service
Overview
The Aleo Name Service (ANS) is a standard program designed for managing human-readable domain names on the Aleo blockchain. This standard emerged from the ARC-137 proposal and was officially approved through community voting on Aleo Governance.

ANS aims to simplify the interaction with Aleo's resources by allowing memorable and updatable human-readable identifiers. It supports both public and private domain names, each serving distinct use cases and privacy needs. Public domain names provide stable, human-readable identifiers that can be used to specify network resources, while private domain names enable private transfer of Aleo Credits (ACs) without revealing the recipient's real Aleo address.

Compatibility with ARC-0721
While ANS aims to be compatible with the ARC-0721 standard, it requires some modifications to the NFT structure to support its unique domain name registration functionality. These differences are necessary to enable the dynamic creation of domain name identifiers while maintaining compatibility with the broader Aleo ecosystem.

Divergence in NFT Structure
One of the key differences lies in the structure of the NFT used within ANS. While ARC-0721 defines a standard structure for NFTs, ANS requires a dynamic approach to the data field within the NFT record. This is due to the nature of domain name registration, where each NFT must reflect a unique identifier (name_hash) that is only determined at the time of domain registration by the user. Below is the ANS-specific NFT structure:

// The ANS NFT structure diverges from ARC-0721 in the `data` field.
// Here, `data` is not predefined but is dynamically created based on the domain name registered by the user.
// This `data` serves as the name_hash of the name, uniquely identifying the domain within ANS.
record NFT {
    owner: address,
    data: data, 
    edition: scalar // The edition number, similar to ARC-0721's structure.
}


Embracing Differences for Enhanced Functionality
The modifications to the NFT structure within ANS are necessary to support the protocol's functionality and objectives. While ANS strives to align with existing standards like ARC-0721, it also recognizes the need to innovate and adapt its NFT representation to serve its unique purpose effectively. This approach ensures that ANS can provide a robust and privacy-centric naming service that complements the broader Aleo ecosystem.

It is important for the community and developers to be aware of these differences for a seamless integration and to leverage the strengths of both standards where they apply.

This documentation outlines the functions of the Aleo Name Service Program and provides guidance on how to use it. The original source code can be found in the GitHub Repository.

ANS Components
The Aleo Name Service consists of three main components:

Registry Program: Manages the domain name system, mapping names to resolvers and allowing updates to these mappings
Registrars: Handle domain name assignments and top-level domain management
Resolvers: Process resource lookups and return requested data
Registry Program
The Registry Program is the core component of ANS, responsible for managing the domain name system and maintaining the mappings between names and their associated data.

Data Structures
Name Struct
struct Name {
    name: [u128; 4],
    parent: field // The name_hash of the parent name, for top level domain(tld), this attribute is 0field.
}


NameStruct
struct NameStruct {
    name: [u128; 4],
    parent: field,
    resolver: field // The resolver program address
}

Data Struct
struct data {
    metadata: [field; 4], // the first element is the name_hash of the name
}


NFT Record
record NFT {
    owner: address,
    data: data,
    edition: scalar
}

NFTView Record
record NFTView {
    owner: address,
    data: data,
    edition: scalar,
    is_view: bool
}

Mappings
mapping nft_owners: field => address;  
mapping names: field => NameStruct;  
mapping tlds: field => [u128; 4];  
mapping primary_names: address => field;  
mapping name_versions: field => u64;  
mapping resolvers: ResolverIndex => [u128; 4];  
mapping domain_credits: field => u64;  

Core Functions
The Registry Program provides the following core functions:

register_tld(): Registers a new top-level domain
register(): Registers a new domain name
register_private(): Registers a private subdomain
register_public(): Registers a public domain
transfer_private(): Transfers ownership of a private domain
transfer_public(): Transfers ownership of a public domain
set_primary_name(): Sets a domain as the primary name for an address
unset_primary_name(): Removes the primary name setting
set_resolver(): Sets the resolver address for a domain
Registrars
Registrars are responsible for managing domain name assignments and top-level domain (TLD) operations. They work in conjunction with the Registry Program to handle domain registration and management.

Registrar Functions
Domain name validation
TLD management
Registration fee handling
Domain renewal processing
Resolvers
Resolvers are specialized programs that process resource lookups and return requested data for domains. They handle the actual resolution of domain names to their associated resources.

Resolver Functions
Resource lookup processing
Data resolution
Record management
Version control
ResolverIndex Struct
struct ResolverIndex {
    name: field, // The name_hash of the domain
    category: u128, // The type of the resolver
    version: u64 // The version of the resolver
}

Resolver Operations
set_resolver_record(): Sets a resolver record for a private domain
unset_resolver_record(): Removes a resolver record for a private domain
set_resolver_record_public(): Sets a resolver record for a public domain
unset_resolver_record_public(): Removes a resolver record for a public domain
Privacy Credit Transfer Scheme
The Privacy Credit Transfer Scheme is an innovative feature built upon the Aleo Name Service (ANS) that facilitates the private transfer of credits. This scheme ensures that neither party in the transaction is required to disclose their Aleo address, thereby enhancing privacy while maintaining ease of use.

Transfer Credits
This function enables the transfer of credits to an ANS domain without revealing the recipient's real Aleo address. It involves a secret that allows the domain holder to claim the transferred credits privately.

Transfer private credits to ANS name
// Function for transferring credits to an ANS domain without revealing the domain holder's real address.
// @param receiver: The name_hash of the recipient ANS domain.
// @param secret: The secret associated with the transaction, used for claim verification.
// @param amount: The amount of credits to be transferred.
// @param pay_record: The record of the payment being made.
transition transfer_credits(receiver: field, secret: [u128; 2], amount: u64, pay_record: credits.leo/credits)


Transfer public credits to ANS name
// Function for transferring credits to an ANS domain without revealing the domain holder's real address.
// @param receiver: The name_hash of the recipient ANS domain.
// @param secret: The secret associated with the transaction, used for claim verification.
// @param amount: The amount of credits to be transferred.
transition transfer_credits_public(receiver: field, secret: [u128; 2], amount: u64)


Claim Credits
These functions allow domain holders to claim the transferred credits. Depending on whether the domain is public or private, the appropriate claim function is used.

Claim Credits Private
// Function for a domain holder to claim credits using a private ANS domain represented by an NFT and a secret.
// This ensures that the claim process remains private and the domain holder's real address is not exposed.
// @param receiver: The receiver address
// @param nft: The NFT record representing the private ANS domain.
// @param secret: The secret used to verify the claim.
// @param amount: The amount of credits to be claimed.
transition claim_credits_private(receiver: address, nft: NFT, secret: [u128; 2], amount: u64)


Claim Credits Public - the caller is the owner of the ANS name
// Similar to the private claim function, this enables the claiming of credits for a public ANS domain.
// The domain holder uses a secret to claim the credits, maintaining privacy.
// @param receiver: The receiver address
// @param name_hash: The name_hash of the public ANS domain.
// @param secret: The secret used to verify the claim.
// @param amount: The amount of credits to be claimed.
transition claim_credits_public(receiver: address, name_hash: field, secret: [u128; 2], amount: u64)


Claim Credits as Signer - the signer is the owner of the ANS name
// Similar to the private claim function, this enables the claiming of credits for a public ANS domain.
// The domain holder uses a secret to claim the credits, maintaining privacy.
// @param receiver: The receiver address
// @param name_hash: The name_hash of the public ANS domain.
// @param secret: The secret used to verify the claim.
// @param amount: The amount of credits to be claimed.
transition claim_credits_as_signer(receiver: address, name_hash: field, secret: [u128; 2], amount: u64)


Comparison Table
A side-by-side comparison between Leo (Aleo) and Solidity (Ethereum/EVM).

Feature	Leo	Solidity
Execution Model	Off-chain execution + on-chain proof verification and optional on-chain execution	Fully on-chain execution
State Model	Public key-value mapping and private record storage	Key-value contract storage, temporary transient storage, temporary memory and read-only calldata
Privacy	Built-in privacy with private inputs (messages), private outputs (state changes) and private user	No privacy ‚Äì all state and calldata are public
Execution Cost	Storage cost + finalize cost (on-chain compute based on instruction)	Gas based on opcode
Supported Types	bool, u8‚Ä¶u128, i8‚Ä¶i128, plus field, group, scalar; no bytes, dynamic arrays and string	bool, (u)int8‚Ä¶256, bytes, dynamic arrays, string, etc.
Tooling	leo CLI, Leo debugger, IDE plugins, DokoJS, Amareleo	Hardhat, Foundry, Remix, Truffle etc.
Randomness	ChaCha random function	Relies on 3rd party off-chain oracle (e.g. Chainlink VRF)
Error Handling	assert, assert_eq, assert_neq (no custom msg)	assert, require, revert with optional revert strings
Dispatch Type	Static dispatch (with dynamic dispatch in roadmap)	Dynamic dispatch
Built-in Functions	block.height, block.timestamp, self.signer, self.caller, self.address, network.id, signature::verify, group::GEN, BHP hashes and commits, Keccak hashes, Pedersen hashes and commits, Poseidon hashes, SHA3 hashes etc.	keccak256, sha256, ripemd160, ecrecover, address.(member functions), abi.encode, abi.decode, block.(metadata) etc.
Token Standard	ARC-21	ERC20
NFT Standard	ARC-721	ERC721
Upgradability	Native upgradeability coming soon with ARC-6	Via proxy patterns (Transparent, UUPS, Beacon)
Block Explorers	Provable Explorer (Beta), VXB.ai (Formerly Aleo123.io), Aleoscan etc.	Etherscan, Blockscout etc.

Migration Guide
This guide provides a comprehensive comparison between Solidity (Ethereum's smart contract language) and Leo (Aleo's programming language for zero-knowledge applications). The document covers fundamental differences between these languages and offers practical examples to assist developers transitioning from Ethereum development to Aleo.

Execution Models
Leo and Solidity differ fundamentally in their execution approaches:

Ethereum/Solidity: On-chain execution where all computation occurs on the blockchain
Aleo/Leo: Off-chain execution with zero-knowledge proofs, where computation occurs privately and only the proof is verified on-chain
This difference influences many language design decisions that can be seen below.

Basic Structure
Headers
Programs begin differently in each language:

Solidity Contract:

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract MyToken {
    // Contract implementation
}

Leo Program:

// No license identifier required
// No pragma needed

program my_token.aleo {
    // Program implementation
}

Key Differences:

Leo does not require license identifiers or pragma statements
Import statements in Leo use program IDs rather than file paths
Leo programs must have a .aleo suffix in their name
To define a contract in Solidity, contract is used as the keyword. In Leo, programs (equivalent to smart contracts in Solidity) are defined with the program keyword, followed by curly brackets {}
Constructor
Constructor in Solidity is optional. Leo does not have a constructor currently, but ARC-0006: Program Upgradability will introduce a must-have constructor in new programs in Leo. While constructor in Solidity only runs once, constructor in Leo is immutable and will run as part of a deployment or upgrade, thus is used to define the program upgradability logic.

Comments
Both languages support identical comment syntax:

// Single line comment in both languages

/*
 * Multi-line comments
 * work identically too
 */

Imports
Solidity's Import System:

// Import entire file
import "./MyContract.sol";

// Import specific symbols
import {Symbol1, Symbol2} from "./MyContract.sol";

// Import with alias
import * as MyAlias from "./MyContract.sol";

// Import from node_modules
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";


Leo's Import System:

import credits.aleo;

program helloworld.aleo {
    // Program implementation
}

Important: Leo imports must also be declared in program.json:

{
  "program": "my_token.aleo",
  "version": "0.0.0",
  "description": "",
  "license": "MIT",
  "dependencies": [
    {
      "name": "credits.aleo",   
      "location": "network",    // Importing from network
      "network": "testnet"
    },
    {
      "name": "board.aleo",      
      "location": "local",      // Importing from local
      "path": "../board"
    }
  ]
}


Dependency Types:

Network dependencies: Programs deployed on Aleo networks (mainnet, testnet)
Local dependencies: Programs in local file system directories
Key Import Difference:

Solidity: Imports copy code directly into your contract at compile time, combining everything into one file
Leo: Imported programs remain separate entities - they are not merged with the current file, and each keeps its own unique program ID on the blockchain
Data & State
State Variables and Storage Models
Solidity and Leo differ significantly in how they handle state variables, storage, and data privacy.

Solidity's Approach:

contract Storage {
    // State variables with visibility modifiers (access control only)
    uint256 public constant FIXED_VALUE = 100;  // Compile-time constant
    uint256 public immutable RUNTIME_VALUE;     // Set in constructor
    uint256 public permanentData;               // Auto-generates getter function 
    uint256 internal shared;                    // Accessible in derived contracts
    uint256 private local = 42;                 // Inaccessible in derived contracts - still visible on-chain
    
    constructor(uint256 _value) {
        RUNTIME_VALUE = _value;  // Can be set at construction
    }
    
    function processData(uint256 tempData) public {
        uint256 memoryVar = tempData * 2;   // Memory (temporary)
        permanentData = memoryVar;          // Persisted to storage
    }
}


Leo's Approach:

program storage.aleo {
    // Compile-time constants only
    const FIXED_VALUE: u64 = 100u64;

    // Permanant public state: accessible to everyone
    mapping balances: address => u64;
    
    // Permanant private state: stored in records (with cryptographic privacy)
    record Token {
        owner: address,
        amount: u64,
    }
    
    // Transition parameters and returns are private by default unless marked public
    async transition process_data(public amount: u64) -> (Token, Future) {
        let amount_loc: u64 = amount * 2u64; // Local variable
        
        let token: Token = Token {
            owner: self.caller,
            amount: amount_loc,
        };
        
        return (token, finalize_process_data(self.caller, amount_loc));
    }
    
    // Async function to handle on-chain state updates
    // Parameters in async functions are automatically public since network nodes execute the computation
    // Async function cannot return values
    async function finalize_process_data(caller: address, amount_loc: u64) {
        let current_balance: u64 = Mapping::get_or_use(balances, caller, 0u64);
        Mapping::set(balances, caller, current_balance + amount_loc);
    }
}


Key Differences:

Solidity Visibility: private, internal, public control code access but all data is visible on-chain
Leo Privacy: public vs private determines actual cryptographic privacy - whether data is stored on-chain or off-chain in records
Constants: Solidity has both constant and immutable, Leo only has compile-time const
Local Variables: The let keyword declares temporary computation variables (similar to Solidity's memory)
No Transient Storage: Leo does not support Solidity's transient storage concept
Getter Functions
The compiler of Solidity automatically creates getter functions for all public state variables. Leo does not have similar features, but instead provides direct API access to query mapping values from the node without requiring getter functions in the program code.

// Solidity: automatic getter generated
contract Example {
    uint256 public value;  // Automatically creates value() function as getter
}


Key Difference:

Solidity: Requires public state variables or explicit getter functions for external access
Leo: Mapping values are accessible via REST API endpoints without any program code:
Endpoint: GET /{network}/program/{programID}/mapping/{mappingName}/{mappingKey}
Example: GET /testnet3/program/credis.aleo/mapping/account/aleo1abc...
Deleting state variables
Solidity's Delete Operation:

contract DeleteExample {
    uint256 public value = 100;
    mapping(address => uint256) public balances;
    
    function resetValue() public {
        delete value;  // Resets to initial value (0 for uint256)
    }
    
    function removeBalance(address user) public {
        delete balances[user];  // Removes mapping entry, resets to initial value (0)
    }
}


Leo's Mapping Operations:

program delete_example.aleo {
    mapping balances: address => u64;
    
    async transition remove_balance(user: address) -> Future {
        return finalize_remove_balance(user);
    }
    
    async function finalize_remove_balance(user: address) {
        // Check if mapping contains the key before removing
        let exists: bool = Mapping::contains(balances, user);
        if exists {
            // Remove mapping entry
            Mapping::remove(balances, user);
        }
    }
}


Key Differences:

Solidity: delete operator resets variables to their initial values (0 for numbers, false for booleans, empty for arrays)
Leo: Only supports removing entries from mappings using Mapping::remove()
No Direct Delete: Leo doesn't have a direct equivalent to Solidity's delete operator for other variable types
Mapping Focus: Leo's deletion functionality is focused on mapping entries, which is the primary state storage mechanism
Key Existence Check: Leo provides Mapping::contains() to check if a key exists in a mapping before operations
Data Types
The type systems differ in several ways:

Common Types (Similar Behavior):

// Solidity
bool flag = true;
uint32 smallNumber = 100;
address userAddr = 0x742d35...;

// Leo
let flag: bool = true;
let small_number: u32 = 100u32;  // Must append type suffix (u32)
let user_addr: address = aleo1abc...;


Type Suffix Requirement: In Leo, all literals must explicitly append their type suffix.

Leo Special Types:

Leo introduces several unique cryptographic types that don't exist in Solidity:

// Leo's unique cryptographic types
let field_element: field = 123field;          // Field elements for arithmetic
let group_element: group = group::GEN;        // Group elements for elliptic curves  
let scalar_value: scalar = 456scalar;         // Scalar values for cryptographic operations
let user_signature: signature = sign1...;     // Built-in signature type


Signature Verification: Leo's signature type uses the Schnorr signature scheme (different from Solidity's ECDSA), where signatures are generated using a nonce, challenge hash, and private key, then verified by reconstructing the challenge against the public key.

Leo Limitations:

Integer Limitations:
// Solidity: supports up to 256 bits
uint256 bigNumber = 115792089237316195423570985008687907853269984665640564039457584007913129639935;


// Leo: maximum 128 bits
let big_number: u128 = 340282366920938463463374607431768211455u128;
// uint256 equivalent does not exist


Types Not Supported in Leo:
// Solidity types that Leo does not support
string memory text = "Hello World";           // String type not available in Leo
bytes memory data = hex"1234";                // Bytes type not available in Leo
uint256[] memory dynamicArray;                // Dynamic arrays not available in Leo
mapping(string => uint256) stringMap;         // String keys in mappings not available in Leo
enum Status { Active, Inactive }              // Enum type not available in Leo 


// Leo alternatives or workarounds
let text_hash: field = 123456field;           // Convert text into Leo supported types such as Field
let static_array: [u32; 5] = [1u32, 2u32, 3u32, 4u32, 5u32]; // Fixed-size arrays only
mapping hash_map: field => u64;               // Use field for complex key types
const ACTIVE: u8 = 0u8;                       // Use constants instead of enums
const INACTIVE: u8 = 1u8;


Static Arrays in Leo:
// Solidity: supports both dynamic and static arrays
uint256[5] public staticArray;

function updateArray() public {
    staticArray[0] = 42;  // Direct element modification
}


// Leo: only supports static array 
transition simple_array() -> [u32; 3] {
    // Create a fixed-size array of 3 elements
    let numbers: [u32; 3] = [1u32, 2u32, 3u32];
    
    // Modify elements using explicit index type (u8)
    numbers[0u8] = 10u32;
    numbers[1u8] = 20u32;
    
    return numbers;
}

Key Static Array Features:

Fixed Size: Array size must be known at compile time
Element Access: Use explicit index types (e.g., array[0u8])
No Dynamic Operations: No push(), pop(), or resizing operations
Type Conversions
Solidity's Implicit Conversions:

uint8 small = 100;
uint256 big = small;  // Automatic conversion

// Solidity allows truncation
uint16 large = 300;
uint8 truncated = uint8(large);  // Only the rightmost 8 bits are kept


Leo's Explicit Conversions:

let small: u8 = 100u8;
let big: u32 = small as u32;  // Explicit casting required

// Leo fails on truncation (checked casting)
let large: u32 = 300u32;
let truncated: u8 = large as u8;  // Program fails - no truncation allowed unless able to fit into smaller size

// Safe conversions to larger types
let safe: u64 = small as u64;    // No truncation


Key Differences:

Leo requires explicit casting with the as keyword
Truncation Behavior: Solidity allows truncation during casting, Leo fails on potential data loss
Type Promotion: Solidity automatically promotes smaller types in operations, Leo requires explicit casting
Automatic Type Promotion Examples:

// Solidity: automatic type promotion
uint8 small = 100;
uint16 medium = 200;
uint16 result = small + medium;  // uint8 automatically promoted to uint16


// Leo: explicit casting required
let small: u8 = 100u8;
let medium: u16 = 200u16;
let result: u16 = (small as u16) + medium;  // Must explicitly cast u8 to u16
// let invalid: u16 = small + medium;  // This would fail - type mismatch


Reference vs Value Types
Solidity distinguishes between value types and reference types, requiring explicit data location specification:

contract TypeSystem {
    uint256[] storageArray;  // Permanently stored
    
    function processData(uint256[] memory memoryArray) public {
        uint256[] storage localRef = storageArray;    // Reference to storage
        uint256[] memory localCopy = storageArray;    // Copy to memory
        
        localRef[0] = 100;   // Modifies storage
        localCopy[0] = 200;  // Modifies memory copy only
    }
    
    function externalCall(uint256[] calldata data) external {
        // Calldata is read-only, cannot be modified
    }
}


Leo only supports value types - all data is copied when passed around:

program value_types.aleo {
    transition process_data(input_array: [u32; 5]) -> [u32; 5] {
        // All data is copied by value
        let local_array: [u32; 5] = input_array;  // Creates a copy
        
        // Can modify individual elements directly
        local_array[0u8] = input_array[0u8] + 1u32;
        local_array[1u8] = input_array[1u8] + 2u32;
        
        return local_array;
    }
}


Key Differences:

Leo Limitation: Only value types, no reference types
Memory Management: Leo handles memory management automatically based on type semantics, eliminating the need for explicit storage location specifications.
Functions
Function Types
Leo completely reimagines function architecture. Instead of Solidity's visibility modifiers, Leo uses different function types:

Solidity's Approach:

contract Example {
    uint256 private data;
    
    // External function - called from outside
    function publicFunction(uint256 input) external returns (uint256) {
        return internalHelper(input);
    }
    
    // Internal helper - accessible in inherited contracts
    function internalHelper(uint256 input) internal view returns (uint256) {
        return input * 2;
    }
    
    // Private function - only accessible within this contract
    function privateFunction() private pure returns (uint256) {
        return 42;
    }
}

contract Child is Example {
    function useParent(uint256 input) public returns (uint256) {
        return internalHelper(input);  // Can access internal functions
        // return privateFunction();   // Cannot access private functions
    }
}


Leo's Approach:

program example.aleo {
    // Transition: externally callable, off-chain execution
    // All inputs and outputs are private by default, requiring explicit 'public' keyword for on-chain visibility
    transition public_function(input: u32, public pub_input2: u32) -> (public u32, u32) {
        let result: u32 = internal_helper(input);
        let pub_result: u32 = result + pub_input2;
        return (pub_result, result);
    }
    
    // Function: helper for transitions (similar to pure functions)
    // Can only compute - no state access, no external calls
    function internal_helper(input: u32) -> u32 {
        let doubled: u32 = inline_multiplier(input, 2u32);
        return doubled;
    }
    
    // Inline: body inserted at call sites (similar to pure functions)
    // Can only compute - no state access, no external calls
    inline inline_multiplier(a: u32, b: u32) -> u32 {
        return a * b;
    }
}


Key Differences:

Externally Callable Functions: In Leo, only transition and async transition functions can be called externally. All other functions (function and inline) are internal and can only be called from within the program
Leo's Computation-Only Functions: Both function and inline in Leo are similar to Solidity's pure functions - they can only perform computations and cannot access state variables or make external calls
Visibility in Leo: Unlike Solidity's visibility modifiers (public, private, internal), Leo's visibility refers to data privacy - whether data is publicly visible on-chain or kept private off-chain
Function Overloading: Unlike Solidity which supports function overloading (multiple functions with the same name but different parameter types), Leo does not allow function overloading. Each function name must be unique within a program, requiring developers to use distinct names for functions with different parameter types.
Returns
In Leo, return types are specified using an arrow (->) syntax, similar to Rust, which differs from Solidity's returns keyword.

Key Differences:

Return Type Syntax: Leo only requires the type for returns, not identifiers (e.g., -> u32 vs Solidity's returns (uint256 value))
Return Value Handling: In Solidity, multiple return values can be selectively ignored using commas (e.g., (index, , ) = f();), while Leo requires all return values to be caught with exact types
Parameter Handling: Similarly, Solidity allows unused parameters to be omitted in function declarations, while Leo requires all parameters to be explicitly declared with their types
Modifiers
Solidity's Modifiers: Modifiers in Solidity are usually used to amend the semantics of functions. Similar to inline in Leo, the body is inlined at each call site.

contract ModifierExample {
    address public owner;
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not the owner");
        _;  // Continue with function execution
    }
    
    modifier validAmount(uint256 amount) {
        require(amount > 0, "Amount must be positive");
        _;
    }
    
    function withdraw(uint256 amount) public onlyOwner validAmount(amount) {
        // Function body executes after modifiers
        payable(msg.sender).transfer(amount);
    }
}


Leo's Approach: Leo doesn't have modifiers, but similar functionality can be achieved using inline functions:

program modifier_example.aleo {
    // Inline functions provide similar behavior to modifiers
    inline only_owner(caller: address, owner: address) {
        assert_eq(caller, owner);
    }
    
    inline valid_amount(amount: u64) {
        assert(amount > 0u64);
    }
    
    transition withdraw(amount: u64, owner: address) -> u64 {
        // Inline functions are called explicitly (like modifiers)
        only_owner(self.caller, owner);
        valid_amount(amount);
        
        // Function logic continues
        return amount;
    }
}


Async Functions
Leo introduces async functions for on-chain execution:

program defi_example.aleo {
    mapping user_balances: address => u64;
    
    // Async transition: can call async functions
    async transition deposit_and_update(public amount: u64) -> Future {
        // Off-chain computation
        let new_record: Token = Token {
            owner: self.caller,
            amount: amount,
        };
        
        // Return future for on-chain execution
        return finish_deposit(self.caller, amount);
    }
    
    // Async function: executes on-chain, can access mappings
    async function finish_deposit(user: address, amount: u64) {
        let current_balance: u64 = user_balances.get_or_use(user, 0u64);
        user_balances.set(user, current_balance + amount);
    }
}


Key Concepts:

Async Pattern: Leo introduces async transitions and async functions for on-chain execution - transitions that call async functions must be declared as async transition
Future Objects: Async functions return Future objects that execute on-chain at a later point in time, allowing access to mapping values that regular transitions cannot access
Call Restrictions
Leo enforces strict rules about function call hierarchy:

Call Flow: transition ‚Üí function ‚Üí inline | transition ‚Üí inline | transition ‚Üí external_transition

Call Flow Rules:

A transition can only call a function, inline, or external transition.
A function can only call an inline.
An inline can only call another inline.
Direct/indirect recursive calls are not allowed.
Recursion: While Solidity allows function recursion (functions calling themselves directly or indirectly), Leo prohibits all forms of recursive calls.

program call_hierarchy.aleo {
    // Transition can call: function, inline, external transitions
    transition main_entry(input: u32) -> u32 {
        let result1: u32 = helper_function(input);      // Valid
        let result2: u32 = inline_helper(input);        // Valid
        let result3: u32 = external_program.aleo/some_transition(input); // Valid
        return result1 + result2 + result3;
    }
    
    // Function can call: inline only
    function helper_function(input: u32) -> u32 {
        let processed: u32 = inline_helper(input);      // Valid
        // let invalid: u32 = another_function(input);  // Invalid
        return processed;
    }
    
    // Inline can call: other inline only
    inline inline_helper(input: u32) -> u32 {
        let doubled: u32 = inline_doubler(input);       // Valid
        return doubled;
    }
    
    inline inline_doubler(input: u32) -> u32 {
        return input * 2u32;
    }
}


Fallback and Receive Functions
Solidity's Fallback and Receive:

contract FallbackExample {
    // Fallback function - called when no other function matches
    fallback() external {
        // Handle unmatched function calls
    }
    
    // Receive function - called when receiving ETH
    receive() external payable {
        // Handle incoming ETH
    }
    
    // Regular function
    function regularFunction() public {
        // Function implementation
    }
}


Leo's Approach: Leo does not have fallback or receive functions:

program fallback_example.aleo {
    // No fallback function - all calls must match a valid function signature
    transition regular_function() {
        // Function implementation
    }
    
    // To receive Aleo Credits, use credits.aleo program
    async transition receive_credits(public amount: u64) -> Future {
        return credits.aleo/transfer_public(self.caller, self.address, amount);
    }
}


Key Differences:

No Fallback: Leo requires all function calls to match a valid function signature
No Receive: Programs don't need special functions to receive Aleo Credits
Program Addresses: Each Leo program has a unique address (same as user-controlled addresses)
Private Records: Programs cannot spend private records sent to them (records are effectively "burnt")
Credit Transfers: Use credits.aleo program's transfer functions to send/receive credits
Cryptography & Built-ins
Hash Functions
While Solidity provides basic hash functions, Leo offers an extensive cryptographic toolkit:

Solidity's Limited Options:

function hashData(bytes memory data) public pure returns (bytes32) {
    return keccak256(data);           // Most common
    // sha256(data);                  // Also available
    // ripemd160(data);               // Less common
}


Leo's Extensive Options:

transition hash_examples(data: u32) -> (field, field, field) {
    // Poseidon hashes (ZK-friendly)
    let poseidon_hash: field = Poseidon4::hash_to_field(data);
    
    // BHP hashes
    let bhp_hash: field = BHP256::hash_to_field(data);
    
    // Traditional hashes
    let keccak_hash: field = Keccak256::hash_to_field(data);
    let sha3_hash: field = SHA3_256::hash_to_field(data);
    
    return (poseidon_hash, bhp_hash, keccak_hash);
}

// Commitment schemes
transition commit_example(value: u32, randomness: field) -> (field, field) {
    let pedersen_commit: field = Pedersen64::commit_to_field(value, randomness);
    let bhp_commit: field = BHP256::commit_to_field(value, randomness);
    return (pedersen_commit, bhp_commit);
}


Random Numbers
Solidity has no built-in randomness and must rely on 3rd party solutions like Chainlink VRF or external oracles.

Leo's Built-in Solution:

async transition secure_random() -> Future {
    return finalize_random();
}

async function finalize_random() {
    // Supports ChaCha random - only available in async functions
    let random_value: u32 = ChaCha::rand_u32();
}


Built-in Properties and Global Variables
Solidity's Extensive Built-ins:

contract GlobalAccess {
    function getBlockInfo() public view returns (uint256, uint256, address, uint256) {
        return (
            block.number,        // Current block number
            block.timestamp,     // Current block timestamp
            msg.sender,          // Immediate caller
            tx.origin           // Transaction originator
        );
    }
    
    function getNetworkInfo() public view returns (uint256, uint256) {
        return (
            block.chainid,       // Current chain ID
            gasleft()           // Remaining gas
        );
    }
}


Leo's Limited Built-ins:

program global_access.aleo {
    async transition get_block_info() -> Future {
        return finalize_get_info();
    }
    
    async function finalize_get_info() {
        // Available within finalize scope only
        let current_height: u32 = block.height;      // Equivalent to block.number
        let current_timestamp: i64 = block.timestamp; // Equivalent to block.timestamp
        let network: u32 = network.id;               // Equivalent to block.chainid
    }
    
    transition get_caller_info() {
        let immediate_caller: address = self.caller;  // Equivalent to msg.sender  
        let origin_caller: address = self.signer;     // Equivalent to tx.origin
        let program_address: address = self.address;  // Equivalent to address(this)
    }
}


Key Differences:

Limited Scope: Leo's block properties only available in async functions (finalize scope)
Timestamp Available: Leo provides block.timestamp which returns the unix timestamp as i64
No Gas Tracking: Leo doesn't expose gas/fee information to programs
Program Context: Leo provides self.address for the current program address
Currency Denominations
Solidity's Ether Units:

contract EtherUnits {
    function demonstrateUnits() public pure returns (uint256, uint256, uint256) {
        uint256 oneWei = 1;
        uint256 oneGwei = 1 gwei;       // 1e9 wei
        uint256 oneEther = 1 ether;     // 1e18 wei
        
        return (oneWei, oneGwei, oneEther);
    }
}


Leo's Credit Units:

program credit_units.aleo {
    transition demonstrate_units() -> (u64, u64, u64) {
        let one_microcredit: u64 = 1u64;
        let one_millicredit: u64 = 1000u64;     // 1e3 microcredits
        let one_credit: u64 = 1000000u64;       // 1e6 microcredits
        
        return (one_microcredit, one_millicredit, one_credit);
    }
}


Key Differences:

Aleo Credits: microcredits (base), millicredits (1e3), credits (1e6)
Ethereum: wei (base), gwei (1e9), ether (1e18)
No Built-in Units: Leo doesn't have built-in unit literals like Solidity
Address Functionality and Native Token Transfers
Solidity's Address Members: Address in Solidity has members to access its associated states such as:

contract AddressExample {
    function demonstrateAddressMembers(address payable target) public view returns (uint256, bytes32) {
        // Access address properties
        uint256 balance = target.balance;           // Balance in Wei
        bytes memory code = target.code;            // Code at address (can be empty) 
        bytes32 codeHash = target.codehash;         // The codehash of the address
        
        return (balance, codeHash);
    }
    
    function transferMethods(address payable target, uint256 amount) public {
        // Different transfer methods
        target.transfer(amount);                    // Reverts on failure, 2300 gas stipend
        bool success = target.send(amount);         // Returns false on failure, 2300 gas stipend
        
        // Low-level calls with adjustable gas
        (bool callSuccess, bytes memory data) = target.call{value: amount}("");
        (bool delegateSuccess, bytes memory delegateData) = target.delegatecall("");
        (bool staticSuccess, bytes memory staticData) = target.staticcall("");
    }
}


Leo's Approach: Leo address does not have member functions. Aleo credits are defined as a program (credits.aleo) on Aleo, therefore to make transfers and access balances, it uses the same method as querying any programs on Aleo, either publicly with mappings or privately by scanning owned records.

import credits.aleo;

program address_example.aleo {
    // Access balance through credits.aleo program mappings (public balance)
    async transition get_public_balance(user: address) -> Future {
        return finalize_get_balance(user);
    }
    
    async function finalize_get_balance(user: address) {
        // Query public balance from credits.aleo account mapping
        let balance: u64 = credits.aleo/account.get_or_use(user, 0u64);
    }
    
    // Transfer credits using credits.aleo program functions
    async transition transfer_public_credits(
        to: address, 
        amount: u64
    ) -> Future {
        return credits.aleo/transfer_public(self.caller, to, amount);
    }
    
    transition transfer_private_credits(
        input: credits.aleo/credits,
        to: address,
        amount: u64
    ) -> (credits.aleo/credits, credits.aleo/credits) {
        return credits.aleo/transfer_private(input, to, amount);
    }
}


Key Differences:

No Address Members: Leo addresses don't have .balance, .code, .codehash properties
No Built-in Transfer Methods: No .transfer(), .send(), .call() methods on addresses
Program-Based Transfers: Native token transfers go through the credits.aleo program
Public vs Private: Balances can be public (mappings) or private (records)
Unified Interface: All program interactions use the same call syntax, whether for tokens or other functionality
Mathematical Operations and Overflow Handling
Solidity's Approach:

contract MathOperations {
    function checkedMath(uint256 a, uint256 b) public pure returns (uint256) {
        return a + b;  // Reverts on overflow by default (since 0.8.0)
    }
    
    function uncheckedMath(uint256 a, uint256 b) public pure returns (uint256) {
        unchecked {
            return a + b;  // Wraps on overflow
        }
    }
    
    function modularMath(uint256 a, uint256 b, uint256 n) public pure returns (uint256, uint256) {
        return (addmod(a, b, n), mulmod(a, b, n));
    }
}


Leo's Approach:

program math_operations.aleo {
    transition checked_math(a: u64, b: u64) -> u64 {
        return a + b;  // Reverts on overflow by default
    }
    
    transition wrapped_math(a: u64, b: u64) -> u64 {
        return a.add_wrap(b);  // Wraps on overflow using wrapped arithmetic
    }
    
    transition modular_math(a: u64, b: u64, n: u64) -> (u64, u64) {
        let add_result: u64 = (a + b) % n;
        let mul_result: u64 = (a * b) % n;
        return (add_result, mul_result);
    }
}


Key Differences:

Wrapped Operations: Leo uses .add_wrap(), .sub_wrap(), .mul_wrap() instead of unchecked blocks
No Built-in Modular Math: Leo doesn't have addmod/mulmod built-ins
Explicit Operators: Leo requires explicit use of wrapped operators
Time and Temporal Operations
Solidity's Time Support:

contract TimeOperations {
    function timeUnits() public pure returns (uint256, uint256, uint256) {
        return (
            1 seconds,    // 1
            1 minutes,    // 60 seconds
            1 hours       // 3600 seconds
        );
    }
    
    function getCurrentTime() public view returns (uint256) {
        return block.timestamp;
    }
}


Leo's Limitation: Leo does not support time units and timestamps (at the moment):

No Time Units: No equivalent to seconds, minutes, hours, etc.
No Timestamps: No access to block timestamps at the moment until ARC-0040 is implemented.
No Time-based Logic: Developers must implement time logic externally or rely on block height
Error Handling
Solidity's Error Handling:

contract ErrorHandling {
    ExternalContract public externalContract;
    error InsufficientBalance(uint256 requested, uint256 available);
    
    function transfer(uint256 amount) public {
        require(amount > 0, "Amount must be positive");
        
        if (balance < amount) {
            revert InsufficientBalance(amount, balance);
        }
        
        try externalContract.riskyCall() returns (string memory) {
            // Success path
        } catch Error(string memory reason) {
            // Handle with reason
        } catch {
            // Handle without reason
        }
    }
}


Leo's Error Handling:

program error_handling.aleo {
    transition transfer(amount: u64, balance: u64) -> u64 {
        // Simple assertions (no custom messages due to lack of string support)
        assert(amount > 0u64);
        assert_neq(amount, 0u64);      // Alternative syntax
        assert(balance >= amount);
        
        // No try/catch - all external calls must succeed
        let result: u64 = external_program.aleo/safe_operation(amount);
        return result;
    }
}


Loops & Conditionals
Solidity's Control Flow:

function controlFlow(uint256[] memory items) public pure returns (uint256) {
    uint256 sum = 0;
    
    // While loops
    uint256 i = 0;
    while (i < items.length) {
        if (items[i] > 10) {
            continue;  // Skip this item
        }
        
        sum += items[i];
        
        if (sum > 100) {
            break;     // Exit early
        }
        
        i++;
    }
    
    // For loops
    for (uint256 j = 0; j < items.length; j++) {
        // Process items
    }
    
    return sum;
}


Leo's Control Flow:

transition control_flow(items: [u32; 5]) -> u32 {
    let sum: u32 = 0u32;
    
    // For loops only (no while, do-while)
    for i: u32 in 0u32..5u32 {
        sum += items[i as u8];
        // No continue and break statement available
    }
    
    // Ternary operator works identically
    let result: u32 = sum > 100u32 ? 100u32 : sum;
    return result;
}

Important Limitation: Leo currently executes all branches of conditional statements, then select the correct result. This differs from typical conditional execution where only one branch runs. This behavior can cause unexpected issues, especially with operations that can halt (like division by zero). ARC-0004 proposes flagged operations to address this limitation, enabling proper if-then-else semantics.

Cross-Program Calls
Solidity's Dynamic Approach:

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
}

contract DynamicCalls {
    function transferTokens(address tokenAddress, address to, uint256 amount) public {
        // Dynamic contract interaction using interface
        IERC20 token = IERC20(tokenAddress);
        bool success = token.transfer(to, amount);
        require(success, "Transfer failed");
        
        // Low-level calls
        (bool callSuccess, bytes memory data) = tokenAddress.call(
            abi.encodeWithSignature("transfer(address,uint256)", to, amount)
        );
        require(callSuccess, "Call failed");
    }
}


Leo's Static Approach:

import credits.aleo;

program static_calls.aleo {
    async transition transfer_credits(
        input: credits.aleo/credits, 
        to: address, 
        amount: u64
    ) -> (credits.aleo/credits, Future) {
        // Static, compile-time known calls only
        let tuple: (credits.aleo/credits, Future) = credits.aleo/transfer_private(
            input,
            to,
            amount
        );
        
        return (tuple.0, f_transfer(tuple.1));
    }

    async function f_transfer(f: Future) {
        f.await();
    }
    
    // Can query public state from other programs within finalize scope
    async transition get_external_balance(user: address) -> Future {
        return f_get_external_balance(user);
    }

    async function f_get_external_balance(user: address) {
        let balance: u64 = credits.aleo/account.get(user);
    }
}


Inheritance
Solidity's Inheritance System:

abstract contract Animal {
    string public name;
    
    constructor(string memory _name) {
        name = _name;
    }
    
    function speak() public virtual returns (string memory);
}

contract Dog is Animal {
    constructor(string memory _name) Animal(_name) {}
    
    function speak() public pure override returns (string memory) {
        return "Woof!";
    }
    
    function wagTail() public pure returns (string memory) {
        return "Wagging tail";
    }
}

contract Cat is Animal {
    constructor(string memory _name) Animal(_name) {}
    
    function speak() public pure override returns (string memory) {
        return "Meow!";
    }
    
    function purr() public pure returns (string memory) {
        return "Purring";
    }
}


Leo's Composition Approach:

Leo does not support inheritance like Solidity does. Instead, Leo uses composition and program imports to achieve similar functionality.

program animal_behaviors.aleo {
    struct AnimalData {
        name: field,
        species: u8, // 1 for dog, 2 for cat
    }
    
    function speak(animal: AnimalData) -> field {
        // Different sounds for different species
        return animal.species == 1u8 ? 100field : 200field; // Dog: "Woof!", Cat: "Meow!"
    }
    
    function species_behavior(animal: AnimalData) -> bool {
        // Dogs wag tail, cats purr
        return animal.species == 1u8 ? true : false; // Dog: wag tail, Cat: purr
    }
}


import animal_behaviors.aleo;

program my_pets.aleo {
    // Struct from imported program must be redefined with exact members
    struct AnimalData {
        name: field,
        species: u8,
    }
    
    record Pet {
        data: AnimalData,
    }
    
    transition create_dog(name: field) -> Pet {
        return Pet {
            data: AnimalData {
                name: name,
                species: 1u8, // Dog
            },
        };
    }
    
    transition create_cat(name: field) -> Pet {
        return Pet {
            data: AnimalData {
                name: name,
                species: 2u8, // Cat
            },
        };
    }
    
    transition make_sound(pet: Pet) -> field {
        // Get sound from animal_behaviors
        return animal_behaviors.aleo/speak(pet.data);
    }
    
    transition check_behavior(pet: Pet) -> bool {
        // Check species-specific behavior
        return animal_behaviors.aleo/species_behavior(pet.data);
    }
}


Abstract Contracts and Interfaces
Solidity's Abstract Types:

// Abstract contract - some functions not implemented
abstract contract Animal {
    string public name;
    
    constructor(string memory _name) {
        name = _name;
    }
    
    function speak() public virtual returns (string memory);  // Must be implemented
    
    function eat() public pure returns (string memory) {
        return "Eating...";  // Default implementation
    }
}

// Interface - no functions implemented
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    // All functions must be external
}

contract Token is IERC20 {
    function totalSupply() external pure override returns (uint256) {
        return 1000000;
    }
    
    function transfer(address to, uint256 amount) external pure override returns (bool) {
        return true;
    }
}


Leo's Approach: Leo does not support abstract contracts or interfaces since it lacks inheritance:

No Abstract Contracts: Cannot define partially implemented contracts
No Interfaces: Cannot define contract interfaces for implementation
Alternative: Use composition and program imports for modularity
Future Consideration: Interfaces may be supported once dynamic dispatch is implemented
Libraries
Solidity's Libraries:

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }
}

contract UsingLibrary {
    using SafeMath for uint256;
    
    function calculate(uint256 a, uint256 b) public pure returns (uint256) {
        return a.add(b);  // Library function attached to type
    }
}


Leo's Alternative: Leo doesn't have dedicated libraries but developers can create stateless programs that function similarly:

// math_library.aleo - Stateless program acting as library
program math_library.aleo {
    transition safe_add(a: u64, b: u64) -> u64 {
        let result: u64 = a + b;
        assert(result >= a);  // Check for overflow
        return result;
    }
}


import math_library.aleo;

program using_library.aleo {
    transition calculate(a: u64, b: u64) -> u64 {
        return math_library.aleo/safe_add(a, b);
    }
}

Key Differences:

No Delegatecall: Leo doesn't support executing external code in current context
No Type Attachment: Cannot attach functions to types like Solidity's using directive
Stateless Programs: Use separate programs instead of libraries
Events and Logging
Solidity's Event System:

contract EventExample {
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Debug(string message, uint256 value);
    
    function transfer(address to, uint256 amount) public {
        // Emit events for external monitoring
        emit Transfer(msg.sender, to, amount);
        emit Debug("Transfer executed", amount);
    }
}


Leo's Limitation: Leo does not support events or logging:

No Events: Cannot emit events for external monitoring
No Logging: No built-in logging facilities
Alternative: Use program outputs or external state tracking for monitoring
Best Practice: Document important state changes in comments
ABI Encoding and Decoding
Solidity's ABI Functions:

contract ABIExample {
    function encodeData(uint256 value, string memory text) public pure returns (bytes memory) {
        return abi.encode(value, text);
    }
    
    function encodePacked(uint256 a, uint256 b) public pure returns (bytes memory) {
        return abi.encodePacked(a, b);
    }
    
    function decodeData(bytes memory data) public pure returns (uint256, string memory) {
        return abi.decode(data, (uint256, string));
    }
}


Leo's Limitation: Leo does not have ABI encoding/decoding functionality:

No Bytes Type: Leo doesn't support bytes type needed for ABI operations
No Dynamic Encoding: Cannot dynamically encode/decode complex data structures
Alternative: Use fixed-size data structures and manual serialization if needed
Static Calls: All cross-program calls use statically defined interfaces
Contract Creation and Dynamic Deployment
Solidity's Contract Creation:

contract Factory {
    function createContract(uint256 initialValue) public returns (address) {
        // Create new contract with constructor parameters
        MyContract newContract = new MyContract(initialValue);
        return address(newContract);
    }
    
    function createWithSalt(uint256 initialValue, bytes32 salt) public returns (address) {
        // Create deterministic address using CREATE2
        MyContract newContract = new MyContract{salt: salt}(initialValue);
        return address(newContract);
    }
}


Leo's Limitation: Leo programs cannot create new programs:

No Dynamic Creation: Programs cannot deploy other programs
Static Deployment: All programs must be deployed through external tools
No CREATE2: No deterministic address generation but programs on Aleo already have developer-defined human-readable names.
Fixed Architecture: Program relationships must be established at deployment time
info
CREATE2 is a special opcode in Solidity to compute the address of creating contract deterministically, please refer to the Solidity docs for more information.

Scoping Rules
Solidity and Leo Similarities: Both languages follow similar scoping rules:

// Solidity
contract ScopeExample {
    uint256 globalVar = 100;
    
    function scopeDemo() public view returns (uint256) {
        uint256 localVar = 200;
        {
            uint256 blockVar = 300;
            return globalVar + localVar + blockVar;  // All accessible
        }
        // blockVar not accessible here
        return globalVar + localVar;
    }
}


// Leo
program scope_example.aleo {
    transition scope_demo() -> u32 {
        let local_var: u32 = 200u32;
        
        {
            let block_var: u32 = 300u32;
            local_var = local_var + block_var;  // Both accessible
        }
        
        // block_var not accessible here
        return local_var;
    }
}


Key Similarity:

Variables are visible from declaration until the end of their containing {} block
Inline Assembly
Solidity's Inline Assembly:

contract AssemblyExample {
    function efficientHash(uint256 a, uint256 b) public pure returns (uint256 result) {
        assembly {
            let hash := keccak256(add(a, b), 0x40)
            result := hash
        }
    }
}


Leo's Limitation: Leo does not support inline assembly:

No Yul-like Integration: Cannot insert low-level assembly code
Separate IR: Aleo Instructions exist as a separate language, not embeddable in Leo.
Standalone Programs: Aleo Instructions can be written as standalone programs in .aleo files, enabling fine-grained control over program execution and circuit design at a low level. For more details about Aleo Instructions, see the Aleo Instructions Overview.


Token Standard Differences
Introduction
The Token Registry Program (ARC-21) serves as the standard "hub" that all tokens and DeFi programs interface with, providing interoperability between new tokens and DeFi programs without requiring program re-deployment. This approach was chosen because on Aleo, all imported programs must be known and deployed before the importing program, and dynamic cross-program calls are not currently supported, which makes composability difficult to implement. However, dynamic dispatch is currently in development and will enable more flexible program interactions in the future.

Quick-glance Comparison
Feature	ERC-20	ARC-21 Token Registry
Token Creation	Deploy new contract	Register with registry
State Management	Per contract	Centralized registry
Transfer Mechanism	Direct contract call	Registry program call
Privacy	None	Built-in private transfers
Approval Flow	Required	Optional
Token Metadata	In contract	In registry
Supply Management	Per contract	Centralized registry
Architectural Differences
Program Structure
ERC-20

Each token is deployed as a separate smart contract
Requires approval flow for token transfers
New smart contract deployment needed for each token
ARC-21 Token Registry

Single program (Token Registry) manages all tokens
No separate approval flow needed for basic transfers
New tokens are created through registration, not deployment
State Management
ERC-20

State is stored within each token contract
Direct state access within the contract
Only supports public visibility for all states
ARC-21 Token Registry

State is managed through the registry program
State access through API endpoints or mappings::get() calls within async functions
Supports both public state visibility with mappings and private state with records
Functional Differences
Token Creation
ERC-20

contract MyToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(msg.sender, 1000000 * 10 ** decimals());
    }
}


ARC-21 Token Registry

// Register a new token
register_token(
    token_id: field,
    name: u128,
    symbol: u128,
    decimals: u8,
    max_supply: u128,
    external_authorization_required: bool,
    external_authorization_party: address
)

External Authorization
The ARC-21 Token Registry supports an optional external authorization system where a designated party (usually a program) can control token spending permissions with time-limited approvals. This feature enforces extra requirements on tokens before they can be transferred, such as time-locked tokens, tokens with vesting schedules or spending limits, compliance requirements, and more. The authorization party can be updated later using update_token_management.

prehook_public and prehook_private are both functions that the external_authorization_party can use to unlock token transfers once the extra requirements have been fulfilled.

Token Transfer
ERC-20

function transfer(address to, uint256 amount) public returns (bool)
function transferFrom(address from, address to, uint256 amount) public returns (bool)


ARC-21 Token Registry

// Public transfer from function caller
async transition transfer_public(
    public token_id: field,
    public recipient: address,
    public amount: u128
) -> Future

// Public transfer from transaction signer
async transition transfer_public_as_signer(
    public token_id: field,
    public recipient: address,
    public amount: u128
) -> Future

// Private transfer
async transition transfer_private(
    recipient: address,
    amount: u128,
    input_record: Token
) -> (Token, Token, Future)

// Public transfer by an approved spender
async transition transfer_from_public(
    public token_id: field,
    public owner: address,
    public recipient: address,
    public amount: u128
) -> Future

// Convert public balance to private Token
async transition transfer_public_to_private(
    public token_id: field,
    recipient: address,
    public amount: u128,
    public external_authorization_required: bool
) -> (Token, Future)

// Convert public balance to private Token by an approved spender
async transition transfer_from_public_to_private(
    public token_id: field,
    public owner: address,
    recipient: address,
    public amount: u128,
    public external_authorization_required: bool
) -> (Token, Future)

// Conver private Token to public balance
async transition transfer_private_to_public(
    public recipient: address,
    public amount: u128,
    input_record: Token
) -> (Token, Future)


Privacy Features
The ARC-21 Token Registry provides additional privacy features not available in ERC-20:

Private Transfers: Ability to transfer tokens privately using the transfer_private function
Public to Private Conversion: Convert public tokens to private using transfer_public_to_private
Private to Public Conversion: Convert private tokens to public using transfer_private_to_public
Token Minting
ERC-20

function mint(address to, uint256 amount) public onlyOwner {
    _mint(to, amount);
}


ARC-21 Token Registry

// Public minting
async transition mint_public(
    public token_id: field,
    public recipient: address,
    public amount: u128,
    public authorized_until: u32
) -> Future

// Private minting
async transition mint_private(
    public token_id: field,
    recipient: address,
    public amount: u128,
    public external_authorization_required: bool,
    public authorized_until: u32
) -> (Token, Future)

The ARC-21 Token Registry provides both public and private minting capabilities. Access to minting is controlled through roles that can be assigned using set_role and revoked using remove_role. Only addresses with MINTER_ROLE or SUPPLY_MANAGER_ROLE can mint tokens if not the admin.

Token Burning
ERC-20

function burn(uint256 amount) public {
    _burn(msg.sender, amount);
}

ARC-21 Token Registry

// Public burning
async transition burn_public(
    public token_id: field,
    public owner: address,
    public amount: u128
) -> Future

// Private burning
async transition burn_private(
    input_record: Token,
    public amount: u128
) -> (Token, Future)

The ARC-21 Token Registry supports both public and private burning mechanisms. Similar to minting, burning permissions are managed through roles using set_role and remove_role. Only addresses with BURNER_ROLE or SUPPLY_MANAGER_ROLE can burn tokens if not the admin.

Token Approval
ERC-20

function approve(address spender, uint256 amount) public returns (bool)
function allowance(address owner, address spender) public view returns (uint256)


ARC-21 Token Registry

// Public approval
async transition approve_public(
    public token_id: field,
    public spender: address,
    public amount: u128
) -> Future

// Revoke public unapproval
async transition unapprove_public(
    public token_id: field,
    public spender: address,
    public amount: u128
) -> Future

Balance and Supply Queries
ERC-20

function balanceOf(address account) public view returns (uint256)
function totalSupply() public view returns (uint256)


ARC-21 Token Registry

# Get balance via RPC endpoint
GET /{network}/program/token_registry.aleo/mapping/balances/{token_id}_{account}

# Get total supply via RPC endpoint
GET /{network}/program/token_registry.aleo/mapping/registered_tokens/{token_id}


The ARC-21 Token Registry uses RPC endpoints to query balances and supply by accessing the program's mappings directly. This approach allows for efficient querying of on-chain state without requiring a transaction. The balance is stored in the balances mapping with a composite key of token_id and account, while the supply information is stored in the registered_tokens mapping.

Summary and Future
The ARC-21 Token Registry provides a more centralized and feature-rich approach to token management compared to ERC-20. While ERC-20 requires separate contracts for each token, the Token Registry manages all tokens through a single program, providing additional features like privacy and role-based access control. This design choice makes it easier to implement DeFi applications and ensures better interoperability between different tokens on the Aleo blockchain.

With the future implementation of dynamic dispatch, the ARC-20 standard will provide a more familiar approach for Ethereum developers, allowing different individual token programs to be called at runtime rather than being strictly defined.


NFT Standard Differences
Introduction
ERC-721 is the standard for non-fungible tokens on Ethereum, but every piece of state (owner, metadata, price) is public.

ARC-721, the Aleo variant implemented in Leo, maintains the same ergonomics while allowing you to choose which parts remain private and which are stored on-chain. The standard originated from the ARC-721 proposal and was officially approved through community voting on Aleo Governance. The standard leverages Aleo's unique privacy features to provide enhanced functionality compared to ERC-721. For example, every NFT in ARC-721 has two separate privacy controls: one for ownership and one for the NFT data itself, with configurable privacy settings for both. For more detailed information about the NFT standards and implementation details, please refer to the NFT Standards documentation.

To address program composability challenges on Aleo, there is a proposed NFT Registry Program (ARC-722) that would serve as a central hub for NFT collections, similar to how the Token Registry Program works for fungible tokens. This registry would allow multiple implementations with different data structures, identified by the unique pair (registry_program_id, collection_id). Note that ARC-722 is currently in the proposal stage and has not yet been voted on or approved by the Aleo community.

Quick-glance Comparison
Function	ERC-721 (Ethereum)	ARC-721 (Aleo)
Owner visibility	Always public	Optional ‚Äî private record or public mapping
Metadata visibility	Whatever you publish is visible	Private, public or hybrid (mixed on-/off-chain)
Unique identifier	Incremental tokenId uint256	Commitment field = hash(data) ‚äï edition (opaque)
Transfer functions	transferFrom, safeTransferFrom	transfer_private, transfer_private_to_public, transfer_public_as_signer, transfer_public_to_private
Approvals	approve, setApprovalForAll	approve_public, set_for_all_approval
Burn & re-mint privately	Not possible without trace	update_edition_private re-obfuscates commit
Architectural Differences
State Management
ERC-721

contract ERC721 {
    // Token name
    string private _name;

    // Token symbol
    string private _symbol;

    // Mapping from token ID to owner address
    mapping(uint256 => address) private _owners;

    // Mapping owner address to token count
    mapping(address => uint256) private _balances;

    // Mapping from token ID to approved address
    mapping(uint256 => address) private _tokenApprovals;
}


ARC-721

Below is the example data structure of an ARC-721 NFT program, using record as private storage and mappings as public storage. Name of the structs don't necessarily have to match data and attribute, allowing to import several NFT collection program without shadowing:

record NFT {
    private owner: address,   // hidden unless revealed
    private data: data,      // on-chain struct (can mirror off-chain JSON)
    private edition: scalar,  // as obfuscator to store NFT commitment on-chain
}

// NFT data is always private and store in NFTView even if ownership is made public
// is_view is always true, to differentiate NFTView from NFT in plaintext representations of records
record NFTView {
    private owner: address,
    private data: data,
    private edition: scalar,
    public is_view: bool
}

// Example attribute, optional
struct attribute {
    trait_type: [field; 4],
    _value: [field; 4],
}

struct data {
    metadata: [field; 4], // URI of offchain metadata JSON
    // (optional) name: [field; 4],
    // (optional) image: [field; 16],
    // (optional) attributes: [attribute; 4],
    // (optional) ...
}

// On-chain NFT data storage if made public 
struct nft_content {
    data: data,
    edition: scalar
}
mapping nft_contents: field => nft_content; // commit(data, edition) => (data, edition)

// Approval data structure
struct Approval {
    collection_id: field,
    approver: address,
    spender: address,
}
mapping for_all_approvals: field => bool     // approval hash ‚Üí bool
mapping nft_approvals:     field => field    // commit ‚Üí approval hash


String Management
Since Leo doesn't have a native string type, strings are managed using arrays of field elements:

// Example attribute, optional
struct attribute {
    trait_type: [field; 4],
    _value: [field; 4],
}

struct data {
    metadata: [field; 4], // URI of offchain metadata JSON
    // (optional) name: [field; 4],
    // (optional) image: [field; 16],
    // (optional) attributes: [attribute; 4],
    // (optional) ...
}


Key points about string management in Leo:

The array length can be adjusted based on the maximum number of characters needed
Fields are used instead of u128 because they offer approximately twice the amount of data for the same constraints
This approach is particularly useful for storing metadata URIs and other string data in NFTs
For JavaScript/TypeScript applications, an example utility is available in the ARC-721 implementation to convert between JavaScript strings and Aleo plaintexts
NFT Identifier
ERC-721

In ERC-721, NFTs are identified by a simple incremental uint256 tokenId.

ARC-721

NFT commit is used to identify each unique NFT in ARC-721:

mapping nft_commits: field => bool; // NFT commit => NFT exists or has existed

inline commit_nft(
    nft_data: data,
    nft_edition: scalar
) -> field {
    let data_hash: field = BHP256::hash_to_field(nft_data);
    let commitment: field = BHP256::commit_to_field(data_hash, nft_edition);
    return commitment;
}


NFT Creation and Structure
ERC-721

ERC-721 provides a standard minting function with optional extensions for custom capabilities.

contract MyNFT is ERC721 {
    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}
    
    function mint(address to, uint256 tokenId) public {
        _mint(to, tokenId);
    }
}


ARC-721

ARC-721 provides flexibility in defining custom NFT creation logic as the NFT program is deployed by developers. The standard implementation includes functions for minting NFTs with different privacy settings:

// Mints a private NFT
// Returns the NFT record that representing ownership and contains NFT data.
async transition mint_private(
    admin_nft: nft_records.aleo/NFT,
    private recipient: address,
    private nft_data: Data,
    private nft_edition: scalar,
) -> (nft_records.aleo/NFT, Future) 

// Mints a private NFT, verifying admin rights during finalization publicly.
// Returns the NFT record that representing ownership and contains NFT data.
async transition mint_private_as_public(
    private recipient: address,
    private collection_id: field,
    private nft_data: Data,
    private nft_edition: scalar,
) -> (nft_records.aleo/NFT, Future)

// Mints a public NFT, with private admin as authorization.
// Returns NFTView record that contains private NFT data, ownership is stored publicly on-chain.
async transition mint_public_as_private(
    admin_nft: nft_records.aleo/NFT,
    public recipient: address,
    private nft_data: Data,
    private nft_edition: scalar,
) -> (nft_records.aleo/NFTView, Future)

// Mints a public NFT
// Returns NFTView record that contains private NFT data, ownership is stored publicly on-chain.
async transition mint_public(
    public recipient: address,
    public collection_id: field,
    private nft_data: Data,
    private nft_edition: scalar,
) -> (nft_records.aleo/NFTView, Future)

// Make a NFT data public
async transition publish_nft_content(
    public nft_data: Data,
    public nft_edition: scalar,
) -> Future


Transfer Mechanisms
ERC-721

function transferFrom(address from, address to, uint256 tokenId) public
function safeTransferFrom(address from, address to, uint256 tokenId) public


ARC-721

// Private transfer
transition transfer_private(
    private nft: NFT,
    private to: address,
) -> NFT

// Public transfer from function caller (msg.sender)
async transition transfer_public(
    private nft_data: data,
    private nft_edition: scalar,
    public to: address,
) -> (NFTView, Future)

// Public transfer from transaction signer (tx.origin)
async transition transfer_public_as_signer(
    private collection_id: field,
    private nft_data: Data,
    private nft_edition: scalar,
    public recipient: address,
) -> (NFTView, Future)

// Public transfer by an approved spender
async transition transfer_from_public(
    public from: address,
    public to: address,
    private nft_data: data,
    private nft_edition: scalar,
) -> (NFTView, Future)

// Convert private NFT ownership to public NFT ownership
async transition transfer_private_to_public(
    nft: nft_records.aleo/NFT,
    public recipient: address,
) -> (nft_records.aleo/NFTView, Future)

// Convert public NFT ownership to private NFT ownership
async transition transfer_public_to_private(
    private nft_data: data,
    private nft_edition: scalar,
    private to: address,
) -> (NFT, Future)

// Convert public NFT ownership to private NFT ownership by an approved sender
async transition transfer_from_public_to_private(
    private collection_id: field,
    public from: address,
    public recipient: address,
    private nft_data: Data,
    private nft_edition: scalar,
) -> (NFT, Future)


Transfer flows side by side
Transfer Flow	ERC-721 (Solidity)	ARC-721 (Leo)	Privacy Level
Private ‚Üí Private	‚ùå Not Supported	transfer_private	Fully private ‚Äî no public trace
Private ‚Üí Public	‚ùå Not Supported	transfer_private_to_public	Owner becomes visible; content stay hidden in NFTView
Public ‚Üí Public	transferFrom / safeTransferFrom	transfer_public (via self.caller) transfer_public_as_signer (via self.signer)	Matches ERC-721 behavior with added flexibility
Public ‚Üí Private	‚ùå Not Supported	transfer_public_to_private transfer_from_public_to_private	Ownership becomes private; asset vanishes from public registry
Public (by Spender)	transferFrom with approve()	transfer_from_public transfer_from_public_to_private	Approved delegated transfers, public or private
Approval System
ERC-721

function approve(address to, uint256 tokenId) public
function setApprovalForAll(address operator, bool approved) public


ARC-721

// Collection-wide approval
async transition set_for_all_approval(
    private spender: address,
    public new_value: bool,
) -> Future

// Individual NFT approval
async transition approve_public(
    private spender: address,
    private nft_data: data,
    private nft_edition: scalar,
) -> Future

// Revoke approval
async transition unapprove_public(
    private collection_id: field,
    private nft_data: Data,
    private nft_edition: scalar,
) -> Future

Settings
ARC-721 also recommended standard setting for collection:

mapping general_settings: u8 => field;  // Setting index => Setting value


0u8 - Amount of mintable NFTs (all editions)
1u8 - Number of total NFTs (first-editions) that can be minted
2u8 - Symbol for the NFT
3u8 - Base URI for NFT, part 1
4u8 - Base URI for NFT, part 2
5u8 - Base URI for NFT, part 3
6u8 - Base URI for NFT, part 4
7u8 - Admin address hash
Edition
ARC-721 introduces the edition field as a mandatory scalar inside every NFT record. The reason for using edition is three-fold:

Privacy salt ‚Äì edition is mixed with the BHP256 hash of the NFT's data to form nft_commit = BHP256::commit_to_field(BHP256::hash_to_field(data), edition). This blinding factor prevents brute force attacks that attempt to determine if two commits contain the same underlying data.

Uniqueness anchor ‚Äì Because the commit depends on edition, any change (even when data is identical) produces a brand-new nft_commit, guaranteeing each token is non-fungible.

Re-obfuscation ‚Äì Owners may "rotate" privacy by choosing a fresh random scalar and calling update_edition_private, breaking on-chain linkage to prior transfers.

Publishing (and re-hiding) content
When an NFT's data should become public, the owner calls:

transition publish_nft_content(nft_data, nft_edition)

which copies the cleartext struct into:

mapping nft_contents: field => nft_content;

If you later need to hide it again:

Bring the NFT private with transfer_public_to_private.
Call update_edition_private to roll the commitment.
Privacy Features
The ARC-721 standard provides several privacy-enhancing features:

Private Ownership

NFTs can be held privately using Aleo records
Ownership can be verified without revealing the owner's identity
Supports conversion between private and public ownership states
Private Data

NFT data is kept private by default
Optional data publication through publish_nft_content
Edition-based Privacy

Each NFT has a unique edition number (scalar)
Editions enable privacy while maintaining uniqueness
Supports edition updates for re-obfuscation
Flexible Visibility

NFTView record type for public ownership with private data
NFT record type for fully private ownership
Built-in conversion functions between states

FAQs
Do applications in Aleo function similarly to ZK rollups?
Differences between Aleo applications and ZK rollups:

Aspect	ZK Rollup	Aleo Application
Information visibility	All information is public	Can make some inputs private, using the zero-knowledge property of zkSNARK
Proof generation	Rollup coordinator generates the proof and submits it in the rollup-transaction	Users generate the proof themselves and submit it as part of the transaction
Batching	Batches multiple transactions	Can batch multiple transitions into the same transaction
zkSNARK usage	Uses the succinct property to prove correct execution of a batch of transactions	Can use rollup-like architecture with added privacy features
Similar to batching multiple transactions in a zk-rollup, Aleo has a way to batch multiple transitions into the same transaction.

How does the network of provers work, including their incentives and the consensus mechanism?
Aleo is SNARK-based and uses the Marlin-proving algorithm to generate program proofs. The cryptography and proof generation are handled by SnarkVM. Aleo program proofs can currently be generated locally by the user or delegated to a third-party prover. These involve tradeoffs between performance and privacy:

tradeoff

Local proof generating is the most trust-minimized solution since it doesn‚Äôt require sharing private inputs with anyone else. However, the performance is limited to your hardware.

For more complex proofs - users can/may delegate to third-party provers with specialized hardware. While outsourcing proof generation leads to better performance, it sacrifices privacy as users need to share some data used in the computation to enable the prover to compute the zero-knowledge proof.

In the Aleo Network, provers use specialized hardware to generate proofs and solve puzzles that help secure the Network. They generate proofs for a given block and earn pro rata portions of the coinbase reward (a subset of the total block reward) based on how many above-target proofs they submit. Talking about the network and reward share among the provers:

Proof difficulties are set by a version of the algorithm created by the Bitcoin Cash team called ASERT. When a proof exceeds the current difficulty limit, a coinbase reward is shared among all provers who contributed. The computational work done by provers includes Multi-Scalar multiplication and fast-Fourier transforms.

How do Aleo Credits work?
Aleo Credits are used in two main ways:

Secure the network: Validators stake Aleo Credits to propose blocks and secure the network, and receive Aleo Credits as a reward for validation. This is standard for PoS blockchains.
Purchase zero-knowledge compute: Applications that need zkSNARK-proving use Aleo credits to pay provers to generate the proofs.
How does Proof of Succint Work (PoSW) operate for provers in Aleo?
Proof of Succinct Work (PoSW) in Aleo is an incentive mechanism designed to drive hardware acceleration for zero‚Äêknowledge proof (ZKP) generation. At its core, PoSW challenges provers with a cryptographic puzzle‚Äîknown as the Coinbase puzzle‚Äîwhich directs them to execute critical computations (such as multi‚Äêscalar multiplications and fast Fourier transforms) that underpin zkSNARK operations. Provers DO NOT produce blocks, but they do earn a portion of the coinbase reward from each block. The coinbase reward is not winner-take-all; all the provers who contribute solutions for a given block above the minimum difficulty target receive a pro-rata portion of the reward.

As the Coinbase puzzle gradually becomes more difficult over time, provers must continuously upgrade their hardware and refine their proving techniques in order to solve increasingly tougher puzzles. This evolving difficulty not only promotes ongoing innovation but also ensures that all participating provers, regardless of whether they are the fastest, receive proportionate rewards per block. In essence, PoSW transforms the proving process into a decentralized, competitive ecosystem akin to a mining pool, where the collective effort drives both performance improvements and cost reductions.

By linking rewards to useful work that directly contributes to the efficiency of ZKP generation, PoSW encourages broad participation and investment in specialized hardware (like ASICs). This alignment of incentives helps maintain a decentralized prover network that is robust, censorship-resistant, and continuously improving‚Äîa key factor in Aleo‚Äôs mission to deliver privacy-first blockchain technology.

How is the record model in Aleo designed, and how does it compare to the account and UTXO models?
Aleo supports both the UTXO like model with Records and account like-models with mapping. In the record model, a decentralized ledger tracks every record via a global state.

We still have users with addresses but instead of running a transaction in an application on a bunch of inputs, we actually execute the transaction locally on a bunch of records and provide these transitions within the transaction with the proof that I have actually executed these records correctly. And in this manner when the network updates the program is no longer a global store of encrypted states, it‚Äôs now an abstraction over records. Essentially splitting up the state in a more proficient manner.

record model

Record model is very similar to the UTXO model (of Bitcoin). The addition on top of the UTXO model is that the content of the UTXO can be as per the program needs and not baked into the protocol level and all the content is encrypted by default.

From the blockchain dilemma triangle perspective, which aspect, if any, did Aleo compromise on?
Aleo doesn‚Äôt compromise on the trilemma and in fact addresses it in totality. This is possible because of Aleo‚Äôs consensus algorithm and ZK Snarks.

Aleo enables Account privacy: The decentralized ledger indexes the global state based on program IDs.

Efficient state updates: Record abstraction: helps you segment/compartmentalize your information from others. Predicates essentially only consume program records being updated.

Concurrency: Simultaneous updates to the program states are achieved through records and the ledger ensures that the program records are not double spent. If we look at the records, we have a Merkle tree of all these leaves, leaves are usually entries. How‚Äôs concurrency achieved? Because we can have the network effectively take all these record updates, and then in one go, update a Merkle tree with everybody's deltas, everybody's diffs, and then subsequently linearize that and patch up to a Merkle group and put that into the block header. And so this fundamentally gives us the ability to get back the feature that we had in the previous account model now in this record model, but with concurrency.

How does Aleo prevent double spending, and what are the implications for transaction finality and fees?
Since Aleo supports both the UTXO-model with records and account model with mappings, the double-spending is prevented in different ways:

For UTXO model:

Each record has a serial number and a corresponding commitment. When spending the record, you publicly create an inclusion proof verifying that the record is in a tree of commitments and the serial number is used to verify that the same record has not been used previously. If we try to spend the same record it fails.

Commitments are a cryptographic way to ensure that the information provided is valid and hasn't been tampered with. They allow protecting sensitive information while still enabling verification and trust. Commitments are also essential for implementing smart contracts on Aleo, as they enable the verification of contract conditions and ensure that the contract's execution adheres to the specified rules without exposing the underlying data

Generating a transaction involves creating commitments to new records as well as computing the unique serial number for consumed records. Commitments are part of proof generation at both the transition and transaction level.

For account models:

The account is updated globally in a mapping. So everytime the transfers happen, the amount is subtracted from the sender‚Äôs account and added to the receiver‚Äôs account (similar to Ethereum and other public chains). Since the information is global, you cannot make transfers of the amount that you do not have in your account. For transactions that update the mapping, one still requires the proofs (unlike the signatures for authorization of transfer) and the proof is based on a stateRoot. If there has been an update in the mapping by some prev transaction, the stateRoot changes and the proof will fail.

What is the purpose and functionality of Aleo instructions?
Aleo instructions is the intermediate representation of Aleo programs. All Leo programs compile to Aleo instructions which compile to bytecode. Aleo instructions are compiled into AVM opcodes that can be executed by the Aleo Virtual Machine.

To generate the zero-knowledge proof, arithmetic circuits are used. Developers on the EVM ecosystem write these circuits using Circom, Zokrates which are later used to generate the proving and verifying keys to generate the proofs. Aleo instructions are the way to write these circuits.

If we have a leo program to add two u32 variables:

leo example

The Aleo instructions would look something like this (very similar to assembly language):

ai example

Why was Leo created, and how does it differ from other smart contract languages like Solidity?
To generate the zero-knowledge proof, arithmetic circuits are used. Developers on the EVM ecosystem write these circuits using Circom, Zokrates which are later used to generate the proving and verifying keys to generate the proofs. Writing circuits can be a bit daunting.

So Leo abstracts that away and makes it easier for developers to write their logic in higher level language called Leo (files with .leo extension) instead of Aleo (files with .aleo extension) circuits.

How does Aleo's approach to off-chain computation differ from other solutions like ZK-Coprocessor, and what are the privacy implications of outsourcing proving tasks?
The approach is very similar. Each transition on Aleo can have an additional finalize block. The logic of the transition block is verified with the ZK-proof and the logic in the finalized block is re-executed by all the nodes on the network to update the state stored in the mapping.

In this sense the logic inside transition acts like the computations sent to the ZK-processor which requires a fixed transaction cost (no matter the size of the logic) and the logic inside the finalize block is similar to the on-chain execution of other public blockchains like Ethereum.

Right now, on Aleo, you have the option to delegate proof generation to a remote server. This will speed up proof generation but disclose the transaction details to a trusted server. For some applications and users, this makes sense but for some applications where privacy is of utmost importance, users still have the option to generate the proof themselves.

Private proof delegation would be the holy grail but we aren‚Äôt there (yet).

Learn more about the state of outsourcing proving tasks here.

How does Aleo compare to Bitcoin and Ethereum in terms of its core design and functionality?
aleo advantage

From the above slide from The Aleo advantage perfectly answers the question.

Bitcoin is public money. It is not programmable and all of the user‚Äôs transactions are public.
Ethereum introduced programmability but still didn‚Äôt offer privacy.
Some projects like ZCast offered privacy but didn‚Äôt provide programmability.
Aleo provides both privacy and programmability.

Where can I watch talks and videos?
Coinbase BUIDL - Learning LEO | Coding Private Application with ZK Cryptography
DEVCON - Aleo Developer Workshop: Leo Coding & Examples
DEVCON - What are ZK Proofs Good For? Applications to Anonymous Identity, Sybil Prevention and Moderation
DEVCON - Efficient Private Delegation of zkSNARK Provers
ICC - Web 3.0 for developers in TLV Howard Wu Aleo
ZK8 - Demystifying Zero-Knowledge Programming ‚Äì Howard Wu - Aleo
ETHCC - The Hitchhiker's Guide to ZK: An Aleo Developer Workshop
CoinGecko - Importance of Zero-knowledge Proofs w/ Alex Pruden
Thinking Crypto - Alex Pruden Interview - Aleo's Privacy Solutions - Zero Knowledge Proofs - a16z - Bitcoin & Crypto
The Interop - Zero-Knowledge Smart Contracts with Alex Pruden of Aleo
Axelar - Tech Talks with Aleo
What are the Aleo's social accounts?
üëæ | Discord ~ https://discord.gg/aleo

üê¶ | X (Twitter) ~ @AleoHQ ~ https://twitter.com/AleoHQ

ü§ù | Community X (Twitter) ~ @aleocommunity ~ https://twitter.com/aleocommunity

üêô | GitHub ~ https://github.com/AleoNet

‚úçÔ∏è | Community Blog ~ https://medium.com/@aleohq

Are there more useful resources?
üèéÔ∏è | A curated list of Aleo & Leo code and resources ~ https://github.com/howardwu/awesome-aleo

üìú | A starter guide to build applications on Aleo ~ https://github.com/AleoNet/workshop

How to Get Help
Discord is our primary communication channel with the community. If you have a question that is not covered in this developer documentation, join our Discord and visit the engineering support channels for help. You can also join the community calls, which is open to everyone and hosted on Discord. To find the exact date and time of the calls, please check the Events section in our Discord server. Right now, there are 3 calls:

Developers Calls: Monthly meetings happening on the first and third Monday of each month at 7:30 AM PT - 8:30 AM PT for developers to discuss technical topics and updates.
Community Call: A monthly meeting happening on the last Monday of the month at 8:00 AM PT - 9:00 AM PT for the general community to learn about the latest developments on the Aleo ecosystem.

Welcome
Contribution Guidelines
Welcome to Aleo's Developer Documentation. Committed to open-source principles and decentralization, Aleo actively welcomes and values contributions from the community. All forms of contributions are encouraged, including suggesting new topics and contents, or providing examples to improve clarity and usefulness.

Introduction
Aleo is a fully open-source, decentralized, programmable and privacy-preserving Layer 1 blockchain that allows developers to create applications with built-in privacy features. Using zero-knowledge proofs, programs deployed on Aleo enable sensitive data to be kept confidential while still allowing verification. The platform offers high scalability, making it capable of supporting large-scale applications, and provides an unrestricted runtime environment that removes typical blockchain limitations. This unique combination of privacy, scalability, and flexibility makes Aleo an ideal platform for building the next generation of privacy-focused decentralized applications.

For more details, visit the Concepts section to explore Aleo's architecture and features.

Help improve our ecosystem
Proposing an ARC
Have ideas on development standards or protocol improvements? Follow these steps to propose an Aleo Request for Comments (ARC): To create a new ARC proposal:

Open a Github Discussion with your proposal using template ARC-0000 and an available ARC number.
File a Pull Request with your proposal in a new subdirectory.
To update an existing ARC:

File a pull request with your changes.
If the change is significant, you may be asked to open a new ARC entirely.
Progressing an ARC
An ARC will start as a "Draft" and progress through the following stages:

Once a proposal is up:

The community will discuss and review the proposal. A maintainer will monitor the ARC and change its status to "Active" once it is ready.
ARCs will be prioritized by number of votes and whether a prototype exists.
ARCs will be discussed during certain community calls. Proposers will have the opportunity to join and participate in the discussion.
Up to this point, the ARC can be withdrawn by the proposer or withdrawn by the maintainers if there is no activity for a long time.
A governor or a team member of the Aleo Network Foundation (ANF) will create a formal proposal on Aleo governance (https://vote.aleo.org/) and initiate the voting process.
The community will vote on the proposal for approval.
If the proposal is accepted, its status will be updated to "Accepted" and the associated pull request will be merged into the ARCs repo. If the proposal is rejected, the status will be reverted to "Draft".
The relevant parties should complete the implementation. Updates can be made to the ARC as needed through new PRs, which do not need votes.
Once the implementation is finalized, the status will change from "Accepted" to "Final" or "Living", depending on the nature of the proposal. The associated discussion will be closed.
A proposal can be "Deprecated" if it is replaced by a new proposal.

Statuses
See ARC-0001 for a detailed explanation of the statuses.

Contributing to Aleo
Every component that forms Aleo is open-sourced and welcomes contributions of all kinds including this documentation. Each component has its own specific contribution guidelines, which are provided below for easy reference:

DevDocs - This developer documentation
Leo - Rust-based DSL to write programs on Aleo
Provable SDK - Javascript/Typescript tools for creating zero knowledge apps
Create-leo-app - Scaffolding your first Aleo project
Aleo Instruction - IR that Leo language compiles into
SnarkOS - The operating system or blockchain node client of Aleo
SnarkVM - The virtual machine that performs verifiable computation

DevDocs Contribution
Welcome to the Aleo DevDocs contribution guide! We invite you to help improve our documentation, making it more comprehensive and up-to-date. Your contributions, big or small, are valuable in enhancing the Aleo ecosystem for developers. This guide will walk you through the process of contributing effectively to our documentation.

Providing Feedback
If you've found an issue or have a suggestion for improvement but don't have time to make the changes yourself, you can still contribute by providing feedback through GitHub Issues:

Go to the Issues page of the welcome repository.
Click on "New Issue".
Choose the appropriate issue template if available, or start with a blank issue.
Provide a clear and concise title that summarizes the issue or suggestion.
In the description:
For bugs or errors: Describe what you expected to see and what you actually saw. Include steps to reproduce if applicable.
For improvement suggestions: Explain your idea and how it would enhance the documentation.
If relevant, include screenshots or code snippets to illustrate your point.
Add appropriate labels to your issue (e.g., "documentation", "enhancement", "bug").
Submit the issue.
Your feedback helps us identify areas for improvement and ensures the documentation remains accurate and helpful for all users.

Getting Started
Fork the welcome repository on GitHub.

Clone your forked repository locally:

git clone https://github.com/YOUR-USERNAME/welcome.git


Navigate to the project directory:

cd welcome

Make changes in the documentation directory:

cd documentation

This is where you'll find the content files to edit.

Making Changes
Create a new branch for your changes:
git checkout -b your-feature-branch

Make your changes to the documentation files. Most content is in Markdown format.
Commit your changes with a descriptive commit message:
git commit -am "Add description of your changes"

Submitting Your Contribution
Push your changes to your forked repository:
git push origin your-feature-branch

Go to the welcome repository on GitHub and create a new pull request from your-feature-branch.
Provide a clear title and description for your pull request, explaining the changes you've made.
Submit the pull request for review.
Guidelines
Ensure your writing is clear, concise, and follows the existing style of the documentation.
Use proper Markdown formatting for headings, code blocks, and other elements.
If adding new pages, update the sidebar configuration appropriately.
Include any necessary images or diagrams to illustrate concepts.
Verify all links are correct and working.
Need Help?
If you have any questions or need assistance, please don't hesitate to open an issue in the welcome repository or reach out to the maintainers.

Thank you for contributing to the Aleo documentation!

SnarkOS Contribution
This checklist provides a step-by-step guide for restarting the Aleo network with new features merged. Follow these steps to ensure a smooth process.

Branches Overview
staging branch

This branch serves as a staging area for the integration and initial testing of changes before they are promoted to the mainnet branch.
mainnet branch

The production branch where only stable and thoroughly tested changes are merged. It is used for creating production releases. It is always a direct mirror of a staging commit.
Networks Overview
DevNet(s)
Initial proposed changes are implemented and tested on DevNets.
Snarkops - aims to provide guides and scripts for managing SnarkOS and participating in ANF's CanaryNet.
CanaryNet (running staging branch)
Changes are merged into CanaryNet from DevNet for testing and validation.
CanaryNet is used to onboard additional validators before potentially bonding them to Testnet Beta/Mainnet.
Validators are bonded by the ANF.
snarkOS github tag standard: canary-v*. Link to tags.
Explorer for canary
Testnet Beta (running mainnet branch)
Open, public network for testing applications in a production-like environment without incurring costs.
Validators are bonded by the Aleo Network Foundation.
ANF and Provable initially run the validators.
Demox Labs and Puzzle run public faucets
snarkOS github tag standard: testnet-beta-v* Link to tags.
Explorer for Testnet Beta
Mainnet (running mainnet branch)
The final testing stage before full production deployment.
Intended to be the ‚Äúlast stop‚Äù for new code and/or validator onboarding.
Will run concurrently with Testnet Beta before becoming the canonical Mainnet.
snarkOS github tag standard: mainnet-v* Link to tags.
Explorer for Mainnet
Contribution Workflow [ snarkOS ]
SnarkOS Contribution Diagram

1. Fork the Repository

Fork the repository from the staging branch to your own GitHub account.
Clone your fork locally.
git clone git@github.com:AleoNet/snarkOS.git
git remote add upstream git@github.com:AleoNet/snarkOS.git


2. Switch to the base branch

git switch staging

3. Create a Feature Branch

Create a feature branch from your fork's main branch.
git checkout -b feat/my-branch

4. Develop Your Feature/Fix and Test

Develop your feature or fix in your forked repository.
Run ./snarkOS/devnet.sh
Make sure to approve the option to re-install the snarkOS binary so you test with your current local snarkOS code.
See that the network progresses blocks normally and send some transactions for further confirmation of network stability.
Run any specific tests to your feature/fix.
5. Push your code to Fix branch

Commit changes with meaningful commit messages that clearly describe the changes and their purpose.
Push changes to your fork.
git add .
git commit -m "Add detailed description of the changes"
git push


6. Submit a PR to Your Fork's Main Branch

Submit a pull request (PR) from your feature branch to your fork's main branch.
This triggers the CI pipeline in your fork to run automated tests.
7. Internal Code Review

Request an internal code review from your team within your forked repository.
Team members review the code, suggest changes, and approve the PR if it meets the quality standards.
The CI pipeline is run again to ensure no new issues have been introduced during the review process.
8. Submit a PR to the Main AleoNet/snarkOS Repository

After internal approval, submit a PR from your fork's main branch to the main AleoNet/snarkOS repository's staging branch.
This triggers the main CI pipeline to run all relevant tests and checks again to ensure the code's stability and compatibility.
9. Review by Core Team

Core team members review the PR in the main AleoNet/snarkOS repository.
If the CI pipeline passes and the review is successful, the PR is approved.

SnarkVM Contribution
This guide details the steps required to update snarkVM and propagate these changes to the Aleo network.

Branches Overview
staging branch

This branch acts as a staging environment for integrating and initially testing changes before they are promoted to the mainnet branch.
mainnet branch

This is the production branch where only stable and thoroughly tested changes are merged. It directly mirrors the staging branch after changes are validated. It is used to create production releases.
Implications of a snarkVM Pull Request (PR)
When a new PR is merged into staging for snarkVM, snarkOS must also be updated to reflect the updated snarkVM dependency. This requires a separate PR for snarkOS, ensuring all checks are passed as specified in the snarkOS contribution guide.
In some cases, a snarkVM PR may have a corresponding "sister PR" in snarkOS, necessary for the successful compilation of snarkOS. Always check for the term "sister PR" in the PR README.
Review and Merge Process for snarkVM PRs
1. Review snarkVM PRs:

Carefully review PRs for snarkVM, considering their status and any comments.
2. Run CI on snarkVM PRs:

Execute Continuous Integration (CI) to validate the reviewed PRs.
3. Checkout and Push snarkVM Branch:

Checkout the relevant snarkVM branch and push it to the repository.
4. Merge snarkVM PRs:

Merge the reviewed and approved snarkVM PRs.
Genesis Block and Parameter Re-generation
Re-generate Genesis Block and Parameters:
To determine if parameters need re-generation and uploading, run the scripts located in snarkVM/parameters/scripts/.
After running the scripts, execute git status. If no changes (git diff) are detected, there is no need to upload anything new.
First-Time Parameters CDN Use:
If this is the first time using the parameters CDN, also upload the .usrs files. These files are fixed and won't show any changes in git diff, but they must be present in the parameters CDN.
Resample Genesis Block:
You may need to resample the genesis block using the snarkup tool.
Update snarkOS to Reference the Latest snarkVM Commit
Create a snarkOS PR:
Create a PR for snarkOS that updates the Cargo.toml and Cargo.lock files to point to the latest snarkVM commit hash.
Follow the procedures outlined in the snarkOS contribution guide to ensure proper integration.











