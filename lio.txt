The Leo Programming Language
Leo is an open-source, statically-typed, imperative programming language designed for building private applications on the Aleo blockchain. It abstracts the complexities of zero-knowledge cryptography, enabling developers to create secure, privacy-preserving applications while abstracting technical complexities.

Key Features
Intuitive Syntax. Influenced by languages like JavaScript and Rust, Leo offers a familiar and readable syntax, making it accessible to a wide range of developers.
Seamless Aleo Integration. Specifically designed for the Aleo blockchain, Leo ensures smooth deployment and management of applications within Aleo's zero-knowledge ecosystem.
Robust Tooling. Leo provides a comprehensive suite of tools, including a command-line interface and integrated development environment (IDE) plugins for Visual Studio Code, Sublime Text 3, and IntelliJ, enhancing the developer experience.
Formal Verification. With a formally defined language structure, Leo enables developers to perform formal verification of their programs, ensuring correctness and security in application logic.
Overview
Getting Started. Install, set up your development environment, and get familiar with Leo.

Language. The syntax and semantics.

CLI. Utilities that will help you build, deploy, and execute Leo programs. Includes other helpful utilities.

Testing. The testing ecosystem for Leo programs.

Guides. Deepen your understanding of Leo and Aleo.

Resources. How to get involved with the community and supplemental material.

SDK. Productionize your Leo program.

Provable API. Endpoints to query and interact with mainnet and testnet.

Contributing
Found a bug? Have an idea for a feature? File an issue or PR on the Leo GitHub or the Documentation Source.

What's new on Leo?
tip
ðŸ“¦ Releases - Stay up to date with the latest Leo releases.
ðŸš€ Upgrade Guide - Learn how to upgrade your Leo programs.
ðŸ¤ Core Developers Call - Collaborate with the Leo development team and ecosystem on the future of Leo.
âš›ï¸ Create Leo App - A full stack application written in Typescript using Leo and React.

Where to go?
While a deep dive through the Leo documentation is a useful exercise, we realize that it may not be very practical. To help you along your journey, we've provided a "map" to help you find your way.

Roadmap
If you're brand new to Leo, go to Getting Started and make your way through Hello, Leo.

If you're designing a dApp, we recommend checking out Leo By Example for a reference.

If you're interested in tutorials, check out Guides. Also be sure to check out the Core Aleo Concepts.

If you're deploying or running your programs, CLI will be helpful.

Installation
There are a number of ways to install Leo, depending on your platform and preferences. Take your pick!

If you'd like to try Leo without installing it locally on your machine, check out the Leo Playground.

Cargo
Pre-Built Binaries
Build from Source
Install Cargo
The easiest way to install Cargo is to install the latest stable release of Rust.

Install Leo
cargo install leo-lang

This will generate the executable at ~/.cargo/bin/leo.

Your Development Environment
Developers can choose from a wide variety of development environments.

Leo Playground
Leo Playground is a web-based IDE that is designed to allow developers to develop, deploy, and execute programs all in the browser! It comes with an editor, Github integrations, and a number of utilities to manage programs and interface with the network.

Leo Playground

note
Developers may find the generating transactions is slower in the browser. This is because the underlying algorithms for generating proofs are computationally expensive. We're actively working on making this better!

Plugins
The Leo team also maintains plugin for a number of different edits. If you do not see your favorite editor on this list, please reach out on GitHub.

VS Code
Download the editor here: https://code.visualstudio.com/download.

Install
Install Leo for VSCode from VSCode marketplace.
The correct extension ID is aleohq.leo-extension, and the description should state "the official VSCode extension for Leo".
Usage
Open VSCode.
Go to Settings > Extensions or use the left side panel Extensions button to enable the Leo plugin.
Sublime Text
Download the editor here: https://www.sublimetext.com/download. Aleo instructions support for Sublime's LSP plugin is provided through a language-server.

Install
Install LSP and LSP-leo from Package Control.
Restart Sublime.
Usage
Follow these steps to toggle the Leo syntax highlighting, hover, and tokens.

Open Sublime Text.
From Settings > Select Color Scheme... > LSP-leo
Intellij
Download the editor here: https://www.jetbrains.com/idea/download/.

Install
Install and enable the Leo plugin in your IDE.


Hello, Leo
Initialize the project
Use the Leo Command Line Interface (CLI) to create a new project. In your terminal, run:

leo new hello
cd hello

This creates a directory with the following structure:

hello/
â”œâ”€â”€ .gitignore # A default `.gitignore` file for Leo projects
â”œâ”€â”€ .env # The environment, containing the `NETWORK` and `PRIVATE_KEY` variables.
â”œâ”€â”€ program.json # The manifest for the Leo project
â”œâ”€â”€ tests/
  â””â”€â”€ test_hello.leo # The Leo source code for unit tests
â””â”€â”€ src/
  â””â”€â”€ main.leo # The Leo source code


Unpacking the Project
The Manifest
program.json is the Leo manifest file that configures the package.

program.json
{
  "program": "hello.aleo",
  "version": "0.1.0",
  "description": "",
  "license": "MIT",
  "dependencies": null,
  "dev_dependencies": null
}

The program ID in program is the official name that other developers will be able to look up after the program has been deployed to a network. This must be the same as the name of your program in main.leo, or compilation will fail.

Dependencies will be added to the field of the same name, as they are imported. Dependencies that are only used during development and not in production will be added to the dev_dependencies field.

The Code
The src/main.leo file is the entry point of a Leo project. It initially contains a function named main. Let's break down the structure of a Leo file.

src/main.leo
// The 'hello' program.
program hello.aleo {
    @noupgrade
    async constructor() {}

    transition main(public a: u32, b: u32) -> u32 {
        let c: u32 = a + b;
        return c;
    }
}


The keyword program indicates the name of the program inside the Leo file. In this case, it is hello.aleo. As mentioned before, this program name must match the one in the program.json manifest file.

The keyword transition indicates a transition function definition in Leo. The main transition takes an input a with type u32 and public visibility, and an input b with type u32 and private visibility (by default). The transition returns one result with type u32. The transition body is enclosed in curly braces { }.

transition main(public a: u32, b: u32) -> u32 {

Inside the main function we declare a variable c with type u32 and set it equal to the addition of variables a and b. Leo's compiler will check that the types of a and b are equal and that the result of the addition is type u32.

let c: u32 = a + b;

note
Leo is designed to detect many errors at compile time, via statically checked strong types. Try changing the type of any variable and seeing what Leo recommends with helpful error messages.

Last, we return the variable c. Leo will check that c's type matches the function return type u32.

return c;

There is an additional function called a constructor. This is a special function that helps enable program upgradability, which allows you to modify some of the logic and contents of a program after you've already deployed it onchain.

@noupgrade
async constructor() {}

The constructor acts as a gatekeeper for your program; the logic in the function gets run before every deployment and upgrade, and governs who and how this program can be deployed and modified.

note
All programs must have an explicitly declared constructor function.

For now, we'll leave it as is, which will prevent upgrades from occurring. For more details on how program upgradability works, and different patterns for upgrading your programs, check out Upgrading Programs.

Now let's compile and run the program.

Build and Run
To compile the program, run:

leo build

On invoking the build command, Leo automatically creates a build/â  and output/â  folder in the project directory. The compiled code is contained in the build directory. The output directory is used to stored intermediate artifacts from compilation.

The leo run command will both compile and run the specified function program. In your terminal, run:

leo run main 1u32 2u32

console output:
       Leo     2 statements before dead code elimination.
       Leo     2 statements after dead code elimination.
       Leo     The program checksum is: '[212u8, 91u8, ... , 107u8]'.
       Leo âœ… Compiled 'hello.aleo' into Aleo instructions.

â›“  Constraints

 â€¢  'hello.aleo/main' - 33 constraints (called 1 time)

âž¡ï¸  Output

 â€¢ 3u32

       Leo âœ… Finished 'hello.aleo/main' (in "./hello/build")


Deploying and Executing
Running programs locally is great, but you'll likely want to actually deploy your programs and execute functions onchain. To do this, you'll need to use leo deploy for deployment and leo execute to execute functions and generate the transaction containing the requisite metadata and zero-knowledge proofs.

We have dedicated guides for both Deploying and Executing, so please check those out for more information!

Clean
Finally, you can remove all build files and outputs with:

leo clean

console output:
Leo ðŸ§¹ Cleaned the outputs directory ./hello/outputs
Leo ðŸ§¹ Cleaned the build directory ./hello/build


Next Steps
To learn more about the Leo language and its syntax, start here.

To learn more about how to use the Leo CLI, start here.

To get started with some sample projects, check out the Leo By Example section.

The Leo Language Reference
Statically Typed
Leo is a statically typed language, which means we must know the type of each variable before executing a circuit.

Leo does not support undefined or null values. When creating a new variable, its type must be either:

Explicitly stated using a type annotation, or
Automatically inferred by the compiler.
Pass by Value
Expressions in Leo are always passed by value, which means their values are always copied when they are used as function inputs or in right sides of assignments.

Layout of a Leo Project
Manifest
program.json is the Leo manifest file that configures our package.

program.json
{
  "program": "hello.aleo",
  "version": "0.1.0",
  "description": "",
  "license": "MIT",
  "dependencies": null,
  "dev_dependencies": null
}

The program ID in program is the official name that other developers will be able to look up after you have published your program.

    "program": "hello.aleo",

Dependencies will be added to the field of the same name, as they are added. The dependencies are also pegged in the leo.lock file.

The src/ directory is where all of your Leo code will live. The main entry point of your project is a file in this directory appropriately named main.leo. Calls to many of the Leo CLI commands will require you to have this file within your project in order to succeed properly.

Programs
A program is a collection of code (its functions) and data (its types) that resides at a program ID on the Aleo blockchain. A program is declared as program {name}.{network} { ... }. The body of the program is delimited by curly braces {}.

main.leo
import foo.aleo;

program hello.aleo {
    const FOO: u64 = 1u64;
    mapping account: address => u64;

    record Token {
        owner: address,
        amount: u64,
    }

    struct Message {
        sender: address,
        object: u64,
    }

    async transition mint_public(
        public receiver: address,
        public amount: u64,
    ) -> (Token, Future) {
        return (Token {
            owner: receiver,
            amount,
        }, update_state(receiver, amount));
    }

    async function update_state(
        public receiver: address,
        public amount: u64,
    ) {
        let current_amount: u64 = Mapping::get_or_use(account, receiver, 0u64);
        Mapping::set(account, receiver, current_amount + amount);
   }

    function compute(a: u64, b: u64) -> u64 {
        return a + b + FOO;
    }
}


The following must be declared inside the scope of a program in a Leo file:

Constants
Mappings and Storage
Records
Structs
Transitions and Async Transitions
Functions and Async Functions
Inlines
The following must be declared outside the scope of a program in a Leo file:

Imports
Declarations are locally accessible within a program file. If you need a declaration from another Leo file, you must import it.

Imports
You can import dependencies that are downloaded to the imports directory. An import is declared as import {filename}.aleo; The dependency resolver will pull the imported program from the network or the local filesystem.

import foo.aleo; // Import all `foo.aleo` declarations into the `hello.aleo` program.

program hello.aleo { }


Program ID
A program ID is declared as {name}.{network}.

The first character of a name must be a lowercase letter. name can only contain lowercase letters, numbers, and underscores, and must not contain a double underscore (__) or the keyword aleo in it.

Currently, aleo is the only supported network domain.

program hello.aleo; // valid

program Foo.aleo;   // invalid
program baR.aleo;   // invalid
program 0foo.aleo;  // invalid
program 0_foo.aleo; // invalid
program _foo.aleo;  // invalid
program foo__bar.aleo;  // invalid
program aleo.aleo;  // invalid

Modules
In addition to your main file, Leo also supports a module system as of v3.2.0.

Leaf modules (i.e. modules without submodules) must be defined in a single file (ex. foo.leo). Modules with submodules must be defined by an optional top-level .leo file and a subdirectory directory containing the submodules:

Take the following project as an example:

src
â”œâ”€â”€ common.leo
â”œâ”€â”€ main.leo
â”œâ”€â”€ outer.leo
â””â”€â”€ outer
    â””â”€â”€ inner.leo

Given the structure above, the following modules are defined:

Filename	Type	Module Name	Access Location & Pattern
common.leo	Module	common	main.leo : common::<item>
outer.leo	Module	outer	main.leo : outer::<item>
outer/inner.leo	Submodule	outer::inner	main.leo : outer::inner::<item>
outer.leo : inner::<item>
info
Only relative paths are implemented so far. That means that items in outer.leo cannot be accessed from items in inner.leo, for example. This is limiting for now but will no longer be an issue when we add absolute paths.

A module file may only contain struct, const, and inline definitions:

const X: u32 = 2u32;

struct S {
    a: field
}

inline increment(x: field) -> field {
    return 1field;
}

Data Types
Primitive Types
Addresses
Addresses are defined to enable compiler-optimized routines for parsing and operating over addresses. These semantics will be accompanied by a standard library in a future sprint.

let sender: address = aleo1ezamst4pjgj9zfxqq0fwfj8a4cjuqndmasgata3hggzqygggnyfq6kmyd4;
let receiver = aleo129nrpl0dxh4evdsan3f4lyhz5pdgp6klrn5atp37ejlavswx5czsk0j5dj;


Booleans
Leo supports the traditional true or false boolean values.

let b: bool = false;
let a = false

Integers
Leo supports signed integer types i8, i16, i32, i64, i128 and unsigned integer types u8, u16, u32, u64, u128.

let b: u8 = 1u8;

Underscores _ can be used to separate digits in integer literals.

let n: u64 = 1_000_000u64;

info
Higher bit length integers generate more constraints in the circuit, which can slow down computation time.

info
Leo does not assume a default integer type. Every integer must either have an explicit type annotation or a type that can be inferred by the compiler.

let a: u8 = 2u8; // explicit type
let b: u16 = a as u16; // type casting

Field Elements
Leo supports the field type for elements of the base field of the elliptic curve. These are unsigned integers less than the modulus of the base field. The following are the smallest and largest field elements.

let a: field = 0field;
let b = 8444461749428370424248824938781546531375899335154063827935233455917409239040field;
let c: field = 0;


Group Elements
The set of affine points on the elliptic curve forms a group. The curve is a Twisted Edwards curve with a = -1 and d = 3021. Leo supports a subgroup of the group, generated by a generator point, as a primitive data type. A group element is denoted by the x-coordinate of its point; for example, 2group means the point (2, 5553594316923449299484601589326170487897520766531075014687114064346375156608).

let a: group = 0group; // the point with 0 x-coordinate, (0, 1)
let b = 1540945439182663264862696551825005342995406165131907382295858612069623286213group;  // the generator point
let c: group = 0;


The aforementioned generator point can be obtained via a constant associated to the group type.

let g: group = group::GEN; // the group generator

Scalar Elements
Leo supports the scalar type for elements of the scalar field defined by the elliptic curve subgroup. These are unsigned integers less than the modulus of the scalar field. The following are the smallest and largest scalars.

let a: scalar = 0scalar;
let b = 2111115437357092606062206234695386632838870926408408195193685246394721360382scalar;
let c: scalar = 0;


Signatures
Aleo uses the Schnorr signature scheme to sign messages with an Aleo private key. Signatures are a native type in Leo, and can be declared with the keyword signature. Signatures can be verified in Leo using the signature::verify or s.verify operators.

program test.aleo {

    struct foo {
        a: u8,
        b: scalar
    }

    transition verify_field(s: signature, a: address, v: field) {
        let first: bool = signature::verify(s, a, v);
        let second: bool = s.verify(a, v);
        assert_eq(first, second);
    }

    transition verify_foo(s: signature, a: address, v: foo) {
        let first: bool = signature::verify(s, a, v);
        let second: bool = s.verify(a, v);
        assert_eq(first, second);
    }
}


Composite Types
Arrays
Leo supports static arrays. Array types are declared as [type; length]. Elements can only be primitive data types, structs, or nested arrays.

// Initalize a boolean array of length 4
let arr: [bool; 4] = [true, false, true, false];

// Empty array
let empty: [u32; 0] = [];

// Nested array
let nested: [[bool; 2]; 2] = [[true, false], [true, false]];


Structs and records can also contain arrays as fields.

record Foo {
    owner: address,
    data: [u8; 8],
}

struct Bar {
    data: [u8; 8],
}

// Array of structs
let arr_of_structs: [Bar; 2] = [Bar { data: 1u8 }, Bar { data: 2u8 }];


Arrays only support constant accesses. The accessor expression must be a constant expression (known at compile-time).

// Access the field of a struct within an array
transition foo(a: [Bar; 8]) -> u8 {
    return a[0u8].data;
}

Arrays can be stored as a mapping input/output, and iterated over using a loop.

// Declare a mapping that contains array values
mapping data: address => [bool; 8];


// Iterate over an array using a for loop and sum the values within
transition sum_with_loop(a: [u64; 4]) -> u64 {
    let sum: u64 = 0u64;
    for i: u8 in 0u8..4u8 {
        sum += a[i];
    }
    return sum;
}


Tuples
Leo supports tuples. Tuple types are declared as (type1, type2, ...) and cannot be empty.

Tuples can contain primitive data types, structs, arrays, or nested tuples. Structs and records can also contain tuples.

// Initalize a boolean array of length 4
let tup: (u8,u8,bool) = (1u8,1u8,true);

// Nested array
let nested: [[bool; 2]; 2] = [[true, false], [true, false]];


Structs and records can also contain tuples as fields.

record Foo {
    owner: address,
    data: (u8,u8),
}

struct Bar {
    data: (u8,u8),
}

// Tuple of structs
let tup_of_structs: [Bar; 2] = [Bar { data: (1u8,1u8) }, Bar { data: (2u8,2u8) }];


Tuples only support constant access with a dot . and a constant integer.

transition baz(foo: u8, bar: u8) -> u8 {
    let a: (u8, u8) = (foo, bar);
    let result: u8 = a.0 + a.1;
    return result;
}

Structs
Struct types are declared and constructed with a familiar syntax. Note that there is a global namespace for struct types across your program and its dependencies. If a dependency declares a struct type T, you may access that type without any qualifier.

program test.aleo {
    struct S {
        x: field,
        y: u32,
    }

    transition foo(y: u32) -> S {
        let s: S = S {
            x: 172field,
            y,
        };
        return s;
    }
}

As of v3.0.0, Leo now supports const generics for struct types:

struct Matrix::[N: u32, M: u32] {
    data: [field; N * M],
}

// Usage
let m = Matrix::[2, 2] { data: [0, 1, 2, 3] };

Note that generic structs cannot currently be imported outside a program, but can be declared and used in submodules. Acceptable types for const generic parameters include integer types, bool, scalar, group, field, and address.

Records
A record data type is the method of encoding private state on Aleo. Records are declared as record {name} {}. A record name must not contain the keyword aleo, and must not be a prefix of any other record name.

Records contain component declarations {visibility} {name}: {type},. Names of record components must not contain the keyword aleo. The visibility qualifier may be specified as constant, public, or private. If no qualifier is provided, Leo defaults to private.

Record data structures must always contain a component named owner of type address, as shown below. When passing a record as input to a program function, the _nonce: group and _version: u8 components are also required but do not need to be declared in the Leo program. They are inserted automatically by the compiler.

record Token {
    // The token owner.
    owner: address,
    // The token amount.
    amount: u64,
}

Option Types
As of v3.3.0, Leo supports first-class option types using the T? syntax, where T is any of the types previously mentioned, excluding record, address, signature, and tuple. A value of type T? can be initialized into two states: either a value of type T, or none:

let w: u8? = 42u8;
let x: u8? = none;

A value of type T? can be converted to type T by calling the .unwrap() method on the value. Note that if the value being unwrapped is none, then the program will fail to execute. To unwrap the value with a fallback for this case, call the .unwrap_or() method:

let y = w.unwrap();        // Returns 42u8
let z = x.unwrap_or(99u8); // Returns 99u8

Option types can also be stored in arrays and structs:

// Struct of options
struct Point { 
    x: u32?, 
    y: u32? 
}

// Array of options
let arr: [u16?; 2] = [1u16, none];
let first_val = arr[0].unwrap();        // Returns 1u16
let second_val = arr[1].unwrap_or(0u16); // Returns 0u16

// Structs have option variant as well
let p: Point? = none;
let p_val = p.unwrap_or(Point { x: 0u32, y: none }); // Returns default 


Type Inference
As of v2.7.0, Leo supports type inference. The Leo compiler is able to infer the types of declared variables and expressions as long as the type can be unambiguously determined from the surrounding context.

If the compiler cannot infer the type, you must provide an explicit type annotation.

Here are some examples:

let a: u8 = 2u8; // explicit type - allowed
let b = 2u8; // type inference - allowed
let c : u8 = 2; // type inference - allowed

let d = 2; // ambiguous type - not allowed

Type inference also applies to members within a struct:

struct Foo {
    x: u8
}

let f = Foo {
    x: 5, // inferred to be a `u8`
};

Private State
Records
A record data type is the method of encoding private state on Aleo. Records are declared as record {name} {}. A record name must not contain the keyword aleo, and must not be a prefix of any other record name.

Records contain component declarations {visibility} {name}: {type},. Names of record components must not contain the keyword aleo. The visibility qualifier may be specified as constant, public, or private. If no qualifier is provided, Leo defaults to private.

Record data structures must always contain a component named owner of type address, as shown below. When passing a record as input to a program function, the _nonce: group and _version: u8 components are also required but do not need to be declared in the Leo program. They are inserted automatically by the compiler.

record Token {
    // The token owner.
    owner: address,
    // The token amount.
    amount: u64,
}


Public State
Mappings
There are several functions available to query and modify mappings. The examples below will reference the following mapping:

mapping balance: address => u64;

Querying
To simply check if a value has been set for a particular address in balance:

balance.contains(addr)
Mapping::contains(balance, addr); // Alternate syntax


To query a value for a particular address in balance:

balance.get(addr)
Mapping::get(balance, addr); // Alternate syntax

Note that if value at addr does not exist above, then the program will fail to execute. To query a value with a fallback for this case:

balance.get_or_use(addr,fallback_value)
Mapping::get_or_use(balance, addr, fallback_value); // Alternate syntax


A program can also query values from another program's mappings:

let balance1 = credits.aleo/account.get(addr);
let balance2 = credits.aleo/account.get_or_use(addr, 0u64);


Although values can be queried, a program cannot directly modify another program's mappings.

Modifying
To set a value for a particular address in balance:

balance.set(addr,value)
Mapping::set(balance, addr, value); // Alternate syntax


To remove the value set at particular address in balance:

balance.remove(addr)
Mapping::remove(balance, addr); // Alternate syntax


Usage
program map.aleo {
    mapping balance: address => u64;

    async transition dubble() -> Future {
        return dubble_onchain(self.caller);
    }

    async function dubble_onchain(addr: address) {
        let current_value: u64 = balance.get_or_use(addr, 0u64);
        balance.set(addr, current_value + 1u64);

        let next_current_value = balance.get(addr);
        balance.set(addr, current_value + 1u64);
    }

}


info
Mapping operations are only allowed in an async function or async block.

Storage Variables
Storage variables behave similar to option types. There are several functions available to query and modify singleton storage variables. The examples below will reference the following:

storage counter: u64;

Querying
To query the value currrently stored at counter:

counter.unwrap();

Note that if counter has not been initialized, then the program will fail to execute. To query the value with a fallback for this case:

counter.unwrap_or(fallback_value);

Modifying
To set a value for counter:

counter = 5u64;

To unset the value at counter:

counter = none;

Usage
program storage_variable.aleo {
    storage counter: u64;

    async transition increment() -> Future {
        return increment_onchain();
    }

    async function increment_onchain() {
        let current_value: u64 = counter.unwrap_or(0u64);
        counter = current_value + 1u64;
    }

}


info
Storage variable operations are only allowed in an async function or async block.

Storage Vectors
Storage vectors behave like dynamic arrays of values of a given types. There are several functions available to query and modify storage vectors. The examples below will reference the following:

storage id_numbers: [u64];

Querying
To query the element currrently stored in id_numbers at index idx:

id_numbers.get(idx);

To get the current length of id_numbers:

id_numbers.len();

Modifying
To set an element at index idx in id_numbers:

id_numbers.set(idx, value);

To push an element onto the end of id_numbers:

id_numbers.push(value);

To pop and return the last element of id_numbers:

id_numbers.pop();

To remove the element at index idx, return it, and replace it with the final element of id_numbers:

id_numbers.swap_remove(idx);

To clear the every element in id_numbers:

id_numbers.clear()

note
clear() does not actually remove any values from the vector. It just sets the length to 0.
Similarly swap_remove() and pop() do not actually remove values either. They just reduce the length by 1 to make sure the last element is no longer accessible.
Usage
program storage_vector.aleo {
    storage id_numbers: [u64];

    async transition add_id(new_id: u64) -> Future {
        return add_id_onchain(new_id);
    }

    async function add_id_onchain(new_id: u64) {
        id_numbers.push(new_id);
    }


    async transition remove_id(idx: u32) -> Future {
        return remove_id_onchain(idx);
    }

    async function remove_id_onchain(idx: u32) {
        id_numbers.swap_remove(idx);
    }
}


info
Storage vector operations are only allowed in an async function or async block.


Functions
Transitions
Transition functions in Leo are declared as transition {name}() {}. If they include a call to an async function to execute code onchain, they must be declared as async transition. Transition functions within a program's current scope can be called directly when running a Leo program (via leo run).

program hello.aleo {
    transition foo(
        public a: field,
        b: field,
    ) -> field {
        return a + b;
    }
}

Inputs
Inputs are declared as {visibility} {name}: {type}. They must be declared just after the function name declaration, in parentheses.

// The transition function `foo` takes a single input `a` with type `field` and visibility `public`.
transition foo(public a: field) { }


Outputs
The return type of the transition is declared as -> {expression} and must be declared just after the function inputs. A function output is calculated as return {expression};. Returning an output ends the execution of the function, and the type of the returned value must match the output type declared in the function signature.

transition foo(public a: field) -> field {
    // Returns the addition of the public input a and the value `1field`.
    return a + 1field;
}


Async Function
An async function is used to define a computation that gets executed onchain. The most common use case is to initiate or change public on chain state within mappings/storage.

An async function can only be called by an async transition.It is declared as async function, and calls to it return a Future object. Async functions are atomic; they either succeed or fail, and the state is reverted if they fail.

The term asynchronous is used because the code gets executed onchain only after the transaction has been submitted and the zero-knowledge proof of the execution of the associated transition is verified.

An example of using an async function to perform on-chain state mutation is in the transfer_public_to_private transition below, which updates the public account mapping (and thus a user's balance) when called.

program transfer.aleo {
    // The function `transfer_public_to_private` turns a specified token amount
    // from `account` into a token record for the specified receiver.
    //
    // This function preserves privacy for the receiver's record, however
    // it publicly reveals the sender and the specified token amount.
    async transition transfer_public_to_private(
        receiver: address,
        public amount: u64
    ) -> (token, Future) {
        // Produce a token record for the token receiver.
        let new: token = token {
            owner: receiver,
            amount,
        };

        // Return the receiver's record, then decrement the token amount of the caller publicly.
        return (new, update_public_state(self.caller, amount));
    }

    async function update_public_state(
        public sender: address,
        public amount: u64
    ) {
        // Decrements `account[sender]` by `amount`.
        // If `account[sender]` does not exist, it will be created.
        // If `account[sender] - amount` underflows, `transfer_public_to_private` is reverted.
        let current_amount: u64 = Mapping::get_or_use(account, sender, 0u64);
        Mapping::set(account, sender, current_amount - amount);
    }
}


Alternatively, you may write async code inside of an async block within an async transition function. Below is what that would look like for the same transfer_public_to_private transition:

program transfer.aleo {
    async transition transfer_public_to_private(
        receiver: address,
        public amount: u64
    ) -> (token, Future) {
        let new: token = token {
            owner: receiver,
            amount,
        };

        let f : Future = async {
            let current_amount: u64 = Mapping::get_or_use(account, self.caller, 0u64);
            Mapping::set(account, self.caller, current_amount - amount);
        }

        return (new, f);
    }
}


If there is no need to create or alter the public on-chain state, async functions are not required.

Helper Function
A helper function is declared as function {name}({arguments}) {}. They contain expressions and statements that can compute values. However, helper functions cannot produce records.

Helper functions cannot be called directly. Instead, they must be called by other functions. Inputs of helper functions cannot have {visibility} modifiers like transition functions, since they are used only internally, not as part of a program's external interface.

function foo(
    a: field,
    b: field,
) -> field {
    return a + b;
}

Inline Function
An inline function is declared as inline {name}() {}. Similar to helper functions, they contain expressions and statements that can compute values, and cannot be executed directly from the outside. The key difference is that the Leo compiler inlines the body of the function at each call site.

Inputs of inline functions cannot have {visibility} modifiers like transition functions, since they are used only internally, not as part of a program's external interface.

inline foo(
    a: field,
    b: field,
) -> field {
    return a + b;
}

As of Leo v3.0.0, inline functions also support const generics:

inline sum_first_n_ints::[N: u32]() -> u32 {
    let sum = 0u32;
    for i in 0u32..N {
        sum += i
    }
    return sum;
}
 
transition main() -> u32 {
    return sum_first_n_ints::[5u32]();
}

Acceptable types for const generic parameters include integer types, bool, scalar, group, field, and address.

Function Call Rules
There are three function variants: transition, function, and inline.
A transition can call: function, inline, and external transitions.
A function can only call: inlines.
An inline can only call: other inlines.
Recursive calls (direct or indirect) are not allowed.


Control Flow
Conditional Statements
Conditional statements are declared as if {condition} {...} else if {condition} {...} else {...}. Conditional statements can be nested.

    let a: u8 = 1u8;
    
    if a == 1u8 {
        a += 1u8;
    } else if a == 2u8 {
        a += 2u8;
    } else {
        a += 3u8;
    }

Leo also supports ternary expressions. Ternary expressions are declared as {condition} ? {then} : {else}, and can be nested.

let a: u8 = 1u8;    
a = (a == 1u8) ? a + 1u8 : ((a == 2u8) ? a + 2u8 : a + 3u8);


For Loops
For loops are declared as for {variable: type} in {lower bound}..{upper bound}. The loop bounds must be integer constants of the same type. Furthermore, if the lower bound is superior or equal to the upper bound, the loop will result in no operations. Nested loops are supported.

  let count: u32 = 0u32;

  for i: u32 in 0u32..5u32 {
    count += 1u32;
  }

  return count; // returns 5u32

Return Statements
Return statements are declared as return {expression};.

    let a: u8 = 1u8;
    
    if a == 1u8 {
        return a + 1u8;
    } else if a == 2u8 {
        return a + 2u8;
    } else {
        return a + 3u8;
    }

Limitations
snarkVM imposes the following limits on Aleo programs:

the maximum size of the program 100 KB, by the number of characters.
the maximum number of mappings is 31.
the maximum number of imports is 64.
the maximum import depth is 64.
the maximum call depth is 31.
the maximum number of functions is 31.
the maximum number of structs is 310.
the maximum number of records is 310.
the maximum number of closures is 62.
If your compiled Leo program exceeds these limits, then consider modularizing or rearchitecting your program. The only way these limits can be increased is through a formal protocol upgrade via the governance process defined by the Aleo Network Foundation.

Some other protocol-level limits to be aware of are:

the maximum transaction size is 128 KB. If your program exceeds this, perhaps by requiring large inputs or producing large outputs, consider optimizing the data types in your Leo code.
the maximum number of micro-credits your transaction can consume for on-chain execution is 100_000_000.. If your program exceeds this, consider optimizing on-chain components of your Leo code.
As with the above restructions. these limits can only be increased via the governance process.

Compiling Conditional On-Chain Code
Consider the following Leo transition.

transition weird_sub(a: u8, b: u8) -> u8 {
    if (a >= b) {
        return a.sub_wrapped(b);
    } else {
        return b.sub_wrapped(a);
    }
}

This is compiled into the following Aleo instructions:

function weird_sub:
    input r0 as u8.private;
    input r1 as u8.private;
    gte r0 r1 into r2;
    sub.w r0 r1 into r3;
    sub.w r1 r0 into r4;
    ternary r2 r3 r4 into r5;
    output r5 as u8.private;

Observe that both branches of the conditional are executed in the transition. The correct output is then selected using a ternary instruction. This compilation method is only possible because operations in transitions are purely functional. 1.

On-chain commands are not all purely functional; for example, get, get.or_use, contains, remove, and set, whose semantics all depend on the state of the program. As a result, the same technique for off-chain code cannot be used. Instead, the on-chain code is compiled using branch and position commands, which allow the program to define sequences of code that are skipped. However, because destination registers in skipped instructions are not initialized, they cannot be accessed in a following instructions. In other words, depending on the branch taken, some registers are invalid and an attempt to access them will return in an execution error. The only Leo code pattern that produces such an access attempt is code that attempts to assign out to a parent scope from a conditional statement; consequently, they are disallowed.

This restriction can be mitigated by future improvements to snarkVM, however we table that discussion for later.

There are some operations that are not purely functional, e.g add which can fail on overflow.â†©


Operators & Expressions
Operators
Operators in Leo compute a value based off of one or more expressions. Leo defaults to checked arithmetic, which means that it will throw an error if an overflow or division by zero is detected.

For instance, addition adds first with second, storing the outcome in destination. For integer types, a constraint is added to check for overflow. For cases where wrapping semantics are needed for integer types, see the wrapped variants of the operators.

let a: u8 = 1u8 + 1u8;
// a is equal to 2

a += 1u8;
// a is now equal to 3

a = a.add(1u8);
// a is now equal to 4

note
The Leo operators compile down to Aleo Instructions opcodes executable by the Aleo Virtual Machine (AVM).

Operator Precedence
Operators will prioritize evaluation according to:

Operator	Associativity
! -(unary)	
**	right to left
* /	left to right
+ -(binary)	left to right
<< >>	left to right
&	left to right
|	left to right
^	left to right
< > <= >=	
== !=	left to right
&&	left to right
||	left to right
= += -= *= /= %= **= <<= >>= &= |= ^=	
Parentheses
To prioritize a different evaluation, use parentheses () around the expression.

let result = (a + 1u8) * 2u8;

(a + 1u8) will be evaluated before multiplying by two * 2u8.

Hashing vs. Committing
Many of the cryptographic operators have both hash and commit variants.

The hash variant is a one-way function that takes an input produces a fixed-size output called a "hash" or "digest." It has a unique property that if even one bit of the input changes, the output hash will change completely, making it easy to see if data has been tampered with.

The commit variant is a wrapper around the hash variant that takes an additional parameter called a blinding factor, otherwise known as a salt. The salt is appended to the input value before hashing it, ensuring the output will be unique from just the simple hash of the raw input. So long as a different salt is used each time, this allows a user to commit to the same value multiple times without revealing that they've done so.


Standard Operators
Table of Contents
Name	Description
abs	Absolute value
abs_wrapped	Wrapping absolute value
add	Addition
add_wrapped	Wrapping addition
and	Conjunction
assert	Assert boolean true
assert_eq	Assert equality
assert_neq	Assert non-equality
block.height	Fetch the latest block height
block.timestamp	Fetch the latest block timestamp
Deserialize:from_bits::[TYPE]	Deserialize bits to a data type
div	Division
div_wrapped	Wrapping division operation
double	Double
group::GEN	group generator
gt	Greater than comparison
gte	Greater than or equal to comparison
inv	Multiplicative inverse
eq	Equality comparison
neq	Non-equality comparison
lt	Less than comparison
lte	Less than or equal to comparison
mod	Modulo
mul	Multiplication
mul_wrapped	Wrapping multiplication
nand	Negated conjunction
neg	Additive inverse
nor	Negated disjunction
not	Logical negation
or	(Inclusive) disjunction
pow	Exponentiation
pow_wrapped	Wrapping exponentiation
rem	Remainder
rem_wrapped	Wrapping remainder
self.address	Address of the current program
self.caller	Address of a transition's calling user/program
self.checksum	Checksum of a program
self.edition	Version number of a program
self.program_owner	Address that submitted a program's deployment transaction
self.signer	Address of the top-level transition's calling user
Serialize::to_bits	Serialize data to bits
shl	Shift left
shl_wrapped	Wrapping shift left
shr	Shift right
shr_wrapped	Wrapping shift right
square_root	Square root
square	Square
sub	Subtraction
sub_wrapped	Wrapping subtraction
ternary	Ternary select
to_x_coordinate	Extract x-coordinate of a group element
to_y_coordinate	Extract y-coordinate of a group element
xor	Exclusive conjunction
Arithmetic Operators
abs
let a: i8 = -1i8;
let b: i8 = a.abs(); // 1i8

Computes the absolute value of the input, checking for overflow, storing the result in the destination.

Note that execution will halt if the operation overflows. For cases where wrapping semantics are needed, see the abs_wrapped instruction. This overflow happens when the input is the minimum value of a signed integer type. For example, abs -128i8 would result in overflow, since 128 cannot be represented as an i8.

Supported Types
Input	Destination
i8	i8
i16	i16
i32	i32
i64	i64
i128	i128
Back to Top

abs_wrapped
let a: i8 = -128i8;
let b: i8 = a.abs_wrapped(); // -128i8

Compute the absolute value of the input, wrapping around at the boundary of the type, and storing the result in the destination.

Supported Types
Input	Destination
i8	i8
i16	i16
i32	i32
i64	i64
i128	i128
Back to Top

add
let a: u8 = 1u8;
let b: u8 = a + 1u8; // 2u8
let c: u8 = b.add(1u8); // 3u8

Adds first with second, storing the result in destination.

Note that execution will halt if the operation overflows. For cases where wrapping semantics are needed for integer types, see the add_wrapped instruction.

Supported Types
First	Second	Destination
field	field	field
group	group	group
i8	i8	i8
i16	i16	i16
i32	i32	i32
i64	i64	i64
i128	i128	i128
u8	u8	u8
u16	u16	u16
u32	u32	u32
u64	u64	u64
u128	u128	u128
scalar	scalar	scalar
Back to Top

add_wrapped
let a: u8 = 255u8;
let b: u8 = a.add_wrapped(1u8); // 0u8

Adds first with second, wrapping around at the boundary of the type, and storing the result in destination.

Supported Types
First	Second	Destination
i8	i8	i8
i16	i16	i16
i32	i32	i32
i64	i64	i64
i128	i128	i128
u8	u8	u8
u16	u16	u16
u32	u32	u32
u64	u64	u64
u128	u128	u128
Back to Top

div
let a: u8 = 4u8;
let b: u8 = a / 2u8; // 2u8
let c: u8 = b.div(2u8); // 1u8

Performs division of the first operand by the second, storing the result in the destination. The operation halts if division by zero is attempted.

For integer types, this operation performs truncated division. Truncated division rounds towards zero, regardless of the sign of the operands. This means it cuts off any digits after the decimal, leaving the whole number whose absolute value is less than or equal to the result.

For example:

7 / 3 yields 2, not 2.3333.
-7 / 3 yields -2, not -2.3333.
The operation halts if there is an underflow. Underflow occurs when dividing the minimum value of a signed integer type by -1. For example, -128i8 / -1i8 would result in underflow, since 128 cannot be represented as an i8.

For field types, division a / b is well-defined for any field values a and b except when b = 0field.

For cases where wrapping semantics are needed for integer types, see the div_wrapped instruction.

Supported Types
First	Second	Destination
field	field	field
i8	i8	i8
i16	i16	i16
i32	i32	i32
i64	i64	i64
i128	i128	i128
u8	u8	u8
u16	u16	u16
u32	u32	u32
u64	u64	u64
u128	u128	u128
Back to Top

div_wrapped
let a: i8 = -128i8;
let b: i8 = a.div_wrapped(-1i8); // -128i8

Divides first by second, wrapping around at the boundary of the type, and storing the result in destination. Halts if second is zero.

Supported Types
First	Second	Destination
i8	i8	i8
i16	i16	i16
i32	i32	i32
i64	i64	i64
i128	i128	i128
u8	u8	u8
u16	u16	u16
u32	u32	u32
u64	u64	u64
u128	u128	u128
Back to Top

mod
let a: u8 = 3u8.mod(2u8); // 1u8

Takes the modulo of first with respect to second, storing the result in destination. Halts if second is zero.

The semantics of this operation are consistent with the mathematical definition of modulo operation.

mod ensures the remainder has the same sign as the second operand. This differs from rem, which follows truncated division and takes the sign of the first operand.

Supported Types
First	Second	Destination
u8	u8	u8
u16	u16	u16
u32	u32	u32
u64	u64	u64
u128	u128	u128
Back to Top

mul
let a: u8 = 2u8 * 2u8; // 4u8
let b: u8 = a.mul(2u8); // 8u8

Multiplies first with second, storing the result in destination.

Note that execution will halt if the operation overflows/underflows. For cases where wrapping semantics are needed for integer types, see the mul_wrapped instruction.

Supported Types
First	Second	Destination
field	field	field
group	scalar	group
scalar	group	group
i8	i8	i8
i16	i16	i16
i32	i32	i32
i64	i64	i64
i128	i128	i128
u8	u8	u8
u16	u16	u16
u32	u32	u32
u64	u64	u64
u128	u128	u128
Back to Top

mul_wrapped
let a: u8 = 128u8.mul_wrapped(2u8); // 0u8

Multiplies first with second, wrapping around at the boundary of the type, and storing the result in destination.

Supported Types
First	Second	Destination
i8	i8	i8
i16	i16	i16
i32	i32	i32
i64	i64	i64
i128	i128	i128
u8	u8	u8
u16	u16	u16
u32	u32	u32
u64	u64	u64
u128	u128	u128
Back to Top

neg
let a: i8 = -1i8.neg(); // 1i8

Negates the first operand, storing the result in the destination.

For signed integer types, the operation halts if the minimum value is negated. For example, -128i8.neg() halts since 128 cannot be represented as an i8.

Supported Types
Input	Destination
field	field
group	group
i8	i8
i16	i16
i32	i32
i64	i64
i128	i128
Back to Top

pow
let a: u8 = 2u8 ** 2u8; // 4u8
let b: u8 = a.pow(2u8); // 16u8

Raises first to the power of second, storing the result in destination.

Note that execution will halt if the operation overflows/underflows. For cases where wrapping semantics are needed for integer types, see the pow_wrapped instruction.

Supported Types
Magnitude can be a u8, u16, or u32.

First	Second	Destination
field	field	field
i8	Magnitude	i8
i16	Magnitude	i16
i32	Magnitude	i32
i64	Magnitude	i64
i128	Magnitude	i128
u8	Magnitude	u8
u16	Magnitude	u16
u32	Magnitude	u32
u64	Magnitude	u64
u128	Magnitude	u128
Back to Top

pow_wrapped
let a: u8 = 16u8.pow_wrapped(2u8); // 0u8

Raises first to the power of second, wrapping around at the boundary of the type, storing the result in destination.

Supported Types
Magnitude can be a u8, u16, or u32.

First	Second	Destination
i8	Magnitude	i8
i16	Magnitude	i16
i32	Magnitude	i32
i64	Magnitude	i64
i128	Magnitude	i128
u8	Magnitude	u8
u16	Magnitude	u16
u32	Magnitude	u32
u64	Magnitude	u64
u128	Magnitude	u128
Back to Top

rem
let a: u8 = 3u8 % 2u8; // 1u8
let b: u8 = 4u8.rem(2u8); // 0u8

Computes the remainder of the division of the first operand by the second, storing the result in destination following truncated division rules:

a and b refers to first and second respectively

a % b = a - (a / b) * b

Here, a and b refer to the first and second operands, respectively

Note that execution will halt if the operation underflows or divides by zero. This underflow happens when the associated division operation, div, underflows.

For cases where wrapping semantics are needed for integer types, see the rem_wrapped instruction.

rem follows truncated division, meaning the remainder has the same sign as a. This differs from mod, where the remainder matches the sign of b.

Supported Types
First	Second	Destination
i8	i8	i8
i16	i16	i16
i32	i32	i32
i64	i64	i64
i128	i128	i128
u8	u8	u8
u16	u16	u16
u32	u32	u32
u64	u64	u64
u128	u128	u128
Back to Top

rem_wrapped
let a: i8 = -128i8;
let b: i8 = a.rem_wrapped(-1i8); // 0i8

Computes the remainder of the division of the first operand by the second following truncated division rules, storing the result in destination. Halts on division by zero. Unlike rem, rem_wrapped is always defined and does not halt, even when div would wrap around.

Notably, rem_wrapped does not introduce wrapping itself but ensures the operation remains defined where rem would be undefined.

Supported Types
First	Second	Destination
i8	i8	i8
i16	i16	i16
i32	i32	i32
i64	i64	i64
i128	i128	i128
u8	u8	u8
u16	u16	u16
u32	u32	u32
u64	u64	u64
u128	u128	u128
Back to Top

sub
let a: u8 = 2u8 - 1u8; // 1u8
let b: u8 = a.sub(1u8); // 0u8

Computes first - second, storing the result in destination. The operation halts if the result is negative in an unsigned type or if it exceeds the minimum representable value in a signed type.

Supported Types
First	Second	Destination
field	field	field
group	group	group
i8	i8	i8
i16	i16	i16
i32	i32	i32
i64	i64	i64
i128	i128	i128
u8	u8	u8
u16	u16	u16
u32	u32	u32
u64	u64	u64
u128	u128	u128
Back to Top

sub_wrapped
let a: u8 = 0u8.sub_wrapped(1u8); // 255u8

Computes first - second, wrapping around at the boundary of the type, and storing the result in destination.

Supported Types
First	Second	Destination
i8	i8	i8
i16	i16	i16
i32	i32	i32
i64	i64	i64
i128	i128	i128
u8	u8	u8
u16	u16	u16
u32	u32	u32
u64	u64	u64
u128	u128	u128
Back to Top

Boolean/Bitwise Operators
and
// Integer (bitwise) AND
let a: i8 = 1i8 & 1i8; 
let b: i8 = 1i8.and(2i8);

// Boolean (logical) AND
let a: bool = true && true; 
let b: bool = true.and(false);

Performs an AND operation on integer (bitwise) or boolean first and second, storing the result in destination.

Supported Types
First	Second	Destination
bool	bool	bool
i8	i8	i8
i16	i16	i16
i32	i32	i32
i64	i64	i64
i128	i128	i128
u8	u8	u8
u16	u16	u16
u32	u32	u32
u64	u64	u64
u128	u128	u128
Back to Top

nand
let a: bool = true.nand(false); // true

Calculates the negated conjunction of first and second, storing the result in destination. The result is false if and only if both first and second are true.

Supported Types
First	Second	Destination
bool	bool	bool
Back to Top

nor
let a: bool = false.nor(false); // true

Calculates the negated (inclusive) disjunction of first and second, storing the result in destination. The result is true if and only if both first and second are false.

Supported Type
First	Second	Destination
bool	bool	bool
Back to Top

not
let a: bool = true.not(); // false

Perform a NOT operation on an integer (bitwise) or boolean input, storing the result in destination.

Supported Types
Input	Destination
bool	bool
i8	i8
i16	i16
i32	i32
i64	i64
i128	i128
u8	u8
u16	u16
u32	u32
u64	u64
u128	u128
Back to Top

or
// Integer (bitwise) OR
let a: i8 = 1i8 | 2i8; 
let b: i8 = 1i8.or(2i8); 

// Boolean (logical) OR
let a: bool = true || true; 
let b: bool = true.or(false);

Performs an inclusive OR operation on integer (bitwise) or boolean first and second, storing the result in destination.

Supported Types
First	Second	Destination
bool	bool	bool
i8	i8	i8
i16	i16	i16
i32	i32	i32
i64	i64	i64
i128	i128	i128
u8	u8	u8
u16	u16	u16
u32	u32	u32
u64	u64	u64
u128	u128	u128
Back to Top

shl
let a: u8 = 1u8 << 1u8; // 2u8
let b: u8 = a.shl(1u8); // 4u8

Shifts first left by second bits, storing the result in destination. The operation halts if the shift distance exceeds the bit size of first, or if the shifted result does not fit within the type of first.

Supported Types
Magnitude can be a u8, u16, or u32.

First	Second	Destination
i8	Magnitude	i8
i16	Magnitude	i16
i32	Magnitude	i32
i64	Magnitude	i64
i128	Magnitude	i128
u8	Magnitude	u8
u16	Magnitude	u16
u32	Magnitude	u32
u64	Magnitude	u64
u128	Magnitude	u128
Back to Top

shl_wrapped
let a: u8 = 128u8.shl_wrapped(1u8); // 0u8
let b: i8 = 64i8.shl_wrapped(2u8); // -128i8

Shifts first left by second bits, wrapping around at the boundary of the type, storing the result in destination. The shift distance is masked to the bit width of first, ensuring that shifting by n is equivalent to shifting by n % bit_size.

If bits are shifted beyond the type's range, they are discarded, which may cause sign changes for signed integers.

Supported Types
Magnitude can be a u8, u16, or u32.

First	Second	Destination
i8	Magnitude	i8
i16	Magnitude	i16
i32	Magnitude	i32
i64	Magnitude	i64
i128	Magnitude	i128
u8	Magnitude	u8
u16	Magnitude	u16
u32	Magnitude	u32
u64	Magnitude	u64
u128	Magnitude	u128
Back to Top

shr
let a: u8 = 4u8 >> 1u8; // 2u8
let b: u8 = a.shr(1u8); // 1u8

Shifts first right by second bits, storing the result in destination. The operation halts if the shift distance exceeds the bit size of first.

Supported Types
Magnitude can be a u8, u16, or u32.

First	Second	Destination
i8	Magnitude	i8
i16	Magnitude	i16
i32	Magnitude	i32
i64	Magnitude	i64
i128	Magnitude	i128
u8	Magnitude	u8
u16	Magnitude	u16
u32	Magnitude	u32
u64	Magnitude	u64
u128	Magnitude	u128
Back to Top

shr_wrapped
let a: u8 = 128u8.shr_wrapped(7u8); // 1u8

Shifts first right by second bits, wrapping around at the boundary of the type, storing the result in destination. The shift distance is masked to the bit width of first, ensuring that shifting by n is equivalent to shifting by n % bit_size.

Supported Types
Magnitude can be a u8, u16, or u32.

First	Second	Destination
i8	Magnitude	i8
i16	Magnitude	i16
i32	Magnitude	i32
i64	Magnitude	i64
i128	Magnitude	i128
u8	Magnitude	u8
u16	Magnitude	u16
u32	Magnitude	u32
u64	Magnitude	u64
u128	Magnitude	u128
Back to Top

xor
let a: bool = true.xor(false); // true

Performs a XOR operation on integer (bitwise) or boolean first and second, storing the result in destination.

Supported Types
First	Second	Destination
bool	bool	bool
i8	i8	i8
i16	i16	i16
i32	i32	i32
i64	i64	i64
i128	i128	i128
u8	u8	u8
u16	u16	u16
u32	u32	u32
u64	u64	u64
u128	u128	u128
Back to Top

Comparators
gt
let a: bool = 2u8 > 1u8; // true
let b: bool = 1u8.gt(1u8); // false

Checks if first is greater than second, storing the result in destination.

Supported Types
First	Second	Destination
field	field	bool
i8	i8	bool
i16	i16	bool
i32	i32	bool
i64	i64	bool
i128	i128	bool
u8	u8	bool
u16	u16	bool
u32	u32	bool
u64	u64	bool
u128	u128	bool
scalar	scalar	bool
Back to Top

gte
let a: bool = 2u8 >= 1u8; // true
let b: bool = 1u8.gte(1u8); // true

Checks if first is greater than or equal to second, storing the result in destination.

Supported Types
First	Second	Destination
field	field	bool
i8	i8	bool
i16	i16	bool
i32	i32	bool
i64	i64	bool
i128	i128	bool
u8	u8	bool
u16	u16	bool
u32	u32	bool
u64	u64	bool
u128	u128	bool
scalar	scalar	bool
Back to Top

eq
let a: bool = 1u8 == 1u8; // true
let b: bool = 1u8.eq(2u8); // false

Compares first and second for equality, storing the result in destination.

Supported Types
First	Second	Destination
address	address	bool
bool	bool	bool
field	field	bool
group	group	bool
i8	i8	bool
i16	i16	bool
i32	i32	bool
i64	i64	bool
i128	i128	bool
u8	u8	bool
u16	u16	bool
u32	u32	bool
u64	u64	bool
u128	u128	bool
scalar	scalar	bool
Signature	Signature	bool
struct	struct	bool
Record	Record	bool
Back to Top

neq
let a: bool = 1u8 != 1u8; // false
let b: bool = 1u8.neq(2u8); // true

Compares first and second for non-equality, storing the result in destination.

Supported Types
First	Second	Destination
address	address	bool
bool	bool	bool
field	field	bool
group	group	bool
i8	i8	bool
i16	i16	bool
i32	i32	bool
i64	i64	bool
i128	i128	bool
u8	u8	bool
u16	u16	bool
u32	u32	bool
u64	u64	bool
u128	u128	bool
scalar	scalar	bool
Signature	Signature	bool
struct	struct	bool
Record	Record	bool
Back to Top

lt
let a: bool = 1u8 < 2u8; // true
let b: bool = 1u8.lt(1u8); // false

Checks if first is less than second, storing the result in destination.

Supported Types
First	Second	Destination
field	field	bool
i8	i8	bool
i16	i16	bool
i32	i32	bool
i64	i64	bool
i128	i128	bool
u8	u8	bool
u16	u16	bool
u32	u32	bool
u64	u64	bool
u128	u128	bool
scalar	scalar	bool
Back to Top

lte
let a: bool = 1u8 <= 2u8; // true
let b: bool = 1u8.lte(1u8); // true

Checks if first is less than or equal to second, storing the result in destination.

Supported Types
First	Second	Destination
field	field	bool
i8	i8	bool
i16	i16	bool
i32	i32	bool
i64	i64	bool
i128	i128	bool
u8	u8	bool
u16	u16	bool
u32	u32	bool
u64	u64	bool
u128	u128	bool
scalar	scalar	bool
Back to Top

Context-dependent Expressions
block.height
async transition matches(height: u32) -> Future {
    return check_block_height(height);
} 

async function check_block_height(height: u32) {
    assert_eq(height, block.height);
}

The block.height operator is used to fetch the latest block height in a Leo program. It represents the number of blocks in the chain. In the above example, block.height is used in an async function to fetch the latest block height in a program.

info
The block.height operator can only be used in an async function. Using it outside an async function will result in a compilation error.
The block.height operator doesn't take any parameters.
Back to Top

block.timestamp
async transition matches(timestamp: i64) -> Future {
    return check_block_timestamp(timestamp);
} 

async function check_block_timestamp(timestamp: i64) {
    assert_eq(timestamp, block.timestamp);
}


The block.timestamp operator is used to fetch the timestamp of the latest block in a Leo program. It represents the number of UNIX timestamp of the latest block in the chain. In the above example, block.timestamp is used in an async function to fetch the latest block height in a program.

info
The block.timestamp operator can only be used in an async function. Using it outside an async function will result in a compilation error.
The block.timestamp operator doesn't take any parameters.
Back to Top

self.address
transition get_program_address() -> address {
    return self.address;
}

The self.address operator returns the address of the program that calls it. While programs are identified by their name ({PROGRAM_NAME}.aleo), under the hood they have a corresponding Aleo address.

info
The self.address operator doesn't take any parameters.
Back to Top

self.caller
transition matches(addr: address) -> bool {
    return self.caller == addr;
}

The self.caller operator returns the address of the account/program that invoked the current transition. Note that if the transition was called as part of an external program, this operation will return the address of the program, NOT the address of the top-level user.

info
The self.caller operator doesn't take any parameters.
Back to Top

self.checksum
async transition matches(checksum: [u8,32]) -> Future {
    return check_program_checksum(checksum);
} 

async function check_program_checksum(checksum: [u8,32]) {
    assert_eq(self.checksum, checksum);
}


The self.checksum operator returns a program's checksum, which is a unique identifier for the program's code.

You may also refer to another program's checksum with the following syntax:

import credits.aleo;
...
let ext_checksum: [u8, 32] = Program::checksum(credits.aleo);


info
The self.checksum operator can only be used in an async function. Using it outside an async function will result in a compilation error.
The self.checksum operator doesn't take any parameters.
To reference another program's checksum, you will need to import that program first.
Back to Top

self.edition
async transition matches(edition: u16) -> Future {
    return check_program_edition(edition);
} 

async function check_program_edition(edition: u16) {
    assert_eq(self.edition, edition);
}


The self.edition operator returns a program's edition, which is the program's version number. A program's edition starts at zero and is incremented by one for each upgrade. The edition is tracked automatically on the network.

You may also refer to another program's edition with the following syntax:

import credits.aleo;
...
let ext_edition: u16 = Program::edition(credits.aleo);


info
The self.edition operator can only be used in an async function. Using it outside an async function will result in a compilation error.
The self.edition operator doesn't take any parameters.
To reference another program's edition, you will need to import that program first.
Back to Top

self.program_owner
async transition matches(owner: address) -> Future {
    return check_program_owner(owner);
} 

async function check_program_owner(owner: address) {
    assert_eq(self.program_owner, owner);
}


The self.program_owner operator returns the address that submitted the deployment transaction for a program. You may also refer to another program's owner with the following syntax:

import credits.aleo;
...
let ext_owner: u16 = Program::owner(credits.aleo);


info
The self.program_owner operator can only be used in an async function. Using it outside an async function will result in a compilation error.
The self.program_owner operator doesn't take any parameters.
To reference another program's owner, you will need to import that program first.
Back to Top

self.signer
transition matches(addr: address) -> bool {
    return self.signer == addr;
}

The self.signer operator returns the address of the account/program that invoked the top-level transition. This will be the user account that signed the transaction.

info
The self.signer operator doesn't take any parameters.
Back to Top

Group/Field Specific Operators
group::GEN
let g: group = group::GEN; // the group generator

Returns the generator of the algebraic group that the group type consists of.

The compilation of Leo is based on an elliptic curve, whose points form a group, and on a specified point on that curve, which generates a subgroup, whose elements form the type group.

This is a constant, not a function. Thus, it takes no inputs, and just returns an output.

It is an associated constant, whose name is GEN and whose associated type is group.

Supported Types
Destination
group
Back to Top

double
let a: group = 2group;
let b: group = a.double();

Adds the input to itself, storing the result in destination.

Supported Types
Input	Destination
field	field
group	group
Back to Top

inv
let a: field = 1field.inv();

Computes the multiplicative inverse of the input, storing the result in destination.

Supported Types
Input	Destination
field	field
Back to Top

square
let a: field = 1field.square(); // 1field

Squares the input, storing the result in destination.

Supported Types
Input	Destination
field	field
Back to Top

square_root
let a: field = 1field.square_root(); // 1field

Computes the square root of the input, storing the result in destination. If the input is a quadratic residue, the function returns the smaller of the two possible roots based on modular ordering. If the input is not a quadratic residue, execution halts.

Supported Types
Input	Destination
field	field
Back to Top

to_x_coordinate
let x: field = 0group.to_x_coordinate(); // 0field


Extracts the x-coordinate of the group element as a field element.

Supported Types
Input	Destination
group	field
Back to Top

to_y_coordinate
let y: field = 0group.to_y_coordinate(); // 1field


Extracts the y-coordinate of the group element as a field element.

Supported Types
Input	Destination
group	field
Back to Top

Serialization / Deserialization
Serialize::to_bits
// Standard serialization (includes type metadata)
let bits: [bool; 58] = Serialize::to_bits(value);

// Raw serialization (no metadata, just raw bits)
let bits: [bool; 32] = Serialize::to_bits_raw(value);

// Works with arrays too
let bits: [bool; 128] = Serialize::to_bits_raw([1u32, 2u32, 3u32, 4u32]);


By appending _raw to the end of the function, the function will omit the metadata of a type and directly serialize the input bits.

Supported Types
First	Destination	Destination (Raw)
address	[bool; 279]	[bool; 253]
bool	[bool; 27]	[bool; 1]
field	[bool; 279]	[bool; 253]
group	[bool; 279]	[bool; 253]
i8	[bool; 34]	[bool; 8]
i16	[bool; 42]	[bool; 16]
i32	[bool; 58]	[bool; 32]
i64	[bool; 90]	[bool; 64]
i128	[bool; 154]	[bool; 128]
u8	[bool; 34]	[bool; 8]
u16	[bool; 42]	[bool; 16]
u32	[bool; 58]	[bool; 32]
u64	[bool; 90]	[bool; 64]
u128	[bool; 154]	[bool; 128]
scalar	[bool; 277]	[bool; 251]
Back to Top

Deserialize::from_bits::[TYPE]
// Standard deserialization (includes type metadata)
let bits1: [bool; 58] = Serialize::to_bits(1u32);
let value1: u32 = Deserialize::from_bits::[u32](bits1);

// Raw deserialization (no metadata, just raw bits)
let bits2: [bool; 32] = Serialize::to_bits_raw(1u32);
let value2: u32 = Deserialize::from_bits_raw::[u32](bits2);

// Works with arrays too
let bits3: [bool; 128] = Serialize::to_bits_raw([1u32, 2u32, 3u32, 4u32]);
let arr: [u32; 4] = Deserialize::from_bits_raw::[[u32; 4]](bits3);


By appending _raw to the end of the function, the function will omit the metadata of a type and directly serialize the input bits.

Supported Types
TYPE	Input	Input (Raw)	Destination
address	[bool; 279]	[bool; 253]	address
bool	[bool; 27]	[bool; 1]	bool
field	[bool; 279]	[bool; 253]	field
group	[bool; 279]	[bool; 253]	group
i8	[bool; 34]	[bool; 8]	i8
i16	[bool; 42]	[bool; 16]	i16
i32	[bool; 58]	[bool; 32]	i32
i64	[bool; 90]	[bool; 64]	i64
i128	[bool; 154]	[bool; 128]	i128
u8	[bool; 34]	[bool; 8]	u8
u16	[bool; 42]	[bool; 16]	u16
u32	[bool; 58]	[bool; 32]	u32
u64	[bool; 90]	[bool; 64]	u64
u128	[bool; 154]	[bool; 128]	u128
scalar	[bool; 277]	[bool; 251]	scalar
Back to Top

Miscellaneous
assert
let a: bool = true;
let b: bool = false;

assert(a); // will not halt
assert(b); // program halts

Checks whether the expression evaluates to a true boolean value, halting if evaluates to false.

Supported Types
Expression
bool
Back to Top

assert_eq
let a: u8 = 1u8;
let b: u8 = 2u8;

assert_eq(a, a); // will not halt
assert_eq(a, b); // program halts

Checks whether first and second are equal, halting if they are not equal.

Supported Types
First	Second
address	address
bool	bool
field	field
group	group
i8	i8
i16	i16
i32	i32
i64	i64
i128	i128
u8	u8
u16	u16
u32	u32
u64	u64
u128	u128
scalar	scalar
Signature	Signature
struct	struct
Record	Record
Back to Top

assert_neq
let a: u8 = 1u8;
let b: u8 = 2u8;

assert_neq(a, b); // will not halt
assert_neq(a, a); // program halts

Checks whether first and second are not equal, halting if they are equal.

Supported Types
First	Second
address	address
bool	bool
field	field
group	group
i8	i8
i16	i16
i32	i32
i64	i64
i128	i128
u8	u8
u16	u16
u32	u32
u64	u64
u128	u128
scalar	scalar
Signature	Signature
struct	struct
Record	Record
Back to Top

ternary
let a: u8 = true ? 1u8 : 2u8; // 1u8

Selects first, if condition is true, otherwise selects second, storing the result in destination.

Supported Types
Condition	First	Second	Destination
bool	bool	bool	bool
bool	field	field	field
bool	group	group	group
bool	i8	i8	i8
bool	i16	i16	i16
bool	i32	i32	i32
bool	i64	i64	i64
bool	i128	i128	i128
bool	u8	u8	u8
bool	u16	u16	u16
bool	u32	u32	u32
bool	u64	u64	u64
bool	u128	u128	u128
bool	scalar	scalar	scalar
bool	Signature	Signature	Signature
Back to Top

Cryptographic Operators
Table of Contents
Name	Description
BHP256::hash_to_TYPE	256-bit input BHP hash
BHP256::commit_to_TYPE	256-bit input BHP commitment
BHP512::hash_to_TYPE	512-bit input BHP hash
BHP512::commit_to_TYPE	512-bit input BHP commitment
BHP768::hash_to_TYPE	768-bit input BHP hash
BHP768::commit_to_TYPE	768-bit input BHP commitment
BHP1024::hash_to_TYPE	1024-bit input BHP hash
BHP1024::commit_to_TYPE	1024-bit input BHP commitment
Pedersen64::hash_to_TYPE	64-bit input Pedersen hash
Pedersen64::commit_to_TYPE	64-bit input Pedersen commitment
Pedersen128::hash_to_TYPE	128-bit input Pedersen hash
Pedersen128::commit_to_TYPE	128-bit input Pedersen commitment
Poseidon2::hash_to_TYPE	Poseidon hash with input rate 2
Poseidon4::hash_to_TYPE	Poseidon hash with input rate 4
Poseidon8::hash_to_TYPE	Poseidon hash with input rate 8
Keccak256::hash_to_bits	256-bit input/output Keccak hash
Keccak256::hash_to_TYPE	256-bit input Keccak hash
Keccak384::hash_to_bits	384-bit input/output Keccak hash
Keccak384::hash_to_TYPE	384-bit input Keccak hash
Keccak512::hash_to_bits	512-bit input/output Keccak hash
Keccak512::hash_to_TYPE	512-bit input Keccak hash
SHA3_256::hash_to_bits	256-bit input/output SHA3 hash
SHA3_256::hash_to_TYPE	256-bit input SHA3 hash
SHA3_384::hash_to_bits	384-bit input/output SHA3 hash
SHA3_384::hash_to_TYPE	384-bit input SHA3 hash
SHA3_512::hash_to_bits	512-bit input/output SHA3 hash
SHA3_512::hash_to_TYPE	512-bit input SHA3 hash
ChaCha::rand_TYPE	ChaCha RNG
signature::verify	Verify a Schnorr signature
ECDSA::verify_digest	Verify an ECDSA signature against a pre-hash
ECDSA::verify_keccak256	Verify an ECDSA signature using Keccak256
ECDSA::verify_keccak384	Verify an ECDSA signature using Keccak384
ECDSA::verify_keccak512	Verify an ECDSA signature using Keccak512
ECDSA::verify_sha3_256	Verify an ECDSA signature using SHA3_256
ECDSA::verify_sha3_384	Verify an ECDSA signature using SHA3_384
ECDSA::verify_sha3_512	Verify an ECDSA signature using SHA3_512
Bowe-Hopwood-Pedersen (BHP)
BHP256::hash_to_TYPE
let result: address = BHP256::hash_to_address(1u8);
let result: field = BHP256::hash_to_field(2i64);
let result: group = BHP256::hash_to_group(1field);
let result: scalar = BHP256::hash_to_scalar(1field);
let result: i8 = BHP256::hash_to_i8(1field);
let result: i16 = BHP256::hash_to_i16(1field);
let result: i32 = BHP256::hash_to_i32(1field);
let result: i64 = BHP256::hash_to_i64(1field);
let result: i128 = BHP256::hash_to_i128(1field);
let result: u8 = BHP256::hash_to_u8(1field);
let result: u16 = BHP256::hash_to_u16(1field);
let result: u32 = BHP256::hash_to_u32(1field);
let result: u64 = BHP256::hash_to_u64(1field);
let result: u128 = BHP256::hash_to_u128(1field);

// Raw hash variants
let result: address = BHP256::hash_to_address_raw(1u8);
let result: field = BHP256::hash_to_field_raw(2i64);
                        ...


Computes a Bowe-Hopwood-Pedersen hash on inputs of 256-bit chunks in first, storing the hash in destination. The produced hash will be an arithmetic (u8, u16, u32, u64, u128, i8, i16, i32,i64,i128, field, group, or scalar) or address value, as specified via hash_to_TYPE at the end of the function.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

The instruction will halt if the given input is smaller than 129 bits.

Supported Types
First	Destination
address	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
bool	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
field	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
group	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
scalar	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
struct	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
Back to Top

BHP256::commit_to_TYPE
let salt: scalar = ChaCha::rand_scalar();
let a: address = BHP256::commit_to_address(1u8, salt);
let b: field = BHP256::commit_to_field(2i64, salt);
let c: group = BHP256::commit_to_group(1field, salt);


Computes a Bowe-Hopwood-Pedersen commitment on inputs of 256-bit chunks in first, and some randomness in second, storing the commitment in destination. Randomness should always be a scalar value, and the produced commitment can be an address, field or, group value.

The instruction will halt if the given input is smaller than 129 bits.

Supported Types
First	Second	Destination
address	scalar	address, field, group
bool	scalar	address, field, group
field	scalar	address, field, group
group	scalar	address, field, group
i8	scalar	address, field, group
i16	scalar	address, field, group
i32	scalar	address, field, group
i64	scalar	address, field, group
i128	scalar	address, field, group
u8	scalar	address, field, group
u16	scalar	address, field, group
u32	scalar	address, field, group
u64	scalar	address, field, group
u128	scalar	address, field, group
scalar	scalar	address, field, group
struct	scalar	address, field, group
Back to Top

BHP512::hash_to_TYPE
let result: address = BHP512::hash_to_address(1u8);
let result: field = BHP512::hash_to_field(2i64);
let result: group = BHP512::hash_to_group(1field);
let result: scalar = BHP512::hash_to_scalar(1field);
let result: i8 = BHP512::hash_to_i8(1field);
let result: i16 = BHP512::hash_to_i16(1field);
let result: i32 = BHP512::hash_to_i32(1field);
let result: i64 = BHP512::hash_to_i64(1field);
let result: i128 = BHP512::hash_to_i128(1field);
let result: u8 = BHP512::hash_to_u8(1field);
let result: u16 = BHP512::hash_to_u16(1field);
let result: u32 = BHP512::hash_to_u32(1field);
let result: u64 = BHP512::hash_to_u64(1field);
let result: u128 = BHP512::hash_to_u128(1field);

// Raw hash variants
let result: address = BHP512::hash_to_address_raw(1u8);
let result: field = BHP512::hash_to_field_raw(2i64);
                        ...


Computes a Bowe-Hopwood-Pedersen hash on inputs of 512-bit chunks in first, storing the hash in destination. The produced hash will always be an arithmetic (u8, u16, u32, u64, u128, i8, i16, i32,i64,i128, field, group, or scalar) or address value, as specified via hash_to_TYPE at the end of the function.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

The instruction will halt if the given input is smaller than 171 bits.

Supported Types
First	Destination
address	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
bool	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
field	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
group	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
scalar	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
struct	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
Back to Top

BHP512::commit_to_TYPE
let salt: scalar = ChaCha::rand_scalar();
let a: address = BHP512::commit_to_address(1u8, salt);
let b: field = BHP512::commit_to_field(2i64, salt);
let c: group = BHP512::commit_to_group(1field, salt);


Computes a Bowe-Hopwood-Pedersen commitment on inputs of 512-bit chunks in first, and some randomness in second, storing the commitment in destination. Randomness should always be a scalar value, and the produced commitment will always be a group value.

The instruction will halt if the given input is smaller than 171 bits.

Supported Types
First	Second	Destination
address	scalar	address, field, group
bool	scalar	address, field, group
field	scalar	address, field, group
group	scalar	address, field, group
i8	scalar	address, field, group
i16	scalar	address, field, group
i32	scalar	address, field, group
i64	scalar	address, field, group
i128	scalar	address, field, group
u8	scalar	address, field, group
u16	scalar	address, field, group
u32	scalar	address, field, group
u64	scalar	address, field, group
u128	scalar	address, field, group
scalar	scalar	address, field, group
struct	scalar	address, field, group
Back to Top

BHP768::hash_to_TYPE
let result: address = BHP768::hash_to_address(1u8);
let result: field = BHP768::hash_to_field(2i64);
let result: group = BHP768::hash_to_group(1field);
let result: scalar = BHP768::hash_to_scalar(1field);
let result: i8 = BHP768::hash_to_i8(1field);
let result: i16 = BHP768::hash_to_i16(1field);
let result: i32 = BHP768::hash_to_i32(1field);
let result: i64 = BHP768::hash_to_i64(1field);
let result: i128 = BHP768::hash_to_i128(1field);
let result: u8 = BHP768::hash_to_u8(1field);
let result: u16 = BHP768::hash_to_u16(1field);
let result: u32 = BHP768::hash_to_u32(1field);
let result: u64 = BHP768::hash_to_u64(1field);
let result: u128 = BHP768::hash_to_u128(1field);

// Raw hash variants
let result: address = BHP768::hash_to_address_raw(1u8);
let result: field = BHP768::hash_to_field_raw(2i64);
                        ...


Computes a Bowe-Hopwood-Pedersen hash on inputs of 768-bit chunks in first, storing the hash in destination. The produced hash will always be an arithmetic (u8, u16, u32, u64, u128, i8, i16, i32,i64,i128, field, group, or scalar) or address value, as specified via hash_to_TYPE at the end of the function.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

The instruction will halt if the given input is smaller than 129 bits.

Supported Types
First	Destination
address	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
bool	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
field	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
group	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
scalar	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
struct	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
Back to Top

BHP768::commit_to_TYPE
let salt: scalar = ChaCha::rand_scalar();
let a: address = BHP768::commit_to_address(1u8, salt);
let b: field = BHP768::commit_to_field(2i64, salt);
let c: group = BHP768::commit_to_group(1field, salt);


Computes a Bowe-Hopwood-Pedersen commitment on inputs of 768-bit chunks in first, and some randomness in second, storing the commitment in destination. Randomness should always be a scalar value, and the produced commitment will always be a group value.

The instruction will halt if the given input is smaller than 129 bits.

Supported Types
First	Second	Destination
address	scalar	address, field, group
bool	scalar	address, field, group
field	scalar	address, field, group
group	scalar	address, field, group
i8	scalar	address, field, group
i16	scalar	address, field, group
i32	scalar	address, field, group
i64	scalar	address, field, group
i128	scalar	address, field, group
u8	scalar	address, field, group
u16	scalar	address, field, group
u32	scalar	address, field, group
u64	scalar	address, field, group
u128	scalar	address, field, group
scalar	scalar	address, field, group
struct	scalar	address, field, group
Back to Top

BHP1024::hash_to_TYPE
let result: address = BHP1024::hash_to_address(1u8);
let result: field = BHP1024::hash_to_field(2i64);
let result: group = BHP1024::hash_to_group(1field);
let result: scalar = BHP1024::hash_to_scalar(1field);
let result: i8 = BHP1024::hash_to_i8(1field);
let result: i16 = BHP1024::hash_to_i16(1field);
let result: i32 = BHP1024::hash_to_i32(1field);
let result: i64 = BHP1024::hash_to_i64(1field);
let result: i128 = BHP1024::hash_to_i128(1field);
let result: u8 = BHP1024::hash_to_u8(1field);
let result: u16 = BHP1024::hash_to_u16(1field);
let result: u32 = BHP1024::hash_to_u32(1field);
let result: u64 = BHP1024::hash_to_u64(1field);
let result: u128 = BHP1024::hash_to_u128(1field);

// Raw hash variants
let result: address = BHP1024::hash_to_address_raw(1u8);
let result: field = BHP1024::hash_to_field_raw(2i64);
                        ...


Computes a Bowe-Hopwood-Pedersen hash on inputs of 1024-bit chunks in first, storing the hash in destination. The produced hash will always be an arithmetic (u8, u16, u32, u64, u128, i8, i16, i32,i64,i128, field, group, or scalar) or address value, as specified via hash_to_TYPE at the end of the function.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

The instruction will halt if the given input is smaller than 171 bits.

Supported Types
First	Destination
address	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
bool	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
field	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
group	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
scalar	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
struct	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
Back to Top

BHP1024::commit_to_TYPE
let salt: scalar = ChaCha::rand_scalar();
let a: address = BHP1024::commit_to_address(1u8, salt);
let b: field = BHP1024::commit_to_field(2i64, salt);
let c: group = BHP1024::commit_to_group(1field, salt);


Computes a Bowe-Hopwood-Pedersen commitment on inputs of 1024-bit chunks in first, and some randomness in second, storing the commitment in destination. Randomness should always be a scalar value, and the produced commitment will always be a group value.

The instruction will halt if the given input is smaller than 171 bits.

Supported Types
First	Second	Destination
address	scalar	address, field, group
bool	scalar	address, field, group
field	scalar	address, field, group
group	scalar	address, field, group
i8	scalar	address, field, group
i16	scalar	address, field, group
i32	scalar	address, field, group
i64	scalar	address, field, group
i128	scalar	address, field, group
u8	scalar	address, field, group
u16	scalar	address, field, group
u32	scalar	address, field, group
u64	scalar	address, field, group
u128	scalar	address, field, group
scalar	scalar	address, field, group
struct	scalar	address, field, group
Back to Top

Pedersen
Pedersen64::hash_to_TYPE
let result: address = Pedersen64::hash_to_address(1u8);
let result: field = Pedersen64::hash_to_field(2i64);
let result: group = Pedersen64::hash_to_group(1field);
let result: scalar = Pedersen64::hash_to_scalar(1field);
let result: i8 = Pedersen64::hash_to_i8(1field);
let result: i16 = Pedersen64::hash_to_i16(1field);
let result: i32 = Pedersen64::hash_to_i32(1field);
let result: i64 = Pedersen64::hash_to_i64(1field);
let result: i128 = Pedersen64::hash_to_i128(1field);
let result: u8 = Pedersen64::hash_to_u8(1field);
let result: u16 = Pedersen64::hash_to_u16(1field);
let result: u32 = Pedersen64::hash_to_u32(1field);
let result: u64 = Pedersen64::hash_to_u64(1field);
let result: u128 = Pedersen64::hash_to_u128(1field);

// Raw hash variants
let result: address = Pedersen64::hash_to_address_raw(1u8);
let result: field = Pedersen64::hash_to_field_raw(2i64);
                        ...


Computes a Pedersen hash up to a 64-bit input in first, storing the hash in destination. The produced hash will always be an arithmetic (u8, u16, u32, u64, u128, i8, i16, i32,i64,i128, field, group, or scalar) or address value, as specified via hash_to_TYPE at the end of the function.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

The instruction will halt if the given struct value exceeds the 64-bit limit.

Supported Types
First	Destination
bool	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
struct	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
Back to Top

Pedersen64::commit_to_TYPE
let salt: scalar = ChaCha::rand_scalar();
let a: address = Pedersen64::commit_to_address(1u8, salt);
let b: field = Pedersen64::commit_to_field(2i64, salt);
let c: group = Pedersen64::commit_to_group(1field, salt);


Computes a Pedersen commitment up to a 64-bit input in first, and some randomness in second, storing the commitment in destination. Randomness should always be a scalar value, and the produced commitment will always be a group value.

The instruction will halt if the given struct value exceeds the 64-bit limit.

Supported Types
First	Second	Destination
bool	scalar	address, field, group
i8	scalar	address, field, group
i16	scalar	address, field, group
i32	scalar	address, field, group
u8	scalar	address, field, group
u16	scalar	address, field, group
u32	scalar	address, field, group
struct	scalar	address, field, group
Back to Top

Pedersen128::hash_to_TYPE
let result: address = Pedersen128::hash_to_address(1u8);
let result: field = Pedersen128::hash_to_field(2i64);
let result: group = Pedersen128::hash_to_group(1field);
let result: scalar = Pedersen128::hash_to_scalar(1field);
let result: i8 = Pedersen128::hash_to_i8(1field);
let result: i16 = Pedersen128::hash_to_i16(1field);
let result: i32 = Pedersen128::hash_to_i32(1field);
let result: i64 = Pedersen128::hash_to_i64(1field);
let result: i128 = Pedersen128::hash_to_i128(1field);
let result: u8 = Pedersen128::hash_to_u8(1field);
let result: u16 = Pedersen128::hash_to_u16(1field);
let result: u32 = Pedersen128::hash_to_u32(1field);
let result: u64 = Pedersen128::hash_to_u64(1field);
let result: u128 = Pedersen128::hash_to_u128(1field);

// Raw hash variants
let result: address = Pedersen128::hash_to_address_raw(1u8);
let result: field = Pedersen128::hash_to_field_raw(2i64);
                        ...


Computes a Pedersen hash up to a 128-bit input in first, storing the hash in destination. The produced hash will always be an arithmetic (u8, u16, u32, u64, u128, i8, i16, i32,i64,i128, field, group, or scalar) or address value, as specified via hash_to_TYPE at the end of the function.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

The instruction will halt if the given struct value exceeds the 64-bit limit.

Supported Types
First	Destination
bool	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
struct	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
Back to Top

Pedersen128::commit_to_TYPE
let salt: scalar = ChaCha::rand_scalar();
let a: address = Pedersen128::commit_to_address(1u8, salt);
let b: field = Pedersen128::commit_to_field(2i64, salt);
let c: group = Pedersen128::commit_to_group(1field, salt);


Computes a Pedersen commitment up to a 128-bit input in first, and some randomness in second, storing the commitment in destination. Randomness should always be a scalar value, and the produced commitment will always be a group value.

The instruction will halt if the given struct value exceeds the 128-bit limit.

Supported Types
First	Second	Destination
bool	scalar	address, field, group
i8	scalar	address, field, group
i16	scalar	address, field, group
i32	scalar	address, field, group
i64	scalar	address, field, group
u8	scalar	address, field, group
u16	scalar	address, field, group
u32	scalar	address, field, group
u64	scalar	address, field, group
struct	scalar	address, field, group
Back to Top

Poseidon
Poseidon2::hash_to_TYPE
let result: address = Poseidon2::hash_to_address(1u8);
let result: field = Poseidon2::hash_to_field(2i64);
let result: group = Poseidon2::hash_to_group(1field);
let result: scalar = Poseidon2::hash_to_scalar(1field);
let result: i8 = Poseidon2::hash_to_i8(1field);
let result: i16 = Poseidon2::hash_to_i16(1field);
let result: i32 = Poseidon2::hash_to_i32(1field);
let result: i64 = Poseidon2::hash_to_i64(1field);
let result: i128 = Poseidon2::hash_to_i128(1field);
let result: u8 = Poseidon2::hash_to_u8(1field);
let result: u16 = Poseidon2::hash_to_u16(1field);
let result: u32 = Poseidon2::hash_to_u32(1field);
let result: u64 = Poseidon2::hash_to_u64(1field);
let result: u128 = Poseidon2::hash_to_u128(1field);

// Raw hash variants
let result: address = Poseidon2::hash_to_address_raw(1u8);
let result: field = Poseidon2::hash_to_field_raw(2i64);
                        ...


Calculates a Poseidon hash with an input rate of 2, from an input in first, storing the hash in destination. The produced hash will always be an arithmetic (u8, u16, u32, u64, u128, i8, i16, i32,i64,i128, field, group, or scalar) or address value, as specified via hash_to_TYPE at the end of the function.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits. s

Supported Types
First	Destination
address	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
bool	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
field	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
group	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
scalar	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
struct	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
Back to Top

Poseidon4::hash_to_TYPE
let result: address = Poseidon4::hash_to_address(1u8);
let result: field = Poseidon4::hash_to_field(2i64);
let result: group = Poseidon4::hash_to_group(1field);
let result: scalar = Poseidon4::hash_to_scalar(1field);
let result: i8 = Poseidon4::hash_to_i8(1field);
let result: i16 = Poseidon4::hash_to_i16(1field);
let result: i32 = Poseidon4::hash_to_i32(1field);
let result: i64 = Poseidon4::hash_to_i64(1field);
let result: i128 = Poseidon4::hash_to_i128(1field);
let result: u8 = Poseidon4::hash_to_u8(1field);
let result: u16 = Poseidon4::hash_to_u16(1field);
let result: u32 = Poseidon4::hash_to_u32(1field);
let result: u64 = Poseidon4::hash_to_u64(1field);
let result: u128 = Poseidon4::hash_to_u128(1field);

// Raw hash variants
let result: address = Poseidon4::hash_to_address_raw(1u8);
let result: field = BHPPoseidon4256::hash_to_field_raw(2i64);
                        ...


Calculates a Poseidon hash with an input rate of 4, from an input in first, storing the hash in destination. The produced hash will always be an arithmetic (u8, u16, u32, u64, u128, i8, i16, i32,i64,i128, field, group, or scalar) or address value, as specified via hash_to_TYPE at the end of the function.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

Supported Types
First	Destination
address	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
bool	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
field	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
group	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
scalar	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
struct	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
Back to Top

Poseidon8::hash_to_TYPE
let result: address = Poseidon8::hash_to_address(1u8);
let result: field = Poseidon8::hash_to_field(2i64);
let result: group = Poseidon8::hash_to_group(1field);
let result: scalar = Poseidon8::hash_to_scalar(1field);
let result: i8 = Poseidon8::hash_to_i8(1field);
let result: i16 = Poseidon8::hash_to_i16(1field);
let result: i32 = Poseidon8::hash_to_i32(1field);
let result: i64 = Poseidon8::hash_to_i64(1field);
let result: i128 = Poseidon8::hash_to_i128(1field);
let result: u8 = Poseidon8::hash_to_u8(1field);
let result: u16 = Poseidon8::hash_to_u16(1field);
let result: u32 = Poseidon8::hash_to_u32(1field);
let result: u64 = Poseidon8::hash_to_u64(1field);
let result: u128 = Poseidon8::hash_to_u128(1field);

// Raw hash variants
let result: address = Poseidon8::hash_to_address_raw(1u8);
let result: field = Poseidon8::hash_to_field_raw(2i64);
                        ...


Calculates a Poseidon hash with an input rate of 8, from an input in first, storing the hash in destination. The produced hash will always be an arithmetic (u8, u16, u32, u64, u128, i8, i16, i32,i64,i128, field, group, or scalar) or address value, as specified via hash_to_TYPE at the end of the function.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

Supported Types
First	Destination
address	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
bool	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
field	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
group	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
scalar	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
struct	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
Back to Top

Keccak
Keccak256::hash_to_bits
let result: [bool; 256] = Keccak256::hash_to_bits(1u8);
let result: [bool; 256] = Keccak256::hash_to_bits(2i64);
let result: [bool; 256] = Keccak256::hash_to_bits(1field);
let result: [bool; 256] = Keccak256::hash_to_bits(1field);
let result: [bool; 256] = Keccak256::hash_to_bits(1field);
let result: [bool; 256] = Keccak256::hash_to_bits(1field);
let result: [bool; 256] = Keccak256::hash_to_bits(1field);
let result: [bool; 256] = Keccak256::hash_to_bits(1field);
let result: [bool; 256] = Keccak256::hash_to_bits(1field);
let result: [bool; 256] = Keccak256::hash_to_bits(1field);
let result: [bool; 256] = Keccak256::hash_to_bits(1field);
let result: [bool; 256] = Keccak256::hash_to_bits(1field);
let result: [bool; 256] = Keccak256::hash_to_bits(1field);
let result: [bool; 256] = Keccak256::hash_to_bits(1field);

// Raw hash variants
let result: [bool; 256] = Keccak256::hash_to_bits_raw(1u8);
let result: [bool; 256] = Keccak256::hash_to_bits_raw(2i64);
                        ...


Computes a Keccak256 hash on inputs of 256-bit chunks in first, storing the hash in destination. The produced hash will be an array of bits.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

Supported Types
First	Destination
address	[bool; 256]
bool	[bool; 256]
field	[bool; 256]
group	[bool; 256]
i8	[bool; 256]
i16	[bool; 256]
i32	[bool; 256]
i64	[bool; 256]
i128	[bool; 256]
u8	[bool; 256]
u16	[bool; 256]
u32	[bool; 256]
u64	[bool; 256]
u128	[bool; 256]
scalar	[bool; 256]
struct	[bool; 256]
Back to Top

Keccak256::hash_to_TYPE
let result: address = Keccak256::hash_to_address(1u8);
let result: field = Keccak256::hash_to_field(2i64);
let result: group = Keccak256::hash_to_group(1field);
let result: scalar = Keccak256::hash_to_scalar(1field);
let result: i8 = Keccak256::hash_to_i8(1field);
let result: i16 = Keccak256::hash_to_i16(1field);
let result: i32 = Keccak256::hash_to_i32(1field);
let result: i64 = Keccak256::hash_to_i64(1field);
let result: i128 = Keccak256::hash_to_i128(1field);
let result: u8 = Keccak256::hash_to_u8(1field);
let result: u16 = Keccak256::hash_to_u16(1field);
let result: u32 = Keccak256::hash_to_u32(1field);
let result: u64 = Keccak256::hash_to_u64(1field);
let result: u128 = Keccak256::hash_to_u128(1field);

// Raw hash variants
let result: address = Keccak256::hash_to_address_raw(1u8);
let result: field = Keccak256::hash_to_field_raw(2i64);
                        ...


Computes a Keccak256 hash on inputs of 256-bit chunks in first, storing the hash in destination. The produced hash will always be an arithmetic (u8, u16, u32, u64, u128, i8, i16, i32,i64,i128, field, group, or scalar) or address value, as specified via hash_to_TYPE at the end of the function.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

Supported Types
First	Destination
address	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
bool	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
field	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
group	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
scalar	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
struct	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
Back to Top

Keccak384::hash_to_bits
let result: [bool; 384] = Keccak384::hash_to_bits(1u8);
let result: [bool; 384] = Keccak384::hash_to_bits(2i64);
let result: [bool; 384] = Keccak384::hash_to_bits(1field);
let result: [bool; 384] = Keccak384::hash_to_bits(1field);
let result: [bool; 384] = Keccak384::hash_to_bits(1field);
let result: [bool; 384] = Keccak384::hash_to_bits(1field);
let result: [bool; 384] = Keccak384::hash_to_bits(1field);
let result: [bool; 384] = Keccak384::hash_to_bits(1field);
let result: [bool; 384] = Keccak384::hash_to_bits(1field);
let result: [bool; 384] = Keccak384::hash_to_bits(1field);
let result: [bool; 384] = Keccak384::hash_to_bits(1field);
let result: [bool; 384] = Keccak384::hash_to_bits(1field);
let result: [bool; 384] = Keccak384::hash_to_bits(1field);
let result: [bool; 384] = Keccak384::hash_to_bits(1field);

// Raw hash variants
let result: [bool; 384] = Keccak384::hash_to_bits_raw(1u8);
let result: [bool; 384] = Keccak384::hash_to_bits_raw(2i64);
                        ...


Computes a Keccak384 hash on inputs of 384-bit chunks in first, storing the hash in destination. The produced hash will be an array of bits.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

Supported Types
First	Destination
address	[bool; 384]
bool	[bool; 384]
field	[bool; 384]
group	[bool; 384]
i8	[bool; 384]
i16	[bool; 384]
i32	[bool; 384]
i64	[bool; 384]
i128	[bool; 384]
u8	[bool; 384]
u16	[bool; 384]
u32	[bool; 384]
u64	[bool; 384]
u128	[bool; 384]
scalar	[bool; 384]
struct	[bool; 384]
Back to Top

Keccak384::hash_to_TYPE
let result: address = Keccak384::hash_to_address(1u8);
let result: field = Keccak384::hash_to_field(2i64);
let result: group = Keccak384::hash_to_group(1field);
let result: scalar = Keccak384::hash_to_scalar(1field);
let result: i8 = Keccak384::hash_to_i8(1field);
let result: i16 = Keccak384::hash_to_i16(1field);
let result: i32 = Keccak384::hash_to_i32(1field);
let result: i64 = Keccak384::hash_to_i64(1field);
let result: i128 = Keccak384::hash_to_i128(1field);
let result: u8 = Keccak384::hash_to_u8(1field);
let result: u16 = Keccak384::hash_to_u16(1field);
let result: u32 = Keccak384::hash_to_u32(1field);
let result: u64 = Keccak384::hash_to_u64(1field);
let result: u128 = Keccak384::hash_to_u128(1field);

// Raw hash variants
let result: address = Keccak384::hash_to_address_raw(1u8);
let result: field = Keccak384::hash_to_field_raw(2i64);
                        ...


Computes a Keccak384 hash on inputs of 384-bit chunks in first, storing the hash in destination. The produced hash will always be an arithmetic (u8, u16, u32, u64, u128, i8, i16, i32,i64,i128, field, group, or scalar) or address value, as specified via hash_to_TYPE at the end of the function.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

Supported Types
First	Destination
address	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
bool	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
field	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
group	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
scalar	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
struct	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
Back to Top

Keccak512::hash_to_bits
let result: [bool; 512] = Keccak512::hash_to_bits(1u8);
let result: [bool; 512] = Keccak512::hash_to_bits(2i64);
let result: [bool; 512] = Keccak512::hash_to_bits(1field);
let result: [bool; 512] = Keccak512::hash_to_bits(1field);
let result: [bool; 512] = Keccak512::hash_to_bits(1field);
let result: [bool; 512] = Keccak512::hash_to_bits(1field);
let result: [bool; 512] = Keccak512::hash_to_bits(1field);
let result: [bool; 512] = Keccak512::hash_to_bits(1field);
let result: [bool; 512] = Keccak512::hash_to_bits(1field);
let result: [bool; 512] = Keccak512::hash_to_bits(1field);
let result: [bool; 512] = Keccak512::hash_to_bits(1field);
let result: [bool; 512] = Keccak512::hash_to_bits(1field);
let result: [bool; 512] = Keccak512::hash_to_bits(1field);
let result: [bool; 512] = Keccak512::hash_to_bits(1field);

// Raw hash variants
let result: [bool; 512] = Keccak512::hash_to_bits_raw(1u8);
let result: [bool; 512] = Keccak512::hash_to_bits_raw(2i64);
                        ...


Computes a Keccak512 hash on inputs of 512-bit chunks in first, storing the hash in destination. The produced hash will be an array of bits.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

Supported Types
First	Destination
address	[bool; 512]
bool	[bool; 512]
field	[bool; 512]
group	[bool; 512]
i8	[bool; 512]
i16	[bool; 512]
i32	[bool; 512]
i64	[bool; 512]
i128	[bool; 512]
u8	[bool; 512]
u16	[bool; 512]
u32	[bool; 512]
u64	[bool; 512]
u128	[bool; 512]
scalar	[bool; 512]
struct	[bool; 512]
Back to Top

Keccak512::hash_to_TYPE
let result: address = Keccak512::hash_to_address(1u8);
let result: field = Keccak512::hash_to_field(2i64);
let result: group = Keccak512::hash_to_group(1field);
let result: scalar = Keccak512::hash_to_scalar(1field);
let result: i8 = Keccak512::hash_to_i8(1field);
let result: i16 = Keccak512::hash_to_i16(1field);
let result: i32 = Keccak512::hash_to_i32(1field);
let result: i64 = Keccak512::hash_to_i64(1field);
let result: i128 = Keccak512::hash_to_i128(1field);
let result: u8 = Keccak512::hash_to_u8(1field);
let result: u16 = Keccak512::hash_to_u16(1field);
let result: u32 = Keccak512::hash_to_u32(1field);
let result: u64 = Keccak512::hash_to_u64(1field);
let result: u128 = Keccak512::hash_to_u128(1field);

// Raw hash variants
let result: address = Keccak512::hash_to_address_raw(1u8);
let result: field = Keccak512::hash_to_field_raw(2i64);
                        ...


Computes a Keccak512 hash on inputs of 512-bit chunks in first, storing the hash in destination. The produced hash will always be an arithmetic (u8, u16, u32, u64, u128, i8, i16, i32,i64,i128, field, group, or scalar) or address value, as specified via hash_to_TYPE at the end of the function.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

Supported Types
First	Destination
address	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
bool	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
field	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
group	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
scalar	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
struct	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
Back to Top

SHA3
SHA3_256::hash_to_bits
let result: [bool; 256] = SHA3_256::hash_to_bits(1u8);
let result: [bool; 256] = SHA3_256::hash_to_bits(2i64);
let result: [bool; 256] = SHA3_256::hash_to_bits(1field);
let result: [bool; 256] = SHA3_256::hash_to_bits(1field);
let result: [bool; 256] = SHA3_256::hash_to_bits(1field);
let result: [bool; 256] = SHA3_256::hash_to_bits(1field);
let result: [bool; 256] = SHA3_256::hash_to_bits(1field);
let result: [bool; 256] = SHA3_256::hash_to_bits(1field);
let result: [bool; 256] = SHA3_256::hash_to_bits(1field);
let result: [bool; 256] = SHA3_256::hash_to_bits(1field);
let result: [bool; 256] = SHA3_256::hash_to_bits(1field);
let result: [bool; 256] = SHA3_256::hash_to_bits(1field);
let result: [bool; 256] = SHA3_256::hash_to_bits(1field);
let result: [bool; 256] = SHA3_256::hash_to_bits(1field);

// Raw hash variants
let result: [bool; 256] = SHA3_256::hash_to_bits_raw(1u8);
let result: [bool; 256] = SHA3_256::hash_to_bits_raw(2i64);
                        ...


Computes a SHA3_256 hash from an input in first, storing the hash in destination. The produced hash will be an array of bits.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

Supported Types
First	Destination
address	[bool; 256]
bool	[bool; 256]
field	[bool; 256]
group	[bool; 256]
i8	[bool; 256]
i16	[bool; 256]
i32	[bool; 256]
i64	[bool; 256]
i128	[bool; 256]
u8	[bool; 256]
u16	[bool; 256]
u32	[bool; 256]
u64	[bool; 256]
u128	[bool; 256]
scalar	[bool; 256]
struct	[bool; 256]
Back to Top

SHA3_256::hash_to_TYPE
let result: address = SHA3_256::hash_to_address(1u8);
let result: field = SHA3_256::hash_to_field(2i64);
let result: group = SHA3_256::hash_to_group(1field);
let result: scalar = SHA3_256::hash_to_scalar(1field);
let result: i8 = SHA3_256::hash_to_i8(1field);
let result: i16 = SHA3_256::hash_to_i16(1field);
let result: i32 = SHA3_256::hash_to_i32(1field);
let result: i64 = SHA3_256::hash_to_i64(1field);
let result: i128 = SHA3_256::hash_to_i128(1field);
let result: u8 = SHA3_256::hash_to_u8(1field);
let result: u16 = SHA3_256::hash_to_u16(1field);
let result: u32 = SHA3_256::hash_to_u32(1field);
let result: u64 = SHA3_256::hash_to_u64(1field);
let result: u128 = SHA3_256::hash_to_u128(1field);

// Raw hash variants
let result: address = SHA3_256::hash_to_address_raw(1u8);
let result: field = SHA3_256::hash_to_field_raw(2i64);
                        ...


Calculates a SHA3_256 hash from an input in first, storing the hash in destination. The produced hash will always be an arithmetic (u8, u16, u32, u64, u128, i8, i16, i32,i64,i128, field, group, or scalar) or address value, as specified via hash_to_TYPE at the end of the function.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

Supported Types
First	Destination
address	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
bool	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
field	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
group	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
scalar	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
struct	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
Back to Top

SHA3_384::hash_to_bits
let result: [bool; 384] = SHA3_384::hash_to_bits(1u8);
let result: [bool; 384] = SHA3_384::hash_to_bits(2i64);
let result: [bool; 384] = SHA3_384::hash_to_bits(1field);
let result: [bool; 384] = SHA3_384::hash_to_bits(1field);
let result: [bool; 384] = SHA3_384::hash_to_bits(1field);
let result: [bool; 384] = SHA3_384::hash_to_bits(1field);
let result: [bool; 384] = SHA3_384::hash_to_bits(1field);
let result: [bool; 384] = SHA3_384::hash_to_bits(1field);
let result: [bool; 384] = SHA3_384::hash_to_bits(1field);
let result: [bool; 384] = SHA3_384::hash_to_bits(1field);
let result: [bool; 384] = SHA3_384::hash_to_bits(1field);
let result: [bool; 384] = SHA3_384::hash_to_bits(1field);
let result: [bool; 384] = SHA3_384::hash_to_bits(1field);
let result: [bool; 384] = SHA3_384::hash_to_bits(1field);

// Raw hash variants
let result: [bool; 384] = SHA3_384::hash_to_bits_raw(1u8);
let result: [bool; 384] = SHA3_384::hash_to_bits_raw(2i64);
                        ...


Computes a SHA3_384 hash from an input in in first, storing the hash in destination. The produced hash will be an array of bits.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

Supported Types
First	Destination
address	[bool; 384]
bool	[bool; 384]
field	[bool; 384]
group	[bool; 384]
i8	[bool; 384]
i16	[bool; 384]
i32	[bool; 384]
i64	[bool; 384]
i128	[bool; 384]
u8	[bool; 384]
u16	[bool; 384]
u32	[bool; 384]
u64	[bool; 384]
u128	[bool; 384]
scalar	[bool; 384]
struct	[bool; 384]
Back to Top

SHA3_384::hash_to_TYPE
let result: address = SHA3_384::hash_to_address(1u8);
let result: field = SHA3_384::hash_to_field(2i64);
let result: group = SHA3_384::hash_to_group(1field);
let result: scalar = SHA3_384::hash_to_scalar(1field);
let result: i8 = SHA3_384::hash_to_i8(1field);
let result: i16 = SHA3_384::hash_to_i16(1field);
let result: i32 = SHA3_384::hash_to_i32(1field);
let result: i64 = SHA3_384::hash_to_i64(1field);
let result: i128 = SHA3_384::hash_to_i128(1field);
let result: u8 = SHA3_384::hash_to_u8(1field);
let result: u16 = SHA3_384::hash_to_u16(1field);
let result: u32 = SHA3_384::hash_to_u32(1field);
let result: u64 = SHA3_384::hash_to_u64(1field);
let result: u128 = SHA3_384::hash_to_u128(1field);

// Raw hash variants
let result: address = SHA3_384::hash_to_address_raw(1u8);
let result: field = SHA3_384::hash_to_field_raw(2i64);
                        ...


Calculates a SHA3_384 hash from an input in first, storing the hash in destination. The produced hash will always be an arithmetic (u8, u16, u32, u64, u128, i8, i16, i32,i64,i128, field, group, or scalar) or address value, as specified via hash_to_TYPE at the end of the function.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

Supported Types
First	Destination
address	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
bool	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
field	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
group	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
scalar	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
struct	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
Back to Top

SHA3_512::hash_to_bits
let result: [bool; 512] = SHA3_512::hash_to_bits(1u8);
let result: [bool; 512] = SHA3_512::hash_to_bits(2i64);
let result: [bool; 512] = SHA3_512::hash_to_bits(1field);
let result: [bool; 512] = SHA3_512::hash_to_bits(1field);
let result: [bool; 512] = SHA3_512::hash_to_bits(1field);
let result: [bool; 512] = SHA3_512::hash_to_bits(1field);
let result: [bool; 512] = SHA3_512::hash_to_bits(1field);
let result: [bool; 512] = SHA3_512::hash_to_bits(1field);
let result: [bool; 512] = SHA3_512::hash_to_bits(1field);
let result: [bool; 512] = SHA3_512::hash_to_bits(1field);
let result: [bool; 512] = SHA3_512::hash_to_bits(1field);
let result: [bool; 512] = SHA3_512::hash_to_bits(1field);
let result: [bool; 512] = SHA3_512::hash_to_bits(1field);
let result: [bool; 512] = SHA3_512::hash_to_bits(1field);

// Raw hash variants
let result: [bool; 512] = SHA3_512::hash_to_bits_raw(1u8);
let result: [bool; 512] = SHA3_512::hash_to_bits_raw(2i64);
                        ...


Computes a SHA3_512 hash from an input in first, storing the hash in destination. The produced hash will be an array of bits.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

Supported Types
First	Destination
address	[bool; 512]
bool	[bool; 512]
field	[bool; 512]
group	[bool; 512]
i8	[bool; 512]
i16	[bool; 512]
i32	[bool; 512]
i64	[bool; 512]
i128	[bool; 512]
u8	[bool; 512]
u16	[bool; 512]
u32	[bool; 512]
u64	[bool; 512]
u128	[bool; 512]
scalar	[bool; 512]
struct	[bool; 512]
Back to Top

SHA3_512::hash_to_TYPE
let result: address = SHA3_512::hash_to_address(1u8);
let result: field = SHA3_512::hash_to_field(2i64);
let result: group = SHA3_512::hash_to_group(1field);
let result: scalar = SHA3_512::hash_to_scalar(1field);
let result: i8 = SHA3_512::hash_to_i8(1field);
let result: i16 = SHA3_512::hash_to_i16(1field);
let result: i32 = SHA3_512::hash_to_i32(1field);
let result: i64 = SHA3_512::hash_to_i64(1field);
let result: i128 = SHA3_512::hash_to_i128(1field);
let result: u8 = SHA3_512::hash_to_u8(1field);
let result: u16 = SHA3_512::hash_to_u16(1field);
let result: u32 = SHA3_512::hash_to_u32(1field);
let result: u64 = SHA3_512::hash_to_u64(1field);
let result: u128 = SHA3_512::hash_to_u128(1field);

// Raw hash variants
let result: address = SHA3_512::hash_to_address_raw(1u8);
let result: field = SHA3_512::hash_to_field_raw(2i64);
                        ...


Calculates a SHA3_512 hash from an input in first, storing the hash in destination. The produced hash will always be an arithmetic (u8, u16, u32, u64, u128, i8, i16, i32,i64,i128, field, group, or scalar) or address value, as specified via hash_to_TYPE at the end of the function.

By appending _raw to the end of the function, the hash function will omit metadata of a variable and directly hash the input bits.

Supported Types
First	Destination
address	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
bool	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
field	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
group	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
i128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u8	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u16	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u32	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u64	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
u128	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
scalar	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
struct	address, field, group, scalar, i8, i16, i32,i64,i128, u8, u16, u32, u64, u128
Back to Top

ChaCha
ChaCha::rand_TYPE
let result: address = ChaCha::rand_address();
let result: bool = ChaCha::rand_bool();
let result: field = ChaCha::rand_field();
let result: group = ChaCha::rand_group();
let result: i8 = ChaCha::rand_i8();
let result: i16 = ChaCha::rand_i16();
let result: i32 = ChaCha::rand_i32();
let result: i64 = ChaCha::rand_i64();
let result: i128 = ChaCha::rand_i128();
let result: u8 = ChaCha::rand_u8();
let result: u16 = ChaCha::rand_u16();
let result: u32 = ChaCha::rand_u32();
let result: u64 = ChaCha::rand_u64();
let result: u128 = ChaCha::rand_u128();
let result: scalar = ChaCha::rand_scalar();

Returns a random value with the destination type.

info
This operation can only be used in an async function.

Supported Types
Destination
address
bool
field
group
i8
i16
i32
i64
i128
u8
u16
u32
u64
u128
scalar
Back to Top

Schnorr Signatures
signature::verify
transition verify_field(s: signature, a: address, v: field) {
    let first: bool = signature::verify(s, a, v);
    let second: bool = s.verify(a, v);
    assert_eq(first, second);
}


Verifies that the signature first was signed by the address second with respect to the field third, storing the result in destination. This verification follows the Schnorr signature scheme, which is a digital signature algorithm where the signer generates a random nonce, commits to it, computes a challenge using a hash function, and produces a signature by combining the nonce, challenge, and private key. The verifier checks the validity by reconstructing the challenge and ensuring consistency with the public key and message.

Supported Types
A Message is any literal or struct type.

First	Second	Third	Destination
signature	address	Message	bool
Back to Top

ECDSA Signatures
ECDSA::verify_digest
let valid: bool = ECDSA::verify_digest(sig, addr, digest);
let valid: bool = ECDSA::verify_digest_eth(sig, eth_addr, digest);


Verifies that the signature first was signed by the private key corresponding to the address second with respect to the field third, storing the result in destination. This function assumes that value passed as third is the output from a hash function that was previously computed. The standard version of verify_digest assume that second is a 33-byte ECDSA public key, while the verify_digest_eth version assumes that second is a 20-byte Ethereum address.

This verification follows the ECDSA signature scheme; an algorithm widely used across many other blockchains and legacy systems.

Supported Types
First	Second	Second (Eth)	Third	Destination
[u8;65]	[u8; 33]	[u8; 20]	[u8; 32]	bool
Back to Top

ECDSA::verify_keccak256
let valid: bool = ECDSA::verify_keccak256(sig, addr, msg);
let valid: bool = ECDSA::verify_keccak256_raw(sig, addr, msg);
let valid: bool = ECDSA::verify_keccak256_eth(sig, eth_addr, msg);


Verifies that the signature first was signed by the private key corresponding to the address second with respect to the field third, storing the result in destination. This function assumes that value passed as third is the plaintext message bytes, which will be hashed using the Keccak256 algorithm. The standard version of verify_keccak256 will include the Aleo specific metadata alongside the input, while the verify_keccak256_raw version will exclude the metadata. The verify_keccak256_eth will both exclude the metadata and assume that second is a 20-byte Ethereum address.

This verification follows the ECDSA signature scheme; an algorithm widely used across many other blockchains and legacy systems.

Supported Types
A Message is any byte-aligned type.

First	Second	Second (Eth)	Third	Destination
[u8;65]	[u8; 33]	[u8; 20]	Message	bool
Back to Top

ECDSA::verify_keccak384
let valid: bool = ECDSA::verify_keccak384(sig, addr, msg);
let valid: bool = ECDSA::verify_keccak384_raw(sig, addr, msg);
let valid: bool = ECDSA::verify_keccak384_eth(sig, eth_addr, msg);


Verifies that the signature first was signed by the private key corresponding to the address second with respect to the field third, storing the result in destination. This function assumes that value passed as third is the plaintext message bytes, which will be hashed using the Keccak384 algorithm. The standard version of verify_keccak384 will include the Aleo specific metadata alongside the input, while the verify_keccak384_raw version will exclude the metadata. The verify_keccak384_eth will both exclude the metadata and assume that second is a 20-byte Ethereum address.

This verification follows the ECDSA signature scheme; an algorithm widely used across many other blockchains and legacy systems.

Supported Types
A Message is any byte-aligned type.

First	Second	Second (Eth)	Third	Destination
[u8;65]	[u8; 33]	[u8; 20]	Message	bool
Back to Top

ECDSA::verify_keccak512
let valid: bool = ECDSA::verify_keccak512(sig, addr, msg);
let valid: bool = ECDSA::verify_keccak512_raw(sig, addr, msg);
let valid: bool = ECDSA::verify_keccak512_eth(sig, eth_addr, msg);


Verifies that the signature first was signed by the private key corresponding to the address second with respect to the field third, storing the result in destination. This function assumes that value passed as third is the plaintext message bytes, which will be hashed using the Keccak512 algorithm. The standard version of verify_keccak512 will include the Aleo specific metadata alongside the input, while the verify_keccak512_raw version will exclude the metadata. The verify_keccak512_eth will both exclude the metadata and assume that second is a 20-byte Ethereum address.

This verification follows the ECDSA signature scheme; an algorithm widely used across many other blockchains and legacy systems.

Supported Types
A Message is any byte-aligned type.

First	Second	Second (Eth)	Third	Destination
[u8;65]	[u8; 33]	[u8; 20]	Message	bool
Back to Top

ECDSA::verify_sha3_256
let valid: bool = ECDSA::verify_sha3_256(sig, addr, msg);
let valid: bool = ECDSA::verify_sha3_256_raw(sig, addr, msg);
let valid: bool = ECDSA::verify_sha3_256_eth(sig, eth_addr, msg);


Verifies that the signature first was signed by the private key corresponding to the address second with respect to the field third, storing the result in destination. This function assumes that value passed as third is the plaintext message bytes, which will be hashed using the SHA3_256 algorithm. The standard version of verify_sha3_256 will include the Aleo specific metadata alongside the input, while the verify_sha3_256_raw version will exclude the metadata. The verify_sha3_256_eth will both exclude the metadata and assume that second is a 20-byte Ethereum address.

This verification follows the ECDSA signature scheme; an algorithm widely used across many other blockchains and legacy systems.

Supported Types
A Message is any byte-aligned type.

First	Second	Second (Eth)	Third	Destination
[u8;65]	[u8; 33]	[u8; 20]	Message	bool
Back to Top

ECDSA::verify_sha3_384
let valid: bool = ECDSA::verify_sha3_384(sig, addr, msg);
let valid: bool = ECDSA::verify_sha3_384_raw(sig, addr, msg);
let valid: bool = ECDSA::verify_sha3_384_eth(sig, eth_addr, msg);


Verifies that the signature first was signed by the private key corresponding to the address second with respect to the field third, storing the result in destination. This function assumes that value passed as third is the plaintext message bytes, which will be hashed using the SHA3_384 algorithm. The standard version of verify_sha3_384 will include the Aleo specific metadata alongside the input, while the verify_sha3_384_raw version will exclude the metadata. The verify_sha3_384_eth will both exclude the metadata and assume that second is a 20-byte Ethereum address.

This verification follows the ECDSA signature scheme; an algorithm widely used across many other blockchains and legacy systems.

Supported Types
A Message is any byte-aligned type.

First	Second	Second (Eth)	Third	Destination
[u8;65]	[u8; 33]	[u8; 20]	Message	bool
Back to Top

ECDSA::verify_sha3_512
let valid: bool = ECDSA::verify_sha3_512(sig, addr, msg);
let valid: bool = ECDSA::verify_sha3_512_raw(sig, addr, msg);
let valid: bool = ECDSA::verify_sha3_512_eth(sig, eth_addr, msg);


Verifies that the signature first was signed by the private key corresponding to the address second with respect to the field third, storing the result in destination. This function assumes that value passed as third is the plaintext message bytes, which will be hashed using the SHA3_512 algorithm. The standard version of verify_sha3_512 will include the Aleo specific metadata alongside the input, while the verify_sha3_512_raw version will exclude the metadata. The verify_sha3_512_eth will both exclude the metadata and assume that second is a 20-byte Ethereum address.

This verification follows the ECDSA signature scheme; an algorithm widely used across many other blockchains and legacy systems.

Supported Types
A Message is any byte-aligned type.

First	Second	Second (Eth)	Third	Destination
[u8;65]	[u8; 33]	[u8; 20]	Message	bool
Back to Top


Best Practices
This guide is provided to point developers in the right direction when writing Leo code. There are many conventions that are unique to the Leo language and the circuits it generates.

This guide is a living document. As new Leo programming conventions arise and old ones become obsolete this guide should reflect the changes. Feel free to add your comments and recommendations here.

Content
Conditional Branches
The Leo compiler rewrites if-else statements inside transitions into a sequence of ternary expressions. This is because the underlying circuit construction does not support branching. For precise control over the circuit size, it is recommended to use ternary expressions directly.

If-Else:
if (condition) {
    return a;
} else {
    return b;
} 

Ternary:
return condition ? a : b;

Why?
Ternary expressions are the cheapest form of conditional. We can resolve the first expression and second expression values before evaluating the condition. This is very easy to convert into a circuit because we know that each expression does not depend on information in later statements.

In the original Example, We cannot resolve the return statements before evaluating the condition. As a solution, Leo creates branches in the circuit so both paths can be evaluated.

branch 1, condition = true
return a;

branch 2, condition = false
return b;

When the input value condition is fetched at proving time, we select a branch of the circuit to evaluate. Observe that the statement return a is repeated in both branches. The cost of every computation within the conditional will be doubled. This greatly increases the constraint numbers and slows down the circuit.

Async Functions vs. Blocks
For code conciseness and readability, prefer using async blocks rather than a separately declared async function:

Async Function:
mapping accumulator: u8 => u64;

async transition increment_accumulator() -> Future {
    return increment_state_onchain();
}
async function increment_accumulator_onchain(){
    let current_count: u64 = accumulator.get_or_use(0u8, 0u64);
    let new_count: u64 = current_count + 1u64;
    accumulator.set(0u8, new_count);

}


Async Block:
mapping accumulator: u8 => u64;

async transition increment_accumulator() -> Future {
    let f : Future = async {
        let current_count: u64 = accumulator.get_or_use(0u8, 0u64);
        let new_count: u64 = current_count + 1u64;
        accumulator.set(0u8, new_count);
    }
    return f;
}


Modules
For maximal code cleanliness and readability, take full advantage of Leo's module system:

src
â”œâ”€â”€ constants.leo
â”œâ”€â”€ utils.leo
â”œâ”€â”€ structs.leo
â””â”€â”€ main.leo

With the above structure, consider the following:

Move all consts to the constants.leo module
Move all inline functions to the utils.leo module
Move some structs to modules (but this may not make sense in the general case)
The goal is to only have the interface of the program in main.leo. Every function should correspond to something than can be called from an external context such as another program. Note that there is no impact on final program size since modules are flattened into a single program eventually anyways.

Layout
Indentation
4 spaces per indentation level.

Blank lines
A single blank line should separate the top-level declarations in a program scope, namely transition, function, struct, record, and mapping declarations. Multiple imports can be optionally separated by a single blank line; the last import at the top of the file should be followed by a blank line.

Yes:
import std.io.Write;
import std.math.Add;

program prog.aleo {

    struct A {
        // ...
    }

    function foo() {
        // ...
    }

}

No:
import std.io.Write;


import std.math.Add;
program prog.aleo {
    struct A {
        // ...
    }
    function foo() {
        // ...
    }
}

Naming Conventions
Item	Convention
Packages	snake_case (but prefer single word)
Structs and Records	CamelCase
Struct and Record Members	snake_case
Functions	snake_case
Function Parameters	snake_case
Variables	snake_case
Inputs	snake_case
Layout
Leo file elements should be ordered:

Imports
Program declaration
Mappings
Records + Structs
Functions + Transitions
Braces
Opening braces always go on the same line.

struct A {
    // ...
}

transition main() {
    // ...
}

let a: A = A { };

Semicolons
Every statement including the return statement should end in a semicolon.

let a: u32 = 1u32;
let b: u32 = a + 5u32;
b *= 2u32;

return b;

Commas
Trailing commas should be included whenever the closing delimiter appears on a separate line.

let a: A = A { x: 0, y: 1 };

let a: A = A {
    x: 0,
    y: 1,
};

Contributing
Thank you for helping make Leo better!

Before contributing, please view the Contributor Code of Conduct. By participating in this project - In the issues, pull requests, or Gitter channels - you agree to abide by the terms.

Report an Issue
To report an issue, please use the GitHub issues tracker. When reporting issues, please mention the following details:

Which version of Leo you are using.
What was the source code (if applicable).
Which platform are you running on.
How to reproduce the issue.
What was the result of the issue.
What the expected behavior is.
Reducing the source code that caused the issue to a bare minimum is always very helpful and sometimes clarifies a misunderstanding.

Make a Pull Request
Start by forking off of the mainnet branch to make your changes. Commit messages should clearly explain why and what you changed.

If you need to pull in any changes from the mainnet branch after making your fork (for example, to resolve potential merge conflicts), please avoid using git merge and instead, git rebase your branch. Rebasing will help us review your changes easily.

Tools Required
To build Leo from source you will need the following tools:

The latest Rust stable version and nightly version.
Recommend that you install multiple versions using rustup.
Cargo
Rusty Hook install via cargo install rusty-hook.
Clippy
Via rustup, if you didn't do the default rustup install rustup component add clippy.
Formatting
Please do the following before opening a PR.

cargo +nightly fmt --all will format all your code.
cargo clippy --all-features --examples --all --benches
Tests
If your code adds new functionality, please write tests to confirm the new features function as expected. Refer to existing tests for examples of how tests are expected to be written. Please read refer to the parser tests section. To run the tests please use the following command cargo test --all --features ci_skip --no-fail-fast.

Parser Tests
In the root directory of the repository, there is a "tests" directory. To add a parser test, look at the Example Leo files in the parser sub-directory. Then when running the test command, make sure you have the environment variable CLEAR_LEO_TEST_EXPECTATIONS set to true. For example, on a UNIX environment, you could run the following command CLEAR_LEO_TEST_EXPECTATIONS=true cargo test --all --features ci_skip --no-fail-fast.

Grammar
The grammars repository contains a file leo.abnf that has the Leo grammar rules in the ABNF format. If your changes affect a grammar rule, we may ask you to modify it in that .abnf file.

We appreciate your hard work!

Leo Syntax Cheatsheet
1. File Import
import foo.aleo;

2. Programs
program hello.aleo {
    // code
}

3. Primitive Data Types
// Boolean value (true or false)
let b: bool = false; 

// Signed 32-bit integer (also available: i8, i16, i64, i128)
let i: i32 = -10i32; 

// Unsigned 32-bit integer (also available: u8, u16, u64, u128)
let ui: u32 = 10u32; 

// Field element (used in cryptographic computations)
let a: field = 1field; 

// Group element (used in elliptic curve operations)
let g: group = 0group; 

// Scalar element (used in elliptic curve arithmetic)
let s: scalar = 1scalar; 

// Aleo blockchain address
let receiver: address = aleo1ezamst4pjgj9zfxqq0fwfj8a4cjuqndmasgata3hggzqygggnyfq6kmyd4; 

// Digital signature (used for authentication and verification)
let s: signature = sign1ftal5ngunk4lv9hfygl45z35vqu9cufqlecumke9jety3w2s6vqtjj4hmjulh899zqsxfxk9wm8q40w9zd9v63sqevkz8zaddugwwq35q8nghcp83tgntvyuqgk8yh0temt6gdqpleee0nwnccxfzes6pawcdwyk4f70n9ecmz6675kvrfsruehe27ppdsxrp2jnvcmy2wws6sw0egv;


Type Casting
// Casting between integer types
let a: u8 = 255u8;
let b: u16 = a as u16; // 255u8 to 255u16
let c: u32 = b as u32; // 255u16 to 255u32
let d: i32 = c as i32; // 255u32 to 255i32

// Casting between field and integers
let f: field = 10field;
let i: i32 = f as i32; // Convert field to i32
let u: u64 = f as u64; // Convert field to u64

// Casting between scalar and field
let s: scalar = 5scalar;
let f_from_scalar: field = s as field; // Convert scalar to field

// Casting between group and field
let g: group = 1group;
let f_from_group: field = g as field; // Convert group to field

// Address casting (only valid conversions)
let addr: address = aleo1ezamst4pjgj9zfxqq0fwfj8a4cjuqndmasgata3hggzqygggnyfq6kmyd4;
let addr_field: field = addr as field; // Convert address to field


The primitive types are: address, bool, field, group, i8, i16, i32, i64, i128, u8, u16, u32, u64, u128, scalar.

We can cast between all of these types except signature.

You can cast an address to a field but not vice versa.

Option Types
// Boolean option value (true or false or none)
let b_some: bool? = true; 
let b_none: bool? = none; 
// Unwrapping option values
let b_true = b_some.unwrap();
let b_false = b_none.unwrap_or(false);

// Signed 32-bit integer option (also available: i8, i16, i64, i128)
let i_some: i32? = -10i32; 
let i_none: i32? = none; 

// Unsigned 32-bit integer option (also available: u8, u16, u64, u128)
let ui_some: u32? = 10u32; 
let ui_none: u32? = none; 

// Field element option (used in cryptographic computations)
let a_some: field? = 1field; 
let a_none: field? = none; 

// Group element option (used in elliptic curve operations)
let g_some: group? = 0group; 
let g_none: group? = none; 

// Scalar element option (used in elliptic curve arithmetic)
let s_some: scalar? = 1scalar; 
let s_none: scalar? = none; 


Both address and signature types do not have option variants.

4. Records
Defining a record:

record Token {
    owner: address,
    amount: u64,
}

Creating a record:

let user: User = User {
    owner: aleo1ezamst4pjgj9zfxqq0fwfj8a4cjuqndmasgata3hggzqygggnyfq6kmyd4,
    balance: 1000u64,
};


Accessing record fields:

let user_address: address = user.owner;
let user_balance: u64 = user.balance;

5. Structs
Defining a struct:

struct Message {
    sender: address,
    object: u64,
}

Creating an instance of a struct:

let msg: Message = Message {
    sender: aleo1ezamst4pjgj9zfxqq0fwfj8a4cjuqndmasgata3hggzqygggnyfq6kmyd4,
    object: 42u64,
};


Accessing struct Fields:

let sender_address: address = msg.sender;
let object_value: u64 = msg.object;

Const Generics
struct Matrix::[N: u32, M: u32] {
    data: [field; N * M],
}

// Usage
let m = Matrix::[2, 2] { data: [0, 1, 2, 3] };

Note that generic structs cannot currently be imported outside a program, but can be declared and used in submodules. Acceptable types for const generic parameters include integer types, bool, scalar, group, field, and address.

Option Types
Creating an option type instance of a struct

struct Point {
    x : u32,
    y : u32
}

let point1: Point? = Point {
    x: 8u32,
    y: 41u32,
};
let point2: Point? = none;

let point1_val = point1.unwrap();
let point2_val = point2.unwrap_or(Point {x: 0u32, y: 0u32,});


Note that because the address and signature types do not have option variants, a struct containing elements of these types also cannot have an option variant.

6. Arrays
Declaring arrays:

let arrb: [bool; 2] = [true, false];
let arr: [u8; 4] = [1u8, 2u8, 3u8, 4u8]; 
let empty: [u8; 0] = []; 

Accessing elements:

let first: u8 = arr[0]; // Get the first element
let second: u8 = arr[1]; // Get the second element


Looping over arrays:

let numbers: [u32; 3] = [5u32, 10u32, 15u32];

let sum: u32 = 0u32;

for i: u8 in 0u8..3u8 {
    sum += numbers[i];
}

7. Tuples
Declaring tuples:

// NOTE: Tuples cannot be empty!
let t: (u8, bool, field) = (42u8, true, 100field);


Accessing tuple elements:

// Using de-structuring
let (a, b, c) = t; 

//Using index-based accessing
let first: u8 = t.0;
let second: bool = t.1;
let third: field = t.2;

8. Functions
The rules for functions (in the traditional sense) are as follows:

There are three variants of functions:

transition: Can only call functions and inlines.
functions: Can only call inlines.
inlines: Can only call inlines.
Direct/indirect recursive calls are not allowed.

Inline
An inline function is used for small operations. It gets inlined at compile time, meaning it does not create a separate function call

inline foo(
    a: field,
    b: field,
) -> field {
    return a + b;
}

Const Generics
inline sum_first_n_ints::[N: u32]() -> u32 {
    let sum = 0u32;
    for i in 0u32..N {
        sum += i
    }
    return sum;
}
 
transition main() -> u32 {
    return sum_first_n_ints::[5u32]();
}

Acceptable types for const generic parameters include integer types, bool, scalar, group, field, and address.

âœ… Can call: inline

âŒ Cannot call: function or transition

Function
A function is used for computations. It cannot modify state and can only call inline functions.

function compute(a: u64, b: u64) -> u64 {
    return a + b;
}

âœ… Can call: inline

âŒ Cannot call: function or transition

Transition
A transition function modifies state (e.g., transfers, updates records). It can call function and inline functions, but cannot be called by a function or inline.

transition transfer(receiver: address, amount: u64) {
    let balance: u64 = 1000u64; // Example balance
    let new_balance: u64 = subtract(balance, amount);
    // Logic to send `amount` to `receiver` would go here
}

function subtract(a: u64, b: u64) -> u64 {
    return a - b;
}


âœ… Can call: function, inline

âŒ Cannot call: another transition (unless from another program)

Async Transition
An async transition function modifies private state exactly like a regular transition, but it also includes an onchain portion that can modify public (onchain) state.

It can call function and inline functions, but cannot be called by a function or inline.

An async transition must return a Future.

mapping balances: address => u64

async transition mint(receiver: address, amount: u64) -> Future {
    return async {
        let current_balance: u64 = balances.get_or_use(receiver, 0u64);
        let new_balance: u64 = current_balance + amount;
        balances.set(receiver, new_balance);
    };
}



âœ… Can call: function, inline

âŒ Cannot call: another transition (unless from another program)

9. Loops
let count: u32 = 0u32;

for i: u32 in 0u32..5u32 {
    count += 1u32;
}

10. Conditionals
let a: u8 = 1u8;

if a == 1u8 {
    a += 1u8;
} else if a == 2u8 {
    a += 2u8;
} else {
    a += 3u8;
}
 
a = (a == 1u8) ? a + 1u8 : ((a == 2u8) ? a + 2u8 : a + 3u8); // Ternary format


11. Onchain Storage
Mappings
mapping balances: address => u64;

// Querying
let contains_bal: bool = balances.contains(receiver);
let get_bal: u64 = balances.get(receiver);
let get_or_use_bal: u64 = balances.get_or_use(receiver, 0u64);

// Modifying
balances.set(receiver, 100u64);
balances.remove(balances, receiver);


Storage Variables
storage var: u8;

// Querying
let unwrap_var: u8 = var.unwrap();
let unwrap_or_var: u8 = var.unwrap_or(0u8);

// Modifying
var = 8u8;
var = none;

Storage Vectors
storage vec: [u8]

// Querying
let len_vec: u32 = vec.len();
let val: u8 = vec.get(idx)

// Modifying
vec.set(idx, value);
vec.push(value);
vec.pop();
vec.swap_remove(idx);
vec.clear();

12. Operators
Standard
// Arithmetic Operators
let sum: u64 = a + b; // addition (also has wrapped variant)
let diff: u64 = a - b; // subtraction (also has wrapped variant)
let prod: u64 = a * b; // multiplication (also has wrapped variant)
let quot: u64 = a / b; // division (also has wrapped variant)
let power: u64 = a ** b; // exponentiation (also has wrapped variant)
let remainder: u64 = a % b; // remainder (also has wrapped variant)
let neg: i64 = -(a as i64); // negation
let abs : i64 = neg.abs(); // absolute value (also has wrapped variant)

// Bitwise/Boolean Operators
let logical_and: bool = a && b; // logical AND
let logical_or: bool = a || b; // logical OR
let bitwise_and: u64 = a & b; // bitwise AND
let bitwise_or: u64 = a | b; // bitwise OR
let bitwise_xor: u64 = a ^ b; // bitwise XOR
let bitwise_not: u64 = !a; // bitwise NOT
let bitwise_shl: u64 = a << b // bitwise shift left (also has wrapped variant)
let bitwise_shr: u64 = a >> b // bitwise shift left (also has wrapped variant)

// Comparators
let eq: bool = a == b; // equality
let neq: bool = a != b; // non-equality
let lt: bool = a < b; // less than
let lte: bool = a <= b; // less than or equal
let gt: bool = a > b; // greater than
let gte: bool = a >= b; // greater than or equal

// Group & Field Operators
let g: group = group::GEN; // the group generator
let x: field = 0group.to_x_coordinate(); // x-coordinate of a group element 
let y: field = 0group.to_y_coordinate(); // y-coordinate of a group element 
let doubled: group = 1field.double();  // Doubles the field/group element
let inverse: field = 1field.inv(); // Multiplicative inverse of the field/group element
let squared: field = 1field.square(); // Square of the field/group element
let root: field = 1field.square_root(); // Square root of the field/group element

// Context-dependent Expressions
let height: u32 = block.height; // Height of current blcok
let now: i64 = block.timestamp; // Timestamp of current block
let this: address = self.address; // Address of program
let caller: address = self.caller; // Address of function caller
let checksum: [u8, 32] = self.checksum; // Checksum of a program
let edition: u16 = self.edition; // Edition of a program
let owner: address = self.program_owner; // Address that deployed a program
let signer: address = self.signer; // Address of tx signer (origin)

// Bit Serialization/Deserialization
let bits: [bool; 58] = Serialize::to_bits(value);  // Standard serialization (includes type metadata)
let raw_bits: [bool; 32] = Serialize::to_bits_raw(value); // Raw serialization (no metadata, just raw bits)

// Miscellaneous
assert(a); // assert the value of a is true
assert_eq(a, b); // assert a and b are equal
assert_neq(b, c); // assert b and c are not equal
let ternary = boolean ? a : b; // Ternary expression


Cryptographic
// Randomization 
let rand: u32 = ChaCha::rand_u32(); // generate a random value `ChaCha::rand_<type>()`

// Hash Functions (BHP, Pedersen, Poseidon, Keccak, SHA3)
let hash: field = BHP256::hash_to_field(1u32); // hash any type to any type
let hash_raw: address = Poseidon2::hash_to_address_raw(1u8); // hash any raw type to any type
let hash_native: [bool; 256] = Keccak256::hash_to_bits(0field); // hash any type to an array of bits (only available for Keccak and SHA3)
let hash_native_raw: [bool; 256] = Keccak256::hash_to_bits_raw(0field); // hash any raw type to an array of bits (only available for Keccak and SHA3)

// Commitment Algorithms (BHP, Pedersen)
let commit: group = Pedersen64::commit_to_group(1u64, 1scalar); // commit any type to a field, group, or address, using a scalar as blinding factor (salt)

// Schnorr Signatures
let schnorr: bool = signature::verify(sig, addr, 0field) // Schnorr Signature Verification 

// ECDSA Signatures (Keccak, SHA3)
let ecdsa: bool = ECDSA::verify_keccak256(sig, addr, msg); // Verify an ECDSA signature against an ECDSA public key and the Keccak256 hash of a message
let ecdsa_raw: bool = ECDSA::verify_keccak256_raw(sig, addr, msg); // Verify an ECDSA signature against an ECDSA public key and the Keccak256 hash of a raw message
let ecdsa_eth: bool = ECDSA::verify_keccak256_eth(sig, eth_addr, msg); // Verify an ECDSA signature against an Ethereum address and the Keccak256 hash of a raw message

let ecdsa_digest: bool = ECDSA::verify_digest(sig, addr, digest); // Verify an ECDSA signature against an ECDSA public key and a prehashed message
let ecdsa_digest_eth: bool = ECDSA::verify_digest_e


leo account
The leo account command is used to create and manage Aleo accounts, as well as sign and verify messages

danger
We urge you to exercise caution when managing your private keys. leo account cannot be used to recover lost keys.

Subcommands
new - Generates a new Aleo account.
import - Derive and Aleo account from a private key.
sign - Sign a message using your Aleo private key.
verify - Verify a message and signature from an Aleo address.
decrypt - Decrypt record ciphertexts using your Aleo private key or view key.
leo account new
Back to Top

Use this command to generate a private key, view key, and address for a new Aleo account.

The output should look like this:

console output:
  Private Key  APrivateKey1zkp...
     View Key  AViewKey1...
      Address  aleo1...

Flags:
--seed <SEED>
-s <SEED>
Specifies a particular numeric value to use as the seed for the random number generator (RNG)

--write 
-w
Writes the generated private key to a .env file in the current working directory (./)

--discreet
Print sensitive information (such as private key) discreetly to an alternate screen

leo account import
Back to Top

Use this command to derive the view key and address for an Aleo account from a private key.

To import an existing Aleo account, run the following command:

leo account import <PRIVATE_KEY>

where <PRIVATE_KEY> is your private key.

Flags:
--write 
-w
Writes the generated private key to a .env file in the current working directory (./)

--discreet
Print sensitive information (such as private key) discreetly to an alternate screen

leo account sign
Back to Top

Use this command to sign a message using your Aleo private key.

Assuming either the current working directory is a Leo project or the $PRIVATE_KEY environment variable has been set, you can sign a message using the following command:

leo account sign --message <MESSAGE>

Flags:
--message <MESSAGE>
-m <MESSAGE>
info
This flag is required!

Specifies the message to be signed.

--private-key <PRIVATE_KEY>
Explicity specifies the private key to sign the message with. Overrides any private key in .env file or $PRIVATE_KEY environment variable.

--private-key-file <PRIVATE_KEY_FILE>
Alternative way to explicity specifies the private key by reading from a text file at path <PRIVATE_KEY_FILE> Overrides any private key in .env file or $PRIVATE_KEY environment variable.

--raw 
-r
Parses the message as bytes instead of Aleo literals.

leo account verify
Back to Top

Use this command to verify a message and signature from an Aleo address.

To verify a message, run the following command

leo account verify --address <ADDRESS> --signature <SIGNATURE> --message <MESSAGE>


where <MESSAGE> is the message, <SIGNATURE> is the signature of that message, and <ADDRESS> is the address of the account that generated the signature.

Flags:
--address <ADDRESS>
-a <ADDRESS>
info
This flag is required!

Specifies the address of the account that generated the signature.

--signature <SIGNATURE>
-s <SIGNATURE>
info
This flag is required!

Specifies the signature of the message.

--message <MESSAGE>
-m <MESSAGE>
info
This flag is required!

Specifies the message that was signed.

--raw 
-r
Parses the message as bytes instead of Aleo literals.

leo account decrypt
Back to Top

Use this command to decrypt a record ciphertext using your Aleo private key or view key.

To decrypt a record ciphertext using your private key, run the following command

leo account decrypt --ciphertext <CIPHERTEXT> -k <KEY>


where <CIPHERTEXT> is the ciphertext of a record, and <KEY> is private key of the record's owner.

Optionally, you can specify a path to a file containing the key rather than the key itself:

leo account decrypt --ciphertext <CIPHERTEXT> -f <PATH_TO_KEYFILE>


If you do not specify either the key or key file, the CLI will attempt use the PRIVATE_KEY and VIEW_KEY environment variables.

If the private key does not correspond to the owner of the record, the decryption will fail.

Flags:
-c <CIPHERTEXT>
info
This flag is required!

Specifies the record ciphertext to decrypt.

-k <KEY>
Specifies the private key or view key to use for decryption. This will raise an error if you also pass the -f flag.

-f <KEY_FILE>
Specifies the path to a file containing the private key or view key. This will raise an error if you also pass the -k flag.

--network <NETWORK>
Specifies the network to deploy to. Overrides any NETWORK environment variable set manually or in a .env file. Valid network names are testnet, mainnet, and canary.

leo add
The leo add command is used to add a new on-chain or local dependency to the current Leo project.

To add a local dependency to your project, run the following command:

leo add --local <LOCAL> <NAME>

where <NAME> is the name of the imported program, and <LOCAL> is the path to the local project.

To add a program already deployed onchain as a dependency to your project, run the following command:

leo add --network <NAME>

where <NAME> is the name of the imported program.

Flags:
--local <LOCAL> 
-l <LOCAL>
Specifies that the dependency to be added is a local program located at path <LOCAL>. This can either be the root directory for a Leo project, or a path directly to an already compiled .aleo file.

--network
-n 
Specifies that the dependency to be added is a remote program currently deployed onchain. The network that it will be pulled from will be the same as the one specified in by the NETWORK variable in .env

--edition <EDITION> 
-e <EDITION>
Specifies the expected edition of the program being imported. Only passing this flag will assume that the program is being imported from the network.

danger
Do not use this feature unless you know what you are doing!

--dev
Specifies that the imported program is a development dependency and should not be used in production

--clear
-c
Clears all previous dependencies.

danger
This feature is currently bugged and is non-functional.


leo build
To compile your program into Aleo instructions and verify that it builds properly, run:

leo build

On invoking the build command, Leo automatically creates a build/â  and output/â  folder in the project directory. The compiled .aleo file is contained in the build directory. The output directory is used to stored intermediate artifacts from compilation.

console output:
  Leo     2 statements before dead code elimination.
  Leo     2 statements after dead code elimination.
  Leo     The program checksum is: '[...]'.
  Leo âœ… Compiled '{PROGRAM_NAME}.aleo' into Aleo instructions.


Flags:
--offline
    Enables offline mode.
--enable-ast-spans
    Enable spans in AST snapshots.
--enable-dce
    Enables dead code elimination in the compiler.
--conditional-block-max-depth <CONDITIONAL_BLOCK_MAX_DEPTH>
    Max depth to type check nested conditionals. [default: 10]
--disable-conditional-branch-type-checking
    Disable type checking of nested conditional branches in finalize scope.
--enable-initial-ast-snapshot
    Write an AST snapshot immediately after parsing.
--enable-all-ast-snapshots
    Writes all AST snapshots for the different compiler phases.
--ast-snapshots <AST_SNAPSHOTS>...
    Comma separated list of passes whose AST snapshots to capture.
--build-tests
    Build tests along with the main program and dependencies.
--no-cache
    Don't use the dependency cache.
--no-local
    Don't use the local source code.
--private-key <PRIVATE_KEY>
    The private key to use for the deployment. Overrides the `PRIVATE_KEY` environment variable.
--network <NETWORK>
    The network to deploy to. Overrides the `NETWORK` environment variable.
--endpoint <ENDPOINT>
    The endpoint to deploy to. Overrides the `ENDPOINT` environment variable.
--devnet
    Whether the network is a devnet. If not set, defaults to the `DEVNET` environment variable.
--consensus-heights <CONSENSUS_HEIGHTS>
    Optional consensus heights to use. This should 

leo clean
To clean the build directory, run:

leo clean

console output:
  Leo ðŸ§¹ Cleaned the outputs directory (in "...")
  Leo ðŸ§¹ Cleaned the build directory (in "...")


leo debug
To start the interactive debugger, run leo debug in a Leo project.

> leo debug
       Leo âœ… Compiled sources for 'workshop'
This is the Leo Interpreter. Try the command `#help`.

? Command? â€º 


Cheatsheet
You probably want to start by running a function or transition.
For instance
#into program.aleo/main()
Once a function is running, commands include
#into    to evaluate into the next expression or statement;
#step    to take one step towards evaluating the current expression or statement;
#over    to complete evaluating the current expression or statement;
#run     to finish evaluating
#quit    to quit the interpreter.

You can set a breakpoint with
#break program_name line_number

When executing Aleo VM code, you can print the value of a register like this:
#print 2

Some of the commands may be run with one letter abbreviations, such as #i.

Note that this interpreter is not line oriented as in many common debuggers;
rather it is oriented around expressions and statements.
As you step into code, individual expressions or statements will
be evaluated one by one, including arguments of function calls.

You may simply enter Leo expressions or statements on the command line
to evaluate. For instance, if you want to see the value of a variable w:
w
If you want to set w to a new value:
w = z + 2u8;

Note that statements (like the assignment above) must end with a semicolon.

If there are futures available to be executed, they will be listed by
numerical index, and you may run them using `#future` (or `#f`); for instance
#future 0

The interpreter begins in a global context, not in any Leo program. You can set
the current program with

#set_program program_name

This allows you to refer to structs and other items in the indicated program.

The interpreter may enter an invalid state, often due to Leo code entered at the
REPL. In this case, you may use the command

#restore

Which will restore to the last saved state of the interpreter. Any time you
enter Leo code at the prompt, interpreter state is saved.

Input history is available - use the up and down arrow keys.


See Debugging for more details.


leo deploy
note
This command requires having a funded account.

To deploy the project in the current working directory, run the following command:

leo deploy # Defaults to using the private key, network, and endpoint in .env or environment variables


sample output:
       Leo     ... statements before dead code elimination.
       Leo     ... statements after dead code elimination.
       Leo     The program checksum is: '[...]'.
       Leo âœ… Compiled '{PROGRAM_NAME}.aleo' into Aleo instructions.

ðŸ“¢ Using the following consensus heights: 0,2950000,4800000,6625000,6765000,7600000,8365000,9173000,9800000
  To override, pass in `--consensus-heights` or override the environment variable `CONSENSUS_VERSION_HEIGHTS`.

Attempting to determine the consensus version from the latest block height at {ENDPOINT}...

ðŸ› ï¸  Deployment Plan Summary
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ”§ Configuration:
  Private Key:        {PRIVATE_KEY}
  Address:            {ADDRESS}
  Endpoint:           {ENDPOINT}
  Network:            {NETWORK}
  Consensus Version:  {CONSENSUS_VERSION}

ðŸ“¦ Deployment Tasks:
  â€¢ {PROGRAM_NAME}.aleo  â”‚ priority fee: 0  â”‚ fee record: no (public fee)

âš™ï¸ Actions:
  â€¢ Transaction(s) will NOT be printed to the console.
  â€¢ Transaction(s) will NOT be saved to a file.
  â€¢ Transaction(s) will be broadcast to {ENDPOINT}

ðŸ”§ Your program '{PROGRAM_NAME}.aleo' has the following constructor.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
constructor:
    ...
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Once it is deployed, it CANNOT be changed.

ðŸ“¦ Creating deployment transaction for '{PROGRAM_NAME}.aleo'...


ðŸ“Š Deployment Summary for '{PROGRAM_NAME}.aleo'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Total Variables:      ...
  Total Constraints:    ...
  Max Variables:        2,097,152
  Max Constraints:      2,097,152

ðŸ’° Cost Breakdown (credits)
  Transaction Storage:  ...
  Program Synthesis:    ...
  Namespace:            ...
  Constructor:          ...
  Priority Fee:         ...
  Total Fee:            ...
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


See the Deploying guide for more details.

Flags:
--private-key <PRIVATE_KEY>
Specifies the private key to use for the deployment. Overrides any $PRIVATE_KEY environment variable set manually or in a .env file.

--network <NETWORK>
Specifies the network to deploy to. Overrides any NETWORK environment variable set manually or in a .env file. Valid network names are testnet, mainnet, and canary.

--endpoint <ENDPOINT>
The endpoint to deploy to. Overrides any ENDPOINT environment variable set manually or in a .env file.

Common Endpoints:

Network	Endpoint
Devnet (local)	https://localhost:3030
Testnet	https://api.explorer.provable.com/v1
Mainnet	https://api.explorer.provable.com/v1
--devnet
Specifies whether the network being deployed to is a devnet. If not set, defaults to the DEVNET environment variable.

info
This flag requires a devnet to be running locally. See INSERT DEVNET GUIDE HERE for more information

-print
Prints the transaction to the terminal/stdout in JSON format.

-broadcast
Broadcasts the transaction to the network upon successful execution. Without passing this flag, the transaction will just be generated locally.

--save <SAVE>
Saves the transaction to the directory located at the <SAVE> path.

--skip <SUBSTRING_0> <SUBSTRING_1> ...
Skips deployment of any program that contains one of the given substrings, delimited by a space.

--yes
-y
The CLI will ask for manual confirmation on several steps throughout the deployment process. Setting this flag automatically agrees to all confirmations.

danger
Do not use this feature unless you know what you are doing!

--priority-fees <PRIORITY_FEES>
Specifes the priority fee for the deployment transaction(s) delimited by | and used in order. The fees are in microcredits and must either be valid u64 or default. Defaults to 0.

tip
1 Credit == 1,000,000 Microcreditss

--fee-records <FEE_RECORDS>
-f <FEE_RECORDS>
Specifes the record(s) to pay for fees privately, delimited by | and used in order. The fees must either be valid plaintext, ciphertext, or default. If not specified, then transaction fees will be public.

--consensus-heights <CONSENSUS_HEIGHTS>
Specifies the consensus heights to use, delimited by ,. This should only be set if you are using a custom devnet.

The following will enable Consensus_V0 at block 0, Consensus_V1 at block 1, etc.:

--consensus-heights 0,1,2,3....

--consensus-version <CONSENSUS_VERSION>
Specifies the consensus version to use. If one is not provided, the CLI will attempt to determine it from the latest block.

--max-wait <MAX_WAIT>
Specifies the number of seconds to wait for a block to appear when searching for a transaction. Defaults to 8 seconds.

--blocks-to-check <BLOCKS_TO_CHECK>
Specifies the number of blocks to look at when searching for a transaction. Defaults to 12 blocks

Options:
--base-fees <BASE_FEES>
  [UNUSED] Base fees in microcredits, delimited by `|`, and used in order. The fees must either be valid `u64` or `default`. Defaults to automatic calculation.
--skip <SKIP>...
  Skips deployment of any program that contains one of the given substrings.
--offline
    Enables offline mode.
--enable-ast-spans
    Enable spans in AST snapshots.
--enable-dce
    Enables dead code elimination in the compiler.
--conditional-block-max-depth <CONDITIONAL_BLOCK_MAX_DEPTH>
    Max depth to type check nested conditionals. [default: 10]
--disable-conditional-branch-type-checking
    Disable type checking of nested conditional branches in finalize scope.
--enable-initial-ast-snapshot
    Write an AST snapshot immediately after parsing.
--enable-all-ast-snapshots
    Writes all AST snapshots for the different compiler phases.
--ast-snapshots <AST_SNAPSHOTS>...
    Comma separated list of passes whose AST snapshots to capture.
--build-tests
    Build tests along with the main program and dependencies.
--no-cache
    Don't use the dependency cache.
--no-local
    Don't use the local source code.

leo devnet
To intialize a local devnet, run the following command:

leo devnet --snarkos <SNARKOS>

where <SNARKOS> should be the path to an installed binary of snarkOS.

If you don't have snarkOS installed, you can do so by passing the --install flag, which will install the binary at the path specified above.

info
The default ENDPOINT for a local devnet is http://localhost:3030

Flags:
--snarkos <SNARKOS>
Specifies the path to the installed snarkOS binary.

info
This flag is required!

--snarkos-features <FEATURES>
Specifies which features of snarkOS to use (e.g. test_network)

--install
Installs (or reinstalls) snarkOS at the provided --snarkos path with the given --snarkos-features.

--snarkos-version <SNARKOS_VERSION>
Specifies which version of snarkOS to use or install. Defaults to latest version on crates.io

--consensus-heights <CONSENSUS_HEIGHTS> 
Optional blocks heights to use for each successive consensus upgrade. Must have --snarkos-features test_network enabled as well.

The following will enable Consensus_V0 at block 0, Consensus_V1 at block 1, etc.:

--consensus-heights 0,1,2,3....

--storage <STORAGE>
Root directory path for snarkOS ledgers and logs. Defaults to ./

--clear-storage
Clear existing snarkOS ledgers before starting the devnet

--network <NETWORK_ID>
Specifies what the network ID of the devnet will be.

ID	Network
0	Mainnet
1	Testnet (default)
2	Canary
--tmux
Run devnet nodes in tmux (only available on Unix-based systems)

--num-validators <NUM_VALIDATORS>
Number of validators to use in snarkOS. Defaults to 4.

--num-clients <NUM_CLIENTS>
Number of clients to use in snarkOS. Defaults to 2.

--verbosity <VERBOSITY>
Specifies the verbository of snarkOS (0-4). Defaults to 1.

leo execute
You can execute a transition function by using the leo execute command. This differs from the leo run command in that a transaction and proof of execution are produced, and optionally can be broadcasted to the network.

To execute a Leo transition function with inputs from the command line, run the following command:

leo execute <TRANSITION_NAME> <INPUTS>

where <TRANSITION_NAME> is the name of the transition or async transition function to execute and <INPUTS>is a list of inputs to the program separated by spaces.

note
This command requires having a funded account.

Under the hood, this command synthesizes the program circuit and generates proving and verifying keys.

sample output:
       Leo     ... statements before dead code elimination.
       Leo     ... statements after dead code elimination.
       Leo     The program checksum is: '[...]'.
       Leo âœ… Compiled '{PROGRAM_NAME}.aleo' into Aleo instructions.

ðŸ“¢ Using the following consensus heights: 0,2950000,4800000,6625000,6765000,7600000,8365000,9173000,9800000
  To override, pass in `--consensus-heights` or override the environment variable `CONSENSUS_VERSION_HEIGHTS`.

Attempting to determine the consensus version from the latest block height at {ENDPOINT}...

ðŸš€ Execution Plan Summary
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ”§ Configuration:
  Private Key:        {PRIVATE_KEY}
  Address:            {ADDRESS}
  Endpoint:           {ENDPOINT}
  Network:            {NETWORK}
  Consensus Version:  {CONSENSUS_VERSION}

ðŸŽ¯ Execution Target:
  Program:        {PROGRAM_NAME}.aleo
  Function:       {FUNCTION_NAME}
  Source:         remote

ðŸ’¸ Fee Info:
  Priority Fee:   {PRIORITY_FEE} Î¼credits
  Fee Record:     no (public fee) | {FEE RECORD}

âš™ï¸ Actions:
  - Program and its dependencies will be downloaded from the network.
  - Transaction will NOT be printed to the console.
  - Transaction will NOT be saved to a file.
  - Transaction will NOT be broadcast to the network.

ðŸ“Š Execution Summary for {PROGRAM_NAME}.aleo
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ’° Cost Breakdown (credits)
  Transaction Storage:  ...
  Onâ€‘chain Execution:   ...
  Priority Fee:         ...
  Total Fee:            ...
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âž¡ï¸  Outputs

 â€¢ {OUTPUT_0}
 â€¢ {OUTPUT_1}
 ...


See the Executing guide for more details.

Flags:
--private-key <PRIVATE_KEY>
Specifies the private key to use for the deployment. Overrides any $PRIVATE_KEY environment variable set manually or in a .env file.

--network <NETWORK>
Specifies the network to deploy to. Overrides any NETWORK environment variable set manually or in a .env file. Valid network names are testnet, mainnet, and canary.

--endpoint <ENDPOINT>
The endpoint to deploy to. Overrides any ENDPOINT environment variable set manually or in a .env file.

Common Endpoints:

Network	Endpoint
Devnet (local)	https://localhost:3030
Testnet	https://api.explorer.provable.com/v1
Mainnet	https://api.explorer.provable.com/v1
--devnet
Specifies whether the network being deployed to is a devnet. If not set, defaults to the DEVNET environment variable.

info
This flag requires a devnet to be running locally. See INSERT DEVNET GUIDE HERE for more information

-print
Prints the transaction to the terminal/stdout in JSON format.

-broadcast
Broadcasts the transaction to the network upon successful execution. Without passing this flag, the transaction will just be generated locally.

--save <SAVE>
Saves the transaction to the directory located at the <SAVE> path.

--yes
-y
The CLI will ask for manual confirmation on several steps throughout the deployment process. Setting this flag automatically agrees to all confirmations.

danger
Do not use this feature unless you know what you are doing!

--priority-fees <PRIORITY_FEES>
Specifes the priority fee for the deployment transaction(s) delimited by | and used in order. The fees are in microcredits and must either be valid u64 or default. Defaults to 0.

tip
1 Credit == 1,000,000 Microcreditss

--fee-records <FEE_RECORDS>
-f <FEE_RECORDS>
Specifes the record(s) to pay for fees privately, delimited by | and used in order. The fees must either be valid plaintext, ciphertext, or default. If not specified, then transaction fees will be public.

--consensus-heights <CONSENSUS_HEIGHTS>
Specifies the consensus heights to use, delimited by ,. This should only be set if you are using a custom devnet.

The following will enable Consensus_V0 at block 0, Consensus_V1 at block 1, etc.:

--consensus-heights 0,1,2,3....

--consensus-version <CONSENSUS_VERSION>
Specifies the consensus version to use. If one is not provided, the CLI will attempt to determine it from the latest block.

--max-wait <MAX_WAIT>
Specifies the number of seconds to wait for a block to appear when searching for a transaction. Defaults to 8 seconds.

--blocks-to-check <BLOCKS_TO_CHECK>
Specifies the number of blocks to look at when searching for a transaction. Defaults to 12 blocks

Options:
--base-fees <BASE_FEES>
  [UNUSED] Base fees in microcredits, delimited by `|`, and used in order. The fees must either be valid `u64` or `default`. Defaults to automatic calculation.
--offline
    Enables offline mode.
--enable-ast-spans
    Enable spans in AST snapshots.
--enable-dce
    Enables dead code elimination in the compiler.
--conditional-block-max-depth <CONDITIONAL_BLOCK_MAX_DEPTH>
    Max depth to type check nested conditionals. [default: 10]
--disable-conditional-branch-type-checking
    Disable type checking of nested conditional branches in finalize scope.
--enable-initial-ast-snapshot
    Write an AST snapshot immediately after parsing.
--enable-all-ast-snapshots
    Writes all AST snapshots for the different compiler phases.
--ast-snapshots <AST_SNAPSHOTS>...
    Comma separated list of passes whose AST snapshots to capture.
--build-tests
    Build tests along with the main program and dependencies.
--no-cache
    Don't use the dependency cache.
--no-local
    Don't use the local source code.

leo new
To create a new project, run:

leo new <NAME>

Valid project names are snake_case: lowercase letters and numbers separated by underscores. This command will create a new directory with the given project name.

See Project Layout for more details .

leo query
The leo query command is used to get data from a network supporting the canonical snarkOS endpoints.

Subcommands
block - Query block information.
transaction - Query transaction information.
program - Query program source code and live mapping values.
stateroot - Query the latest stateroot.
committee - Query the current committee.
mempool - Query transactions and transmissions from the memory pool.
peers - Query peer information.
leo query block
To fetch blocks from a given network, run the following command

leo query <ID>

where <ID> is either a specific block height or block hash. The block will be returned in JSON format.

For example, you can fetch the Mainnet genesis block by running either of the following commands:

leo query block 0 --network mainnet --endpoint https://api.explorer.provable.com/v1


leo query block ab1sm6kyqle2ftg4z8gegafqrjy0jwjhzu6fmy73726dgszrtxhxvfqha0eee --network mainnet --endpoint https://api.explorer.provable.com/v1


Flags:
--network <NETWORK>
Specifies the network to deploy to. Overrides any NETWORK environment variable set manually or in a .env file. Valid network names are testnet, mainnet, and canary.

--endpoint <ENDPOINT>
The endpoint to deploy to. Overrides any ENDPOINT environment variable set manually or in a .env file.

--latest
-l
Queries the latest block.

Example:
leo query block --latest

--latest-hash
Queries the hash of the latest block.

Example:
leo query block --latest-hash

--latest-height
Queries the height of the latest block

Example:
leo query block --latest-height

--range <START_HEIGHT> <END_HEIGHT>
-r <START_HEIGHT> <END_HEIGHT>
Queries up to 50 consecutive blocks.

Example:
leo query block --range <START_HEIGHT> <END_HEIGHT>


--transactions
-t
Queries all transactions at the specified block height

Example:
leo query block <BLOCK_HEIGHT> --transactions

--to-height
Queries the block height corresponding to a hash value

Example:
leo query block <BLOCK_HASH> --to-height

leo query transaction
To fetch a specific transaction from a given network, run the following command:

leo query transaction <ID>

where <ID> is the ID of the transaction. The transaction will be returned in JSON format.

Flags:
--network <NETWORK>
Specifies the network to deploy to. Overrides any NETWORK environment variable set manually or in a .env file. Valid network names are testnet, mainnet, and canary.

--endpoint <ENDPOINT>
The endpoint to deploy to. Overrides any ENDPOINT environment variable set manually or in a .env file.

--confirmed
-c
Returns information (including details about onchain execution) about the queried transaction if it was confirmed.

--unconfirmed
-u
Queries the original (unconfirmed) transaction.

--from-io <INPUT_OR_OUTPUT_ID>
Get the ID of the transaction that an input or output ID occurred in.

Example:
leo query transaction --from-io <INPUT_OR_OUTPUT_ID>


--from-transition <TRANSITION_ID>
Get the ID of the transaction containing the specified transition.

Example:
leo query transaction --from-transition <TRANSITION_ID>


--from-program <PROGRAM_NAME>
Get the ID of the transaction that the specified program was deployed in.

Example:
leo query transaction --from-program <PROGRAM_NAME>


leo query program
To fetch a specific program from a given network, run the following command:

leo query program <PROGRAM_NAME>

You can also use this to query specific mappings and mapping values from a given program. For example, if you wanted to query your public balance of Aleo credits:

leo query program credits.aleo --mapping-value account <YOUR_ADDRESS>


Flags:
--network <NETWORK>
Specifies the network to deploy to. Overrides any NETWORK environment variable set manually or in a .env file. Valid network names are testnet, mainnet, and canary.

--endpoint <ENDPOINT>
The endpoint to deploy to. Overrides any ENDPOINT environment variable set manually or in a .env file.

--mappings
Lists all mappings defined in the latest deployed edition of the program.

--mapping-value <MAPPING> <KEY> 
Get the value corresponding to the specified mapping and key. Will return null if key is not present in mapping.

--edition <EDITION>
An optional edition to query for when fetching the program source. If not specified, the latest edition will be used.

The edition of the program is set to 0 upon initial deployment and is incremented by 1 each time the program is upgraded. See the Upgrading Programs guide for more details.

leo query stateroot
This command queries the latest stateroot of a given network.

Flags:
--network <NETWORK>
Specifies the network to deploy to. Overrides any NETWORK environment variable set manually or in a .env file. Valid network names are testnet, mainnet, and canary.

--endpoint <ENDPOINT>
The endpoint to deploy to. Overrides any ENDPOINT environment variable set manually or in a .env file.

leo query committee
This command queries the current validator committee for a given network.

Flags:
--network <NETWORK>
Specifies the network to deploy to. Overrides any NETWORK environment variable set manually or in a .env file. Valid network names are testnet, mainnet, and canary.

--endpoint <ENDPOINT>
The endpoint to deploy to. Overrides any ENDPOINT environment variable set manually or in a .env file.

leo query mempool
This command queries transactions and transmissions from the memory pool for a node on a given network.

note
This command can only be run with a custom endpoint. Using the official Provable API endpoint will fail.

To query transactions:

leo query mempool --transactions

To query transmissions:

leo query mempool --transmissions

Flags:
--transactions
Queries the transactions in the memory pool.

--transmissions
Queries the transactions in the memory pool.

--network <NETWORK>
Specifies the network to deploy to. Overrides any NETWORK environment variable set manually or in a .env file. Valid network names are testnet, mainnet, and canary.

--endpoint <ENDPOINT>
The endpoint to deploy to. Overrides any ENDPOINT environment variable set manually or in a .env file.

leo query peers
This command queries peer information for a node on a given network.

note
This command can only be run with a custom endpoint. Using the official Provable API endpoint will fail.

Flags:
--metrics
-m
Queries all peer metrics

--count
-c
Queries the count of all participating peers

--network <NETWORK>
Specifies the network to deploy to. Overrides any NETWORK environment variable set manually or in a .env file. Valid network names are testnet, mainnet, and canary.

--endpoint <ENDPOINT>
The endpoint to deploy to. Overrides any ENDPOINT environment variable set manually or in a .env file.


leo remove
To remove a dependency from your project, run the following command:

leo remove <NAME>

where <NAME> is the name of the imported program.

See the Dependency Management guide for more details.

Flags:
--all
Removes all dependencies (or dev dependencies, if used with --dev).

-dev
Removes dev dependencies.


leo run
You can run a transition function by using the leo run command. This will simply run the specified transition function with the provided inputs and show what the produced output will be. It will NOT generate the zero-knowledge proof of execution or the transaction, and nothing will be run onchain. For that, please see the leo execute command.

To run a Leo transition function with inputs from the command line, run the following command:

leo run <TRANSITION_NAME> <INPUTS>

where <TRANSITION_NAME> is the name of the transition or async transition function to run and <INPUTS> is a list of inputs to the program separated by spaces.

This command does not synthesize the program circuit or generate proving and verifying keys.

sample output:
       Leo     ... statements before dead code elimination.
       Leo     ... statements after dead code elimination.
       Leo     The program checksum is: '[...]'.
       Leo âœ… Compiled '{PROGRAM_NAME}.aleo' into Aleo instructions.

â›“  Constraints

 â€¢  '{PROGRAM_NAME}.aleo/{FUNCTION_NAME}' - ... constraints (called 1 time)

âž¡ï¸  Outputs

 â€¢ {OUTPUT_0}
 â€¢ {OUTPUT_1}
 ...


If one or more of your inputs are negatives, and consequently begin with a -, you may separate the inputs with a -- so that the command line parser won't attempt to parse them as options:

leo run <TRANSITION_NAME> -- <INPUT_0> -- <INPUT_1> ...


Flags:
--offline
    Enables offline mode.
--enable-ast-spans
    Enable spans in AST snapshots.
--enable-dce
    Enables dead code elimination in the compiler.
--conditional-block-max-depth <CONDITIONAL_BLOCK_MAX_DEPTH>
    Max depth to type check nested conditionals. [default: 10]
--disable-conditional-branch-type-checking
    Disable type checking of nested conditional branches in finalize scope.
--enable-initial-ast-snapshot
    Write an AST snapshot immediately after parsing.
--enable-all-ast-snapshots
    Writes all AST snapshots for the different compiler phases.
--ast-snapshots <AST_SNAPSHOTS>...
    Comma separated list of passes whose AST snapshots to capture.
--build-tests
    Build tests along with the main program and dependencies.
--no-cache
    Don't use the dependency cache.
--no-local
    Don't use the local source code.
--private-key <PRIVATE_KEY>
    The private key to use for the deployment. Overrides the `PRIVATE_KEY` environment variable.
--network <NETWORK>
    The network to deploy to. Overrides the `NETWORK` environment variable.
--endpoint <ENDPOINT>
    The endpoint to deploy to. Overrides the `ENDPOINT` environment variable.
--devnet
    Whether the network is a devnet. If not set, defaults to the `DEVNET` environment variable.
--consensus-heights <CONSENSUS_HEIGHTS>
    Optional consensus heights to use. This should 

leo synthesize
This command is used to generate proving and verifying keys for all transitions in a local or remote Leo program, along with circuit metadata.

leo synthesize <PROGRAM_NAME> --save <SAVE_DIRECTORY>


Each output of this command includes:

Number of public inputs
Number of variables
Number of constraints
Non-zero entries in matrices
Circuit ID
Proving and verifying keys saved to disk
This enables better understanding of program size and key management.

Flags:
--network <NETWORK>
Specifies the network to deploy to. Overrides any NETWORK environment variable set manually or in a .env file. Valid network names are testnet, mainnet, and canary.

--endpoint <ENDPOINT>
The endpoint to deploy to. Overrides any ENDPOINT environment variable set manually or in a .env file.

--local
-l
Specifies that the keys should be generated for the local Leo project in the current working directory.

--skip <SKIP>
-s <SKIP>
Specifies to skip the key generation for any function names that contain the provided substrings

--save <SAVE_DIRECTORY>
The directory to save the key files to. If the provided path does not exist, it will be created in your current working directory.

leo test
This command runs all the test cases specified in the Leo file in tests/.

If you want to run a specific set of tests, run the following command:

leo test <TEST_NAME>

where <TEST_NAME> is the string to match against the qualified name of each test.

Check out the Testing guide for more information.

Flags:
--offline
    Enables offline mode.
--enable-ast-spans
    Enable spans in AST snapshots.
--enable-dce
    Enables dead code elimination in the compiler.
--conditional-block-max-depth <CONDITIONAL_BLOCK_MAX_DEPTH>
    Max depth to type check nested conditionals. [default: 10]
--disable-conditional-branch-type-checking
    Disable type checking of nested conditional branches in finalize scope.
--enable-initial-ast-snapshot
    Write an AST snapshot immediately after parsing.
--enable-all-ast-snapshots
    Writes all AST snapshots for the different compiler phases.
--ast-snapshots <AST_SNAPSHOTS>...
    Comma separated list of passes whose AST snapshots to capture.
--build-tests
    Build tests along with the main program and dependencies.
--no-cache
    Don't use the dependency cache.
--no-local
    Don't use the local source code.



leo update
To download and install the latest Leo version run:

leo update

console output:
Checking target-arch... aarch64-apple-darwin
Checking current version... v3.1.0
Checking latest released version... v3.1.0
       Leo 
Leo is already on the latest version

If you'd like to install a specific version of Leo, you can do so by passing the --name flag:

leo update --name v3.0.0

Flags:
--list
-l
Lists all available versions of Leo.

--name
-n
An optional release name if you wish to install a specific version of Leo. By default, the command will look for the latest release.

leo upgrade
Upgrades a program that is already deployed on the network.

See the Upgrading Programs guide for more details.

Flags:
--private-key <PRIVATE_KEY>
Specifies the private key to use for the deployment. Overrides any $PRIVATE_KEY environment variable set manually or in a .env file.

--network <NETWORK>
Specifies the network to deploy to. Overrides any NETWORK environment variable set manually or in a .env file. Valid network names are testnet, mainnet, and canary.

--endpoint <ENDPOINT>
The endpoint to deploy to. Overrides any ENDPOINT environment variable set manually or in a .env file.

Common Endpoints:

Network	Endpoint
Devnet (local)	https://localhost:3030
Testnet	https://api.explorer.provable.com/v1
Mainnet	https://api.explorer.provable.com/v1
--devnet
Specifies whether the network being deployed to is a devnet. If not set, defaults to the DEVNET environment variable.

info
This flag requires a devnet to be running locally. See INSERT DEVNET GUIDE HERE for more information

-print
Prints the transaction to the terminal/stdout in JSON format.

-broadcast
Broadcasts the transaction to the network upon successful execution. Without passing this flag, the transaction will just be generated locally.

--save <SAVE>
Saves the transaction to the directory located at the <SAVE> path.

--yes
-y
The CLI will ask for manual confirmation on several steps throughout the deployment process. Setting this flag automatically agrees to all confirmations.

danger
Do not use this feature unless you know what you are doing!

--priority-fees <PRIORITY_FEES>
Specifes the priority fee for the deployment transaction(s) delimited by | and used in order. The fees are in microcredits and must either be valid u64 or default. Defaults to 0.

tip
1 Credit == 1,000,000 Microcreditss

--fee-records <FEE_RECORDS>
-f <FEE_RECORDS>
Specifes the record(s) to pay for fees privately, delimited by | and used in order. The fees must either be valid plaintext, ciphertext, or default. If not specified, then transaction fees will be public.

--consensus-heights <CONSENSUS_HEIGHTS>
Specifies the consensus heights to use, delimited by ,. This should only be set if you are using a custom devnet.

The following will enable Consensus_V0 at block 0, Consensus_V1 at block 1, etc.:

--consensus-heights 0,1,2,3....

--consensus-version <CONSENSUS_VERSION>
Specifies the consensus version to use. If one is not provided, the CLI will attempt to determine it from the latest block.

--max-wait <MAX_WAIT>
Specifies the number of seconds to wait for a block to appear when searching for a transaction. Defaults to 8 seconds.

--blocks-to-check <BLOCKS_TO_CHECK>
Specifies the number of blocks to look at when searching for a transaction. Defaults to 12 blocks

Options:
--base-fees <BASE_FEES>
  [UNUSED] Base fees in microcredits, delimited by `|`, and used in order. The fees must either be valid `u64` or `default`. Defaults to automatic calculation.
--skip <SKIP>...
  Skips the upgrade of any program that contains one of the given substrings.
--offline
    Enables offline mode.
--enable-ast-spans
    Enable spans in AST snapshots.
--enable-dce
    Enables dead code elimination in the compiler.
--conditional-block-max-depth <CONDITIONAL_BLOCK_MAX_DEPTH>
    Max depth to type check nested conditionals. [default: 10]
--disable-conditional-branch-type-checking
    Disable type checking of nested conditional branches in finalize scope.
--enable-initial-ast-snapshot
    Write an AST snapshot immediately after parsing.
--enable-all-ast-snapshots
    Writes all AST snapshots for the different compiler phases.
--ast-snapshots <AST_SNAPSHOTS>...
    Comma separated list of passes whose AST snapshots to capture.
--build-tests
    Build tests along with the main program and dependencies.
--no-cache
    Don't use the dependency cache.
--no-local
    Don't use the local source code.
The Asynchronous Programming Model
Background
The Leo asynchronous programming model enables users to update public on-chain data using a developer-friendly syntax.

The execution of on-chain code is treated as an async function call which returns a Future object. The execution of the on-chain state change occurs after validators verify the proof associated with the transaction.

Managing Public State
On-chain data is stored publicly in one of three data structures: mappings, storage variables, and storage vectors. Any logic that reads from or updates the state of these structures must be contained within an async function block as follows:

program first_public_state.aleo {
    mapping accumulator: u8 => u64;
    storage count: u8;
    storage queue: [u8];

    async function increment_state_onchain(){
        let current_count: u64 = accumulator.get_or_use(0u8, 0u64); // Get current value, defaults to 0
        let new_count: u64 = current_count + 1u64;
        accumulator.set(0u8, new_count);
    }

    async function increment_count_onchain(){
        let current_count: u8 = count.unwrap_or(0u8); // Get current value, defaults to 0
        count = current_count + 1u8;
    }

    async function add_to_queue_onchain(val: u8){
        queue.push(val); // Push to end of queue
    }
}


However, as users can only call transition functions, the Future generated by an async function must be returned from a transition in order to be usable. Any transition that invokes this process must be annotated with the async keyword. There are also a few other nuances:

Async transitions can return additional data types in a tuple, including Records, along with a Future.
Only one Future can be returned.
If multiple types are returned, the Future must be the last type in the tuple.
program first_public_state.aleo {
    mapping accumulator: u8 => u64;
    storage count: u8;
    storage queue: [u8];

    //=============================================================
    //               MAPPING MODIFICATION
    //=============================================================
    async transition increment_accumulator() -> Future {
        return increment_state_onchain();
    }
    async function increment_accumulator_onchain(){
        let current_count: u64 = accumulator.get_or_use(0u8, 0u64); // Get current value, defaults to 0
        let new_count: u64 = current_count + 1u64;
        accumulator.set(0u8, new_count);
    }

    //=============================================================
    //            STORAGE VARIABLE MODIFICATION
    //=============================================================
    async transition increment_count() -> Future {
        return increment_count_onchain();
    }
    async function increment_count_onchain(){
        let current_count: u8 = count.unwrap_or(0u8); // Get current value, defaults to 0
        count = current_count + 1u8;
    }

    //=============================================================
    //            STORAGE VECTOR MODIFICATION
    //=============================================================
    async transition add_to_queue(val: u8) -> Future {
        return add_to_queue_onchain(val: u8);
    }
    async function add_to_queue_onchain(val: u8){
        queue.push(val); // Push to end of queue
    }    
}


Leo also offers a shorthand for writing onchain code in the form of async blocks within async transition functions.

program first_public_state.aleo {
    mapping accumulator: u8 => u64;
    storage count: u8;
    storage queue: [u8];

    //=============================================================
    //               MAPPING MODIFICATION
    //=============================================================
    async transition increment_accumulator() -> Future {
        let f : Future = async {
            let current_count: u64 = accumulator.get_or_use(0u8, 0u64); // Get current value, defaults to 0
            let new_count: u64 = current_count + 1u64;
            accumulator.set(0u8, new_count);
        }
        return f;
    }

    //=============================================================
    //            STORAGE VARIABLE MODIFICATION
    //=============================================================
    async transition increment_count() -> Future {
        let f : Future = async {
            let current_count: u8 = count.unwrap_or(0u8); // Get current value, defaults to 0
            count = current_count + 1u8;
        }
        return f;
    }

    //=============================================================
    //            STORAGE VECTOR MODIFICATION
    //=============================================================
    async transition add_to_queue(val: u8) -> Future {
        let f : Future = async {
            queue.push(val); // Push to end of queue
        }
        return f;
    } 
}


External Async Transitions
Leo enables developers to call external async transitions from imported programs in an async transition. A call to an async transition returns a Future which must be passed as inputs to an async function. These Futures must be composed inside of the async function using the await keyword, as shown in the example below.

import first_public_storage.aleo;

program second_public_storage.aleo {
    mapping hashes: u8 => scalar;

    async transition two_mappings(value: u8) -> Future {
        let increment_future: Future = first_public_storage.aleo/increment();
        return finalize_update_mapping(value, imported_future); 
    } 

    async function finalize_update_mapping(value: u8, imported_future: Future) {
        imported_future.await();
        let hash: scalar = BHP256::hash_to_scalar(value);
        hashes.set(value, hash);
    }
}


If using async blocks, you will need to call the external async transition outside the block and await the resulting Future within.

import first_public_storage.aleo;

program second_public_storage.aleo {
    mapping hashes: u8 => scalar;

    async transition two_mappings(value: u8) -> Future {
        let increment_future: Future = first_public_storage.aleo/increment();
        let f: Future = async {
            imported_future.await();
            let hash: scalar = BHP256::hash_to_scalar(value);
            hashes.set(value, hash);
        }
        return f; 
    } 
}


You can access the inputs to an external future using the following syntax:

let f = imported_program.aleo/some_function();
let value = f.0;  // or f.1, f.2, f.3 and so on depending on the input index 


Managing Both Public and Private State
Updating private state on Aleo utilizes off-chain proof generation to preserve the confidentiality of the userâ€™s data and associated address. Therefore, Records cannot be created or consumed within the scope of async functions. However, Records can be used inside of the scope of async transitions. This is because transition and async transition functions are initially executed off-chain and are accompanied by proofs of correct execution which are subsequently verified by validators. Once the proof is verified, validators execute the code contained within a Future, which is solely defined by code within an async function.

Public State	Private State
Function Type	async function, async block	async transition or transition
Data Storage	mapping, storage	record
Visibility	everyone	visible if you have the viewkey

Dependency Management
Leo Imports
In your main.leo file, specify any imported dependencies using the import keyword before the program declaration:

import credits.aleo;

program test.aleo {
...
}

From the root of your Leo program directory, use the leo add command to update the program.json manifest to add dependencies.

Deployed Programs
When adding a deployed program as a dependency to your program, such as the credits.aleo, use the following command::

leo add credits.aleo

or

leo add credits

If you are deploying to mainnet, you will need to specify mainnet imports using the --network flag as follows:

leo add credits --network mainnet

For the first imported dependency, a new dependencies field will be added to the 'package.json` manifest:

{
  "program": "your_program.aleo",
  "version": "0.0.0",
  "description": "",
  "license": "MIT",
  "dependencies": [
    {
      "name": "credits.aleo",
      "location": "network",
      "network": "testnet",
      "path": null
    }
  ]
}

Dependencies can be removed using the leo remove command:

leo remove credits.aleo

Local Development
When deploying to a local devnet, specify the path for the local dependency as follows:

leo add program_name.aleo --local ./path_to_dependency


The dependencies section in the program.json manifest should include the path:

{
  "program": "your_program.aleo",
  "version": "0.0.0",
  "description": "",
  "license": "MIT",
  "dependencies": [
    {
      "name": "local_dependency.aleo",
      "location": "local",
      "network": null,
      "path": "./path"
    }
  ]
} 

Recursive Deployment
When deploying a program that uses local dependencies, use the following command:

leo deploy --recursive

All local dependency will be deployed in order, followed by the main program. Deployed dependencies will be skipped.

Deploying Your Programs
The leo deploy command is used for deploying Leo program to a local devnet, Testnet, or Mainnet. The leo upgrade command is used for upgrading an existing Leo program on the network.

Getting Started
From the root of the Leo program directory, run the following command:

leo deploy --help

This will display the help message with all available options for the leo deploy command.

Deploy a program

Usage: leo deploy [OPTIONS]

Options:
      --base-fees <BASE_FEES>
          [UNUSED] Base fees in microcredits, delimited by `|`, and used in order. The fees must either be valid `u64` or `default`. Defaults to automatic calculation.
  -d
          Print additional information for debugging
      --priority-fees <PRIORITY_FEES>
          Priority fee in microcredits, delimited by `|`, and used in order. The fees must either be valid `u64` or `default`. Defaults to 0.
  -q
          Suppress CLI output
  -f, --fee-records <FEE_RECORDS>
          Records to pay for fees privately, delimited by '|', and used in order. The fees must either be valid plaintext, ciphertext, or `default`. Defaults to public fees.
      --print
          Print the transaction to stdout.
      --broadcast
          Broadcast the transaction to the network.
      --save <SAVE>
          Save the transaction to the provided directory.
      --private-key <PRIVATE_KEY>
          The private key to use for the deployment. Overrides the `PRIVATE_KEY` environment variable.
      --network <NETWORK>
          The network to deploy to. Overrides the `NETWORK` environment variable.
      --endpoint <ENDPOINT>
          The endpoint to deploy to. Overrides the `ENDPOINT` environment variable.
      --devnet
          Whether the network is a devnet. If not set, defaults to the `DEVNET` environment variable.
      --consensus-heights <CONSENSUS_HEIGHTS>
          Optional consensus heights to use. This should only be set if you are using a custom devnet.
  -y, --yes
          Don't ask for confirmation. DO NOT SET THIS FLAG UNLESS YOU KNOW WHAT YOU ARE DOING
      --consensus-version <CONSENSUS_VERSION>
          Consensus version to use. If one is not provided, the CLI will attempt to determine it from the latest block.
      --max-wait <MAX_WAIT>
          Seconds to wait for a block to appear when searching for a transaction. [default: 8]
      --blocks-to-check <BLOCKS_TO_CHECK>
          Number of blocks to look at when searching for a transaction. [default: 12]
      --skip <SKIP>...
          Skips deployment of any program that contains one of the given substrings.
      --offline
          Enables offline mode.
      --enable-ast-spans
          Enable spans in AST snapshots.
      --path <PATH>
          Path to Leo program root folder
      --enable-dce
          Enables dead code elimination in the compiler.
      --home <HOME>
          Path to aleo program registry
      --conditional-block-max-depth <CONDITIONAL_BLOCK_MAX_DEPTH>
          Max depth to type check nested conditionals. [default: 10]
      --disable-conditional-branch-type-checking
          Disable type checking of nested conditional branches in finalize scope.
      --enable-initial-ast-snapshot
          Write an AST snapshot immediately after parsing.
      --enable-all-ast-snapshots
          Writes all AST snapshots for the different compiler phases.
      --ast-snapshots <AST_SNAPSHOTS>...
          Comma separated list of passes whose AST snapshots to capture.
      --build-tests
          Build tests along with the main program and dependencies.
      --no-cache
          Don't use the dependency cache.
      --no-local
          Don't use the local source code.
  -h, --help
          Print help


A Quick Example
When you run leo new, it creates a new Leo project with default files and directories, including a .env file. The defaults in the .env file are set to deploy on a testnet devnet using a local node API endpoint. The defaults are set to deploy on a local devnet with the testnet configuration using a local node API endpoint.

To test the deployment, run a devnet via leo devnet (you'll need to configure it appropriately and run it in a separate terminal) and then run:

> leo deploy  --devnet --broadcast
       Leo
2 statements before dead code elimination.
       Leo     2 statements after dead code elimination.
       Leo     The program checksum is: '[96u8, 221u8, 32u8, 227u8, 44u8, 46u8, 93u8, 242u8, 17u8, 214u8, 17u8, 134u8, 170u8, 250u8, 59u8, 72u8, 48u8, 182u8, 210u8, 153u8, 135u8, 38u8, 214u8, 209u8, 12u8, 135u8, 252u8, 74u8, 132u8, 140u8, 123u8, 209u8]'.
       Leo âœ… Compiled 'helloworld.aleo' into Aleo instructions.

ðŸ“¢ Using the following consensus heights: 0,10,11,12,13,14,15,16,17
  To override, pass in `--consensus-heights` or override the environment variable `CONSENSUS_VERSION_HEIGHTS`.

Attempting to determine the consensus version from the latest block height at http://localhost:3030...

ðŸ› ï¸  Deployment Plan Summary
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ”§ Configuration:
  Private Key:        APrivateKey1zkp8CZNn3yeC...
  Address:            aleo1rhgdu77hgyqd3xjj8uc...
  Endpoint:           http://localhost:3030
  Network:            testnet
  Consensus Version:  9

ðŸ“¦ Deployment Tasks:
  â€¢ helloworld.aleo  â”‚ priority fee: 0  â”‚ fee record: no (public fee)

âš™ï¸ Actions:
  â€¢ Transaction(s) will NOT be printed to the console.
  â€¢ Transaction(s) will NOT be saved to a file.
  â€¢ Transaction(s) will be broadcast to http://localhost:3030
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

? Do you want to proceed with deployment? (y/n) â€º no
> leo deploy  --devnet --broadcast
       Leo
2 statements before dead code elimination.
       Leo     2 statements after dead code elimination.
       Leo     The program checksum is: '[96u8, 221u8, 32u8, 227u8, 44u8, 46u8, 93u8, 242u8, 17u8, 214u8, 17u8, 134u8, 170u8, 250u8, 59u8, 72u8, 48u8, 182u8, 210u8, 153u8, 135u8, 38u8, 214u8, 209u8, 12u8, 135u8, 252u8, 74u8, 132u8, 140u8, 123u8, 209u8]'.
       Leo âœ… Compiled 'helloworld.aleo' into Aleo instructions.

ðŸ“¢ Using the following consensus heights: 0,10,11,12,13,14,15,16,17
  To override, pass in `--consensus-heights` or override the environment variable `CONSENSUS_VERSION_HEIGHTS`.

Attempting to determine the consensus version from the latest block height at http://localhost:3030...

ðŸ› ï¸  Deployment Plan Summary
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ”§ Configuration:
  Private Key:        APrivateKey1zkp8CZNn3yeC...
  Address:            aleo1rhgdu77hgyqd3xjj8uc...
  Endpoint:           http://localhost:3030
  Network:            testnet
  Consensus Version:  9

ðŸ“¦ Deployment Tasks:
  â€¢ helloworld.aleo  â”‚ priority fee: 0  â”‚ fee record: no (public fee)

âš™ï¸ Actions:
  â€¢ Transaction(s) will NOT be printed to the console.
  â€¢ Transaction(s) will NOT be saved to a file.
  â€¢ Transaction(s) will be broadcast to http://localhost:3030
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ” Do you want to proceed with deployment? Â· yes


ðŸ”§ Your program 'helloworld.aleo' has the following constructor.
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
constructor:
    assert.eq edition 0u16;
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Once it is deployed, it CANNOT be changed.

âœ” Would you like to proceed? Â· yes

ðŸ“¦ Creating deployment transaction for 'helloworld.aleo'...


ðŸ“Š Deployment Summary for helloworld.aleo
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Total Variables:      16,995
  Total Constraints:    12,927
  Max Variables:        2,097,152
  Max Constraints:      2,097,152

ðŸ’° Cost Breakdown (credits)
  Transaction Storage:  0.879000
  Program Synthesis:    0.748050
  Namespace:            1.000000
  Constructor:          0.050000
  Priority Fee:         0.000000
  Total Fee:            2.677050
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ðŸ“¡ Broadcasting deployment for helloworld.aleo...
ðŸ’°Your current public balance is 93749999.894112 credits.

âœ” This transaction will cost you 2.67705 credits. Do you want to proceed? Â· yes

âœ‰ï¸ Broadcasted transaction with:
  - transaction ID: 'at1wnrupt8fvsck0jll4mu94e23uhmgwhjpftaazcephm8nu0yyvqrsm27apa'
  - fee ID: 'au1rqczm86uw6jwcx8ychgvy677axrsh2vjjz8kh0cmpaw87xyp7q9q20fpa7'
  - fee transaction ID: 'at12rgh8c58sc0npxusg065p6xrsrk60pmfg02t5047rf5dp096g5ysdftz4f'
    (use this to check for rejected transactions)

ðŸ”„ Searching up to 12 blocks to confirm transaction (this may take several seconds)...
Explored 2 blocks.
Transaction accepted.
âœ… Deployment confirmed!


Leo will:

Compile the program and generate the necessary AVM instructions.
Tell you the program's checksum, which is a unique identifier for the program's code.
Display a deployment summary, including the total number of variables and constraints.
Ask for confirmation before proceeding with the deployment.
Broadcast the deployment transaction to the specified network.
Wait for the transaction to be confirmed and display the transaction ID.
Upgrading a Program
If your program is already deployed, you can upgrade it using the leo upgrade command. The upgrade will only work if your program is upgradable, meaning it has a constructor that allows for upgrades. See the Upgradability Guide for more details on how to make your program upgradable.

Options and Environment Variables
The target network, the Private Key, and a node API endpoint need to be specified for a deployment or upgrade. They can be set in one of the following ways, in order of precedence:

CLI options,
environment variables, or
3 .env file:
The options are selected in that order of precedence. For example, if the --network option is specified, it will override the value in the .env file. A .env file should be formatted as follows:

NETWORK=testnet
PRIVATE_KEY=APrivateKey1z...GPWH
ENDPOINT=https://api.explorer.provable.com/v1

If you are deploying to a local devnet, use the --devnet flag.


Executing Your Programs
The leo execute command executes the Leo program and outputs a transaction object

leo execute <FUNCTION_NAME> <INPUT_1> <INPUT_2> ...


Optionally, you can execute a function in a remote Leo program by using

leo execute <PROGRAM_NAME>.aleo/<FUNCTION_NAME> <INPUT_1> <INPUT_2> ...


If executing a function from a local program, the leo execute command will first build/compile that program:

console output:
       Leo     2 statements before dead code elimination.
       Leo     2 statements after dead code elimination.
       Leo     The program checksum is: '[212u8, 91u8, ... , 107u8]'.
       Leo âœ… Compiled 'hello.aleo' into Aleo instructions.



It will then print out the summary of the execution plan with

ðŸš€ Execution Plan Summary
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ”§ Configuration:
  Private Key:        APrivateKey1zkp...
  Address:            aleo1...
  Endpoint:           https://api.explorer.provable.com/v1
  Network:            <testnet | mainnet>
  Consensus Version:  9

ðŸŽ¯ Execution Target:
  Program:        <PROGRAM_NAME>
  Function:       <FUNCTION_NAME>
  Source:         <local | remote>

ðŸ’¸ Fee Info:
  Priority Fee:   0 Î¼credits
  Fee Record:     no (public fee)

âš™ï¸ Actions:
  - Transaction will NOT be printed to the console.
  - Transaction will NOT be saved to a file.
  - Transaction will NOT be broadcast to the network.


Finally, an execution cost breakdown will be printed alongside any outputs from the function itself.

ðŸ“Š Execution Summary for <PROGRAM_NAME>
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ’° Cost Breakdown (credits)
  Transaction Storage:  0.001316
  Onâ€‘chain Execution:   0.000000
  Priority Fee:         0.000000
  Total Fee:            0.001316
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âž¡ï¸  Output

  â€¢ <OUTPUT_1>
  â€¢ <OUTPUT_2>
  ...

Under the hood, leo execute produces a JSON object. This is a Transaction that can be broadcast to the Aleo network. You can view this JSON by passing the --print flag to leo execute.

Signing and Verifying
In addition to creating accounts, leo account can be used to sign data and verify signatures. This can be useful for a particular class of applications that rely on signed data as input.

Signing
The leo account sign command enables developers and users to create cryptographic signatures using an Aleo private key. These signatures can be verified within leo using the signature::verify function or with the leo account verify command.

To generate a signature for Leo and Aleo values, run the following:

# replace `5field` with any aleo value
leo account sign --private-key {$PRIVATE_KEY} -m 5field

# Output:
sign1...


To generate a signature for any plaintext, use the --raw flag:

# replace "Hello, Aleo" with any plaintext message
leo account sign --private-key {$PRIVATE_KEY} -raw -m "Hello, Aleo"

# Output:
sign1...


There are a few alternatives to using the --private-key flag:

--private-key-file <path/to/file> - read a private key from a text file
no flags - read a private key from environment, or .env
Verifying
To complement with the leo account sign command, the leo account verify command verifies the signatures of Aleo values and plaintext messages.

To verify signed aleo values, run:

# replace `5field` with the message and `sign1signaturehere` with the signature
leo account verify -a {$ADDRESS} -m 5field -s sign1signaturehere

# Output:
âœ… The signature is valid

# Error Output:
Error [ECLI0377002]: cli error: âŒ The signature is invalid


To verify signatures of signed plaintext values, run:

# replace "Hello, Aleo" with the message and `sign1signaturehere` with the signature
leo account verify -a {$ADDRESS} --raw -m "Hello, Aleo" -s sign1signaturehere

# Output:
âœ… The signature is valid

# Error Output:
Error [ECLI0377002]: cli error: âŒ The signature i

Querying Network Metadata and State
Coming soon!

Running a Devnet
A local devnet can be a heavyweight but reliable way to test your application on Aleo.

Setup
The Leo CLI provides a helpful command to help startup a local devnet:

leo devnet --snarkos <SNARKOS> --snarkos-features test_network


The <SNARKOS> is the path to an installed binary of snarkOS, the decentralized operating system that forms the backbone of the Aleo network.

If you don't have snarkOS installed, you can pass the --install flag and the CLI will automatically download, compile, and store the binary at the path specified by <SNARKOS>.

leo devnet --snarkos <SNARKOS> --snarkos-features test_network --install


info
Windows users will need to perform some additional steps in order for snarkOS to install properly:

Upon initially installing Rust, you should have been automatically been prompted to install Visual Studio with the MSVC 2022 C++ build tools.
Open the Visual Studio Installer and install the C++ Clang Compiler for Windows and either the Windows 10 SDK or Windows 11 SDK (depending on your OS). Make a note of the installation path of the installed tool. It should be of the form {PATH}\Microsoft Visual Studio\2022\BuildTools.
Within the aforementioned build tools directory, you should find the location of a file called libclang.dll. For x86-based systems, this should be in the VC\Tools\Llvm\bin subdirectory. For x64-based systems, this should be in the VC\Tools\Llvm\x64\bin subdirectory.
Once you have the full path of libclang.dll, create the LIBCLANG_PATH environment variable for your system and set it to this path.
snarkOS should now compile and run properly.
The tmux command will allow you to toggle between nodes in your local devnet. You can enable this by passing the --tmux flag upon startup:

leo devnet --snarkos <SNARKOS> --snarkos-features test_network --tmux


info
This feature is only available on Unix-based systems.

You'll need to install the tmux package first:

To install tmux on macOS, you can use the Homebrew package manager. If you haven't installed Homebrew yet, you can find instructions at their website. Once Homebrew is installed, run:

brew install tmux

On Ubuntu and other Debian-based systems, you can use the apt package manager:
sudo apt update
sudo apt install tmux

Here are some useful (default) commands in tmux:

# To toggle to the next node in a local devnet
Ctrl+b n 
# To toggle to the previous node in a local devnet
Ctrl+b p 
# To scroll easily, press q to quit
Ctrl+b q
# To select a node in a local devnet
Ctrl+b w 
# To select a node manually in a local devnet
Ctrl+b :select-window -t {NODE_ID}
# To stop a local devnet
Ctrl+b :kill-session


See the full leo devnet CLI documentation here

Usage
When you start the devnet, the CLI will actually spin up a new instance of the blockchain from genesis via the snarkOS binary. This means that the chain will start at block 0 and consensus version 1, and the only program deployed will be credits.aleo.

The height of the chain will increase as blocks are produced. At various different heights, a new consensus version will activate, which will unlock various features that have been implemented as the Aleo network has matured. By default, the devnet will assume the predefined consensus heights from Testnet:

(ConsensusVersion::V1, 0),
(ConsensusVersion::V2, 2_950_000),
(ConsensusVersion::V3, 4_800_000),
(ConsensusVersion::V4, 6_625_000),
(ConsensusVersion::V5, 6_765_000),
(ConsensusVersion::V6, 7_600_000),
(ConsensusVersion::V7, 8_365_000),
(ConsensusVersion::V8, 9_173_000),
(ConsensusVersion::V9, 9_800_000),
(ConsensusVersion::V10, 10_525_000),
(ConsensusVersion::V11, 11_952_000),

Obviously you don't have time to wait for 10 million blocks to access a newer feature like program upgradability, so leo devnet provides a way to manually set the consensus heights via the --consensus-heights flag:

leo devnet --snarkos <SNARKOS> --snarkos-features test_network --consensus-heights 0,1,2,3,4,5,6,7,8,9,10


Note that if you want to access the latest features, the number of comma-separated arguments you pass to this flag must be exactly equal to the latest consensus version.

Each time you stop and restart the chain, the prior state and history will be saved. You can clear any prior history by passing the --clear-storage flag:

leo devnet --snarkos <SNARKOS> --snarkos-features test_network --clear-storage


Clearing the ledger history may be useful if you wish to redeploy your program without changing the name. However, this will erase all transaction history and start a new instance of the Aleo blockchain from genesis.

Deploying and Executing
When deploying or executing programs on a local devnet, make sure that endpoint is set to http://localhost:3030 rather than any external API endpoints. You can do this either by manually setting the ENDPOINT environment variable, by passing the --endpoint http://localhost:3030 flag in the CLI, or by setting the ENDPOINT variable in a .env file within the root directory of your Leo project.

You will also need credits to fund transactions on the devnet. snarkOS automatically initializes four development accounts funded with Aleo credits that can be used for testing purposes.

# Account 0
APrivateKey1zkp8CZNn3yeCseEtxuVPbDCwSyhGW6yZKUYKfgXmcpoGPWH
AViewKey1mSnpFFC8Mj4fXbK5YiWgZ3mjiV8CxA79bYNa8ymUpTrw
aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px

# Account 1
APrivateKey1zkp2RWGDcde3efb89rjhME1VYA8QMxcxep5DShNBR6n8Yjh
AViewKey1pTzjTxeAYuDpACpz2k72xQoVXvfY4bJHrjeAQp6Ywe5g
aleo1s3ws5tra87fjycnjrwsjcrnw2qxr8jfqqdugnf0xzqqw29q9m5pqem2u4t

# Account 2
APrivateKey1zkp2GUmKbVsuc1NSj28pa1WTQuZaK5f1DQJAT6vPcHyWokG
AViewKey1u2X98p6HDbsv36ZQRL3RgxgiqYFr4dFzciMiZCB3MY7A
aleo1ashyu96tjwe63u0gtnnv8z5lhapdu4l5pjsl2kha7fv7hvz2eqxs5dz0rg

# Account 3
APrivateKey1zkpBjpEgLo4arVUkQmcLdKQMiAKGaHAQVVwmF8HQby8vdYs
AViewKey1iKKSsdnatHcm27goNC7SJxhqQrma1zkq91dfwBdxiADq
aleo12ux3gdauck0v60westgcpqj7v8rrcr3v346e4jtq04q7kkt22czsh808v2


You can specify the private key to use by manually setting the PRIVATE_KEY environment variable, by passing the --private-key http://localhost:3030 flag in the CLI, or by setting the PRIVATE_KEY variable in a .env file within the root directory of your Leo project.

Once your private key and endpoint have been correctly set, deploying and executing largely function the same as they would on Testnet or Mainnet. For more details on either of those processes, check out the Deploying and Executing guides.

Querying Transaction Status
You can check your transactions by using the following API endpoint:

GET http://localhost:3030/testnet/transaction/{TRANSACTION_ID}


or by using leo query from the CLI:

leo query transaction {TRANSACTION_ID}

The transaction API endpoint is instructive in verifying whether a transaction succeeded or failed. Since both successful and failed transaction execute a fee transaction, if only the fee transaction appears, that is a clear indication that the transaction has failed. Note that on the Testnet and on Mainnet, failed transactions still require a fee since the network is performing a computation.

A full list of API endpoints is available here

Record Scanning
You can use the CLI from your installed snarkOS binary to view your records. First, navigate to the directory where you installed the binary. The use the following command syntax:

./snarkos developer scan --endpoint http://localhost:3030 --private-key {YOUR_PRIVATE_KEY} --start <block_number> --network 1


Setting block_number to 0 will list all of the records created starting from the genesis block, including your test credit records.

sample output:
âš ï¸  Attention - Scanning the entire chain. This may take a while...

Scanning 3 blocks for records (100% complete)...   

[
  "{  owner: aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px.private,  microcredits: 23437500000000u64.private,  _nonce: 3666670146276262240199958044811329632452609778779651964870759629195088099828group.public}",
  "{  owner: aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px.private,  microcredits: 23437500000000u64.private,  _nonce: 4536868268814456227312360347031739423312689137706933033938812386306238998060group.public}",
  "{  owner: aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px.private,  microcredits: 23437500000000u64.private,  _nonce: 205967862164714901379497326815256981526025583494109091059194305832749867953group.public}",
  "{  owner: aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px.private,  microcredits: 23437500000000u64.private,  _nonce: 4424806931746512507605174575961455750579179367541686805196254590136284583805group.public}"
]


Setting block_number to 1 or higher will exclude the above credit records from the scan.


Testing, Testing, 123
Once deployed, an application lives on the ledger forever. Consequently, it's important to consider every edge case and rigorously test your code. There are number of tools and techniques you can use.

Unit and Integration Testing - Validate Leo program logic through test cases.

Running a Devnet - Deploy and execute on a local devnet.

Deploying/Executing on Testnet - Deploy and execute on the Aleo Testnet.

Other Tools - Tools and methodologies developed by the open-source Aleo community.

Unit and Integration Testing
The Leo testing framework enables developers to validate their Leo program logic by writing unit and integration tests. Tests are written in Leo and are located in a tests/ subdirectory of the main Leo project directory.

example_program
â”œâ”€â”€ build
â”‚   â”œâ”€â”€ imports
â”‚   â”‚   â””â”€â”€ test_example_program.aleo
â”‚   â”œâ”€â”€ main.aleo
â”‚   â””â”€â”€ program.json
â”œâ”€â”€ outputs
â”œâ”€â”€ src
â”‚   â””â”€â”€ main.leo
â”œâ”€â”€ tests
â”‚   â””â”€â”€ test_example_program.leo
â””â”€â”€ program.json

The test file is a Leo program that imports the program in main.leo. The test functions will all be annotated with @test above the function declaration.

This tutorial will use an example program which can be found in the example's repository.

info
Developers can add multiple leo files to the test directory but must ensure that the name of the test file matches the program name within that test file. For example, if the name of the test file is test_example_program.leo, the program name in that file must be test_example_program.aleo.

Testing transition Functions
The example_program.leo program contains a transition function which returns the sum of two u32 inputs.

transition simple_addition(public a: u32, b: u32) -> u32 {
    let c: u32 = a + b;
    return c;
}


The test_example_program.leo contains two tests to ensure that the transition logic returns a correct output and fails when the output does not match the sum of the input values.

@test
transition test_simple_addition() {
    let result: u32 = example_program.aleo/simple_addition(2u32, 3u32);
    assert_eq(result, 5u32);
}


The @should_fail annotation should be added after the @test annotation for tests that are expected to fail.

@test
@should_fail
transition test_simple_addition_fail() {
    let result: u32 = example_program.aleo/simple_addition(2u32, 3u32);
    assert_eq(result, 3u32);
}


Testing Leo Types
Developers can test that record and struct fields match their expected values. In example_program.leo, a record is minted transition function shown here:

record Example {
    owner: address,
    x: field,
}

transition mint_record(x: field) -> Example {
    return Example {
        owner: self.signer,
        x,
    };
}

The corresponding test in test_example_program.leo checks that the Record field contains the correct value:

@test
transition test_record_maker() {
    let r: example_program.aleo/Example = example_program.aleo/mint_record(0field);
    assert_eq(r.x, 0field);
}


info
Each test file is required to have at least one transition function.

Modeling Onchain State
While the testing framework cannot access on-chain state from either testnet or mainnet, developers can simulate on-chain state in scripts. A script is interpreted Leo code in which developers are able to await Futures and update mappings using interpreted tests. When using interpreted tests, the transition or function keyword is replaced with the script keyword.

@test
script test_async() {
    const VAL: field = 12field;
    let fut: Future = example_program.aleo/set_mapping(VAL);
    fut.await();
    assert_eq(Mapping::get(example_program.aleo/map, 0field), VAL);

    let rand_val: field = ChaCha::rand_field();
    Mapping::set(example_program.aleo/map, VAL, rand_val);
    let value: field = Mapping::get(example_program.aleo/map, VAL);
    assert_eq(value, rand_val);
}


info
External transitions -- async or not -- may be called from test transitions or scripts, but external async functions may only be called directly from scripts.

Running Tests
Invoking the leo test command will run all of the compiled and interpreted tests. Developer may optionally select an individual tests by supplying a a test function name or a string that is contained within a test function name. For instance, to run the test for test_async, developers would use the following command:

leo test test_async

Either of the following commands will run both of the addition function tests:

leo test simple

or

leo test addition

See the leo test CLI documentation here

Running a Devnet
A local devnet can be a heavyweight but reliable way to test your application on Aleo.

For more information, refer the to Devnet guide

Deploying/Executing on Testnet
To deploy and execute on Testnet, you'll need to set your endpoint back to one of the public facing options. Additionally, you'll need to obtain Testnet credits from one of the faucets below:

Faucets
At some point you'll need testnet credits. There are a few community-supported faucets to choose from:

Puzzle - 15 credits / 4 hours

Demox - 10 credits / 12 hours

The faucets are periodically refreshed.

Other Tools
The Aleo community has developed some neat tools to aid in testing.

doko.js

Debuggin' Out
leo debug is a powerful tool that developers can use to interactively step through executions and track down bugs. In this workshop, we'll use the Leo debugger to explore and gain a deeper understanding of a variety of programs. You will also build up the skills to adeptly use the debugger in your development work.

This tutorial assumes that you are already familiar with Leo.

Setup
Source Material
Download the latest version of the workshop.

Leo
Install Leo. You may also use the install script in the workshop.

An Introduction
First, let's fire up the debugger.

leo debug

You'll see this prompt pop up.

This is the Leo Interpreter. Try the command `#help`. ? Command? â€º
Let's go ahead and run the #help command.

âœ” Command? Â· #help You probably want to start by running a function or transition. For instance #into program.aleo/main() Once a function is running, commands include #into    to evaluate into the next expression or statement; #step    to take one step towards evaluating the current expression or statement; #over    to complete evaluating the current expression or statement; #run     to finish evaluating #quit    to quit the interpreter. You can set a breakpoint with #break program_name line_number When executing Aleo VM code, you can print the value of a register like this: #print 2 Some of the commands may be run with one letter abbreviations, such as #i. Note that this interpreter is not line oriented as in many common debuggers; rather it is oriented around expressions and statements. As you step into code, individual expressions or statements will be evaluated one by one, including arguments of function calls. You may simply enter Leo expressions or statements on the command line to evaluate. For instance, if you want to see the value of a variable w: w If you want to set w to a new value: w = z + 2u8; Note that statements (like the assignment above) must end with a semicolon. If there are futures available to be executed, they will be listed by numerical index, and you may run them using `#future` (or `#f`); for instance #future 0 The interpreter begins in a global context, not in any Leo program. You can set the current program with #set_program program_name This allows you to refer to structs and other items in the indicated program. The interpreter may enter an invalid state, often due to Leo code entered at the REPL. In this case, you may use the command #restore Which will restore to the last saved state of the interpreter. Any time you enter Leo code at the prompt, interpreter state is saved. Input history is available - use the up and down arrow keys.
The leo debug initializes a REPL loop in which you may run standalone Leo code.

âœ” Command? Â· 1u32 + 2u32 Result: 3u32 âœ” Command? Â· let x: u32 = 1u32; âœ” Command? Â· let y: u32 = 2u32; âœ” Command? Â· let z: u32 = x + y; âœ” Command? Â· x Result: 1u32 âœ” Command? Â· y Result: 2u32 âœ” Command? Â· z Result: 3u32
More often than not, you'll be using the debugger to step through a program. Let's see how that works.

First, let's go to the program under investigation. In the directory where you installed the source material, run

cd workshop/learn_to_debug/point_math
leo debug

The debugger will type check the point_math.aleo and initialize a REPL loop with access to the program definition. In additional to directly evaluating Leo code, the debugger provides commands with which the user can selectively step through code:

#into | #i - to evaluate into the next expression or statement
#step | #s - to take one step towards evaluating the current expression or statement
#over | #o - to complete evaluating the current expression or statement
#run | #r - to finish evaluating
#break | #b <PROGRAM_NAME> <LINE_NUMBER> - to set a breakpoint
#watch | #w <EXPRESSION> - to watch an expression. It's value will be printed out each step of the interpreter.
#into is particularly useful as users can prefix a Leo statement or expression with an #into command to step through the associated code. We'll now use the debugger to step through an evaluation of the sqrt_bitwise function.

âœ” Command? Â· #i point_math.aleo/sqrt_bitwise(0u32) Prepared to evaluate:point_math.aleo/sqrt_bitwise(0u32)âœ” Command? Â· #i Prepared to evaluate: point_math.aleo/sqrt_bitwise(0u32) âœ” Command? Â· #s Result: 0u32 Prepared to evaluate:point_math.aleo/sqrt_bitwise(0u32)âœ” Command? Â· #s Prepared to evaluate:point_math.aleo/sqrt_bitwise(0u32)âœ” Command? Â· #s Result: 0u32
Challenge
Use the above commands to step through evaluations of sqrt_bitwise for inputs 0u32, 1u32, 4u32, 9u32. Are they as you expect?

Use the debugger and the above commands to: a. Create and store two distinct Point records. b. Calculate the distance between them. c. Add the points together.

Solution
Transcripts for each of the above challenges are given below.

Part 1
âœ” Command? Â· #i point_math.aleo/sqrt_bitwise(0u32) Prepared to evaluate: point_math.aleo/sqrt_bitwise(0u32) âœ” Command? Â· #o Result: 0u32### Cheatsheet ``` You probably want to start by running a function or transition. For instance #into program.aleo/main() Once a function is running, commands include #into    to evaluate into the next expression or statement; #step    to take one step towards evaluating the current expression or statement; #over    to complete evaluating the current expression or statement; #run     to finish evaluating #quit    to quit the interpreter. You can set a breakpoint with #break program_name line_number When executing Aleo VM code, you can print the value of a register like this: #print 2 Some of the commands may be run with one letter abbreviations, such as #i. Note that this interpreter is not line oriented as in many common debuggers; rather it is oriented around expressions and statements. As you step into code, individual expressions or statements will be evaluated one by one, including arguments of function calls. You may simply enter Leo expressions or statements on the command line to evaluate. For instance, if you want to see the value of a variable w: w If you want to set w to a new value: w = z + 2u8; Note that statements (like the assignment above) must end with a semicolon. If there are futures available to be executed, they will be listed by numerical index, and you may run them using `#future` (or `#f`); for instance #future 0 The interpreter begins in a global context, not in any Leo program. You can set the current program with #set_program program_name This allows you to refer to structs and other items in the indicated program. The interpreter may enter an invalid state, often due to Leo code entered at the REPL. In this case, you may use the command #restore Which will restore to the last saved state of the interpreter. Any time you enter Leo code at the prompt, interpreter state is saved. Input history is available - use the up and down arrow keys. ``` âœ” Command? Â· #i point_math.aleo/sqrt_bitwise(1u32) Prepared to evaluate: point_math.aleo/sqrt_bitwise(1u32) âœ” Command? Â· #o Result: 1u32 âœ” Command? Â· #i point_math.aleo/sqrt_bitwise(4u32) Prepared to evaluate: point_math.aleo/sqrt_bitwise(4u32) âœ” Command? Â· #o Result: 2u32 âœ” Command? Â· #i point_math.aleo/sqrt_bitwise(9u32) Prepared to evaluate: point_math.aleo/sqrt_bitwise(9u32) âœ” Command? Â· #o Result: 3u32
Part 2
âœ” Command? Â· let p1: Point = point_math.aleo/create_point(1u32, 2u32); âœ” Command? Â· let p2: Point = point_math.aleo/create_point(3u32, 4u32); âœ” Command? Â· p1 Result: Point {owner: aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px, x: 1u32, y: 2u32} âœ” Command? Â· p2 Result: Point {owner: aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px, x: 3u32, y: 4u32} âœ” Command? Â· let distance: u32 = point_math.aleo/distance(p1, p2); âœ” Command? Â· distance Result: 2u32 âœ” Command? Â· let sum: Point = point_math.aleo/add_points(p1, p2); âœ” Command? Â· sum Result: Point {owner: aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px, x: 4u32, y: 6u32}
Pro Tips
The Leo debugger also provides a number of features to help with more advanced debugging. These will be helpful as you go through the more complex examples below.

Recovering From Errors
As you step through and evaluate code, you may run into a state where your debugger halts. This can happen for a number of reasons including, accessing values that don't exist, attempting to evaluate expressions that overflow, etc. If this happens, the #restore command can help you recover the debugger to the last code point.

Setting a Namespace
The Leo debugger initializes in a "global" context, which contains the programs and dependencies in your project. When you invoke a transition or function, the debugger implicitly steps into the associated program's scope.

You may find youself wanting to initialize structs and records defined in a specific program. To do so, you can explicitly set the program scope and directly instantiate data types.

By setting a program scope, you can also directly invoke functions and interact with mappings defined in that scope. This is useful as specifying the full path (program name and resource) can be cumbersome.

âœ” Command? Â· #set_program point_math âœ” Command? Â· let p: Point = Point { owner: self.caller, x: 1u32, y: 2u32 }; âœ” Command? Â· p Result: Point {owner: aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px, x: 1u32, y: 2u32} âœ” Command? Â· let a: u32 = sqrt_bitwise(0u32); âœ” Command? Â· a Result: 0u32
Cheatcodes
The debugger also provides users with a number of "cheatcodes" to aid in debugging. The supported cheatcodes include:

CheatCode::print_mapping(<MAPPING>)
CheatCode::set_block_height(<u32>)
GUI
The Leo debugger also provides a user with a more sophisticated GUI, which can help step through code cleanly. The interface can be enabled with the --tui command and provides better code visualization, where the current line is highlighted.

â”Œcodeâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    }                                                                                                 â”‚
â”‚                                                                                                      â”‚
â”‚    // An implementation of integer square root.                                                      â”‚
â”‚    function sqrt_bitwise(n: u32) -> u32 {                                                            â”‚
â”‚        <b>let res: u32 = 0u32;</b>                                                                   â”‚
â”‚        // Iterate over all 32 bits from most significant to least significant                        â”‚
â”‚        for inv_shift: u8 in 0u8..32u8 {                                                              â”‚
â”‚            let shift: u8 = 31u8 - inv_shift;                                                         â”‚
â”‚            let bit: u32 = 1u32 << shift;                                                             â”‚
â”‚            let temp: u32  = res | bit;                                                               â”‚
â”‚            // Check if temp is safe to square without overflow                                       â”‚
â”‚            if temp <= 65535u32 { // âˆš(2^32 - 1) = 65535                                              â”‚
â”‚                let square: u32 = temp.mul_wrapped(temp);                                             â”‚
â”‚                if square <= n {                                                                      â”‚
â”‚                    res = temp; // Update res if temp^2 <= n                                          â”‚
â”‚                }                                                                                     â”‚
â”‚            }                                                                                         â”‚
â”‚        }                                                                                             â”‚
â”‚        return res;                                                                                   â”‚
â”‚    }                                                                                                 â”‚
â”‚                                                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”ŒResultâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”ŒWatchpointsâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚0u32                                              â”‚â”‚                                                  â”‚
â”‚                                                  â”‚â”‚                                                  â”‚
â”‚                                                  â”‚â”‚                                                  â”‚
â”‚                                                  â”‚â”‚                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”ŒMessageâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”ŒCommand:â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


A More Complicated Example
In the previous example, we use leo debug to evaluate simple transitions with strictly off-chain execution. The debugger can also be used to evaluate on-chain code.

Let's dive in further by looking at some code. First let's navigate to the code and fire up the debugger.

cd workshop/learn_to_debug/access_control
leo debug

Using the debugger, a user can directly produce and evaluate futures. Users can also interact with mappings by directly executing Leo code.

âœ” Command? Â· #set_program access_control âœ” Command? Â· let f: Future = set_timelock(self.caller, 1u32); âœ” Command? Â· f.await() Result: () âœ” Command? Â· CheatCode::print_mapping(timelocks) Mapping: timelocks Metadata {locker: aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px, lockee: aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px} -> 1u32 Result: () âœ” Command? Â· let m: Metadata = Metadata { locker: self.caller, lockee: self.caller }; âœ” Command? Â· timelocks.get(m) Result: 1u32 âœ” Command? Â· timelocks.set(m, 2u32); âœ” Command? Â· timelocks.get(m) Result: 2u32
Challenge
Navigate to the timelocked_credits example and fire up the debugger.

cd workshop/learn_to_debug/timelocked_credits
leo debug

Deposit 10 credits. Note that you'll need to set the state of the account mapping in credits.aleo.
Increment the block height by 1 and attempt to withdraw.
Increment the block height by 3 and withdraw.
While you are stepping through the code, be sure to the use the #i and #s commands to visualize the flow of the execution.

Debugging AVM Bytecode
You may also use the Leo debugger to step through AVM bytecode. This can be useful for debugging programs that may be deployed on-chain, but whose Leo source code is not available.

The debugger provides the #print | #p <REGISTER_NUMBER> command to display register values.

Challenge
Go to the Provable Explorer and pick out a program. Note that this program needs to be deployed on the same network that you have configured in your .env file. You can always default to credits.aleo.

Add the program as a dev dependency via leo add.

Step through an execution of the program.

Wrapping it Up
In this tutorial, you learned how to use the Leo debugger. If you made it through all of the challenges you will have:

Stepped through simple, local evaluations of a program.
Simulated on-chain state to test more complex behaviors.
Explicitly evaluated futures, giving you a better understanding of the async programming model.
Debugged a deployed program that you may not have written directly.
We hope that this tool makes your Leo development experience easier! If you have any feedback or run into any issues, please feel free to file an issue here on the Leo repo.

Upgrading Programs
A Developer's Guide to Upgradability in Leo
This guide provides a practical overview of Aleo's program upgradability framework, tailored for developers using the Leo language. You'll learn how to configure your program, implement common upgrade patterns, and follow best practices for writing secure, maintainable applications. For more details on the underlying protocol, refer to the Aleo docs.

Getting Started: The Upgrade Policy
Your program's upgrade policy is defined by an annotation on a constructor (see below) in the Leo program. The Leo compiler reads the annotation to understand your intent and generates the appropriate underlying code.

There are four primary upgrade modes:

Mode	Description
@noupgrade	The program is not upgradable.
@admin	Upgrades are controlled by a single, hardcoded admin address.
@checksum	Upgrades are governed by an on-chain checksum, often managed by a separate program (e.g., a DAO).
@custom	You write the entire upgrade logic from scratch in the constructor.
Core Mechanics
Upgradability revolves around a special constructor function and on-chain program metadata.

The constructor
The constructor is a special function that runs on-chain during every deployment and upgrade. Think of it as the gatekeeper for your program. There are two key properties of the constructor related to upgradability:

Foundational: All programs must be deployed with a constructor. If the constructor logic fails (e.g., a failed assert), the entire deployment or upgrade transaction is rejected.
Immutable: The logic inside the constructor is set in stone at the first deployment. It can never be changed by a future upgrade. Any bugs introduced here are permanent, so audit your constructor carefully.
Program Metadata Operands
Within a constructor, you can access on-chain metadata about the program using the self keyword.

Operand	Leo Type	Description
self.edition	u16	The program's version number. Starts at 0 and is incremented by 1 for each upgrade. The edition is tracked automatically on the network.
self.program_owner	address	The address that submitted the deployment transaction.
self.checksum	[u8, 32]	The program's checksum, which is a unique identifier for the program's code.
You may also refer to other program's metadata by qualifying the operand with the program name, like Program::edition(credits.aleo), Program::program_owner(foo.aleo). You will need to import the program in your Leo file to use this syntax.

Note. Programs deployed before the upgradability feature (i.e. using Leo version < v3.1.0) do not have a program_owner. Attempting to access it will result in a runtime error.

Upgrade Patterns in Leo
Below are some common upgrade patterns in Leo.

You may also refer to the working Leo examples.

Pattern 1: Non-Upgradable
Goal: Explicitly prevent all future upgrades.

main.leo

The Leo compiler automatically generates a constructor that locks the program to its initial version.

// The 'noupgrade_example' program.
program noupgrade_example.aleo {
    // This constructor is for the "noupgrade" mode.
    // It is immutable and prevents any future upgrades.
    @noupgrade
    async constructor() {
        // The Leo compiler automatically generates the constructor logic.
    }
    
    transition main(public a: u32, b: u32) -> u32 {
        let c: u32 = a + b;
        return c;
    }
}


The corresponding AVM code is:

constructor:
    assert.eq edition 0u16

Pattern 2: Admin-Driven Upgrade
Goal: Restrict upgrades to a single, hardcoded admin address.

main.leo

// The 'admin_example' program.
program admin_example.aleo {
    // This constructor is for the "admin" mode.
    // It ensures that only the designated admin can upgrade the program.
    @admin(address="aleo1rhgdu77hgyqd3xjj8ucu3jj9r2p3lam3tc3h0nvv2d3k0rp2ca5sqsceh7")
    async constructor() {
        // The Leo compiler automatically generates the constructor logic.
    }
    
    transition main(public a: u32, b: u32) -> u32 {
        let c: u32 = a + b;
        return c;
    }
}


The corresponding AVM code is:

constructor:
    assert.eq program_owner aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px;


Pattern 3: Checksum-Driven (Vote Example)
Goal: Delegate upgrade authority to a separate governance program that manages a list of approved code checksums.

main.leo

The compiler uses the mapping and key fields to generate a constructor that looks up the approved checksum from the basic_voting.aleo program.

// The 'vote_example' program.
program vote_example.aleo {
    // This constructor is for the "checksum" mode.
    @checksum(mapping="basic_voting.aleo/approved_checksum", key="true")
    async constructor() {
        // The Leo compiler automatically generates the constructor logic.
    }
    
    transition main(public a: u32, b: u32) -> u32 {
        let c: u32 = a + b;
        return c;
    }
}


The corresponding AVM code is:

constructor:
    branch.eq edition 0u16 to end;
    get basic_voting.aleo/approved_checksum[true] into r0;
    assert.eq checksum r0;
    position end;


Pattern 4: Custom Logic (Time-lock Example)
Goal: Enforce a time delay before an upgrade is allowed. No pre-defined mode is available for this so we'll have to write our own upgrade policy

main.leo

With the @custom constructor, you are responsible for writing the entire constructor logic yourself.

// The 'timelock_example' program.
program timelock_example.aleo {
    @custom
    async constructor() {
        // For upgrades (edition > 0), enforce a block height condition on when the constructor can be called successfully
        if self.edition > 0u16 {
            assert(block.height >= 1300u32);
        }
    }
    
    transition main(public a: u32, b: u32) -> u32 {
        let c: u32 = a + b;
        return c;
    }
}


The corresponding AVM code is:

constructor:
    gt edition 0u16 into r0;
    branch.eq r0 false to end_then_0_0;
    gte block.height 1300u32 into r1;
    assert.eq r1 true;
    branch.eq true true to end_otherwise_0_1;
    position end_then_0_0;
    position end_otherwise_0_1;

The Rules: What You Can and Cannot Change
The protocol enforces strict rules to ensure that upgrades don't break dependent applications or corrupt existing state.

An upgrade can:

Change the internal logic of existing transition and async functions blocks.
Add new structs, records, mappings, transitions, and functions.
An upgrade cannot:

Change the input or output signatures of any existing transition, function, async transition, or async function.
Change the logic within a non-inline function.
Modify or delete any existing struct, record, or mapping.
Delete any existing program component.
Program Component	Delete	Modify	Add
import	âŒ	âŒ	âœ…
struct	âŒ	âŒ	âœ…
record	âŒ	âŒ	âœ…
mapping	âŒ	âŒ	âœ…
function	âŒ	âŒ	âœ…
transition	âŒ	âœ… (logic)	âœ…
async function	âŒ	âœ… (logic)	âœ…
constructor	âŒ	âŒ	âŒ
Security Checklist
Program mutability introduces new risks. Keep these points in mind:

Audit the constructor intensely. Its logic is permanent and cannot be fixed after deployment.
Prefer multi-sig or DAO governance over a single admin. A single point of failure is risky.
Implement time-locks for major upgrades. Giving users a window to react builds trust.
Plan for "ossification". Provide a way to make your program immutable (e.g., by transferring admin rights to a burn address) to give users long-term certainty.
Legacy Programs
If you have a program that was deployed before the upgradability feature was enabled (or any program deployed without a constructor):

It is permanently non-upgradable.

There is no migration path to make a legacy program upgradable. If you need to add new features, you must deploy an entirely new program and have your users migrate to it.

A Private Auction using Leo
Source Code

Summary
A first-price sealed-bid auction (or blind auction) is a type of auction in which each participant submits a bid without knowing the bids of the other participants. The bidder with the highest bid wins the auction.

In this model, there are two kinds of parties: the auctioneer and the bidders.

Bidder: A participant in the auction.
Auctioneer: The party responsible for conducting the auction.
We make following assumptions about the auction:

The auctioneer is honest. That is, the auctioneer will resolve all bids in the order they are received. The auctioneer will not tamper with the bids.
There is no limit to the number of bids.
The auctioneer knows the identity of all bidders, but bidders do not necessarily know the identity of other bidders.
Under this model, we require that:

Bidders do not learn any information about the value of other bids.
Auction Flow
The auction is conducted in a series of stages.

Bidding: In the bidding stage, bidders submit bids to the auctioneer. They do so by invoking the place_bid function.
Resolution: In the resolution stage, the auctioneer resolves the bids in the order they were received. The auctioneer does so by invoking the resolve function. The resolution process produces a single winning bid.
Finishing: In this stage, the auctioneer finishes the auction by invoking the finish function. This function returns the winning bid to the bidder, which the bidder can then use to claim the item.
Language Features and Concepts
record declarations
assert_eq
record ownership
How to Run
Follow the Leo Installation Instructions.

This auction program can be run using the following bash script. Locally, it will execute Leo program functions to conduct, bid, and close a three party auction.

cd leo/examples/auction
./run.sh

The .env file contains a private key and address. This is the account that will be used to sign transactions and is checked for record ownership. When executing programs as different parties, be sure to set the private_key field in .env to the appropriate value. You can check out how we've set things up in ./run.sh for a full example of how to run the program as different parties.

Walkthrough
Step 0: Initializing the Auction
Step 1: The First Bid
Step 2: The Second Bid
Step 3: Select the Winner
Step 0: Initializing the Auction
The three parties we'll be emulating are as follows:

Bidder 1 Private Key:  
APrivateKey1zkpG9Af9z5Ha4ejVyMCqVFXRKknSm8L1ELEwcc4htk9YhVK
Bidder 1 Address: 
aleo1yzlta2q5h8t0fqe0v6dyh9mtv4aggd53fgzr068jvplqhvqsnvzq7pj2ke

Bidder 2 Private Key:
APrivateKey1zkpAFshdsj2EqQzXh5zHceDapFWVCwR6wMCJFfkLYRKupug
Bidder 2 Address:
aleo1esqchvevwn7n5p84e735w4dtwt2hdtu4dpguwgwy94tsxm2p7qpqmlrta4

Auctioneer Private Key:
APrivateKey1zkp5wvamYgK3WCAdpBQxZqQX8XnuN2u11Y6QprZTriVwZVc
Auctioneer Address:
aleo1fxs9s0w97lmkwlcmgn0z3nuxufdee5yck9wqrs0umevp7qs0sg9q5xxxzh


Step 1: The First Bid
Have the first bidder place a bid of 10.

Swap in the private key and address of the first bidder to .env.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkpG9Af9z5Ha4ejVyMCqVFXRKknSm8L1ELEwcc4htk9YhVK
ENDPOINT=https://localhost:3030
" > .env


Call the place_bid program function with bidder 1 and 10u64 arguments.

leo run place_bid aleo1yzlta2q5h8t0fqe0v6dyh9mtv4aggd53fgzr068jvplqhvqsnvzq7pj2ke 10u64


Output:

 â€¢ {
  owner: aleo1yzlta2q5h8t0fqe0v6dyh9mtv4aggd53fgzr068jvplqhvqsnvzq7pj2ke.private,
  bidder: aleo1yzlta2q5h8t0fqe0v6dyh9mtv4aggd53fgzr068jvplqhvqsnvzq7pj2ke.private,
  amount: 10u64.private,
  is_winner: false.private,
  _nonce: 4668394794828730542675887906815309351994017139223602571716627453741502624516group.public
}


Step 2: The Second Bid
Have the second bidder place a bid of 90.

Swap in the private key of the second bidder to .env.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkpAFshdsj2EqQzXh5zHceDapFWVCwR6wMCJFfkLYRKupug
ENDPOINT=https://localhost:3030
" > .env


Call the place_bid program function with bidder 2 and 90u64 arguments.

leo run place_bid aleo1esqchvevwn7n5p84e735w4dtwt2hdtu4dpguwgwy94tsxm2p7qpqmlrta4 90u64


Output:

 â€¢ {
  owner: aleo1esqchvevwn7n5p84e735w4dtwt2hdtu4dpguwgwy94tsxm2p7qpqmlrta4.private,
  bidder: aleo1esqchvevwn7n5p84e735w4dtwt2hdtu4dpguwgwy94tsxm2p7qpqmlrta4.private,
  amount: 90u64.private,
  is_winner: false.private,
  _nonce: 5952811863753971450641238938606857357746712138665944763541786901326522216736group.public
}


Step 3: Select the Winner
Have the auctioneer select the winning bid.

Swap in the private key of the auctioneer to .env.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkp5wvamYgK3WCAdpBQxZqQX8XnuN2u11Y6QprZTriVwZVc
ENDPOINT=https://localhost:3030
" > .env


Provide the two Bid records as input to the resolve transition function.

leo run resolve "{
    owner: aleo1fxs9s0w97lmkwlcmgn0z3nuxufdee5yck9wqrs0umevp7qs0sg9q5xxxzh.private,
    bidder: aleo1yzlta2q5h8t0fqe0v6dyh9mtv4aggd53fgzr068jvplqhvqsnvzq7pj2ke.private,
    amount: 10u64.private,
    is_winner: false.private,
    _nonce: 4668394794828730542675887906815309351994017139223602571716627453741502624516group.public
}" "{
    owner: aleo1fxs9s0w97lmkwlcmgn0z3nuxufdee5yck9wqrs0umevp7qs0sg9q5xxxzh.private,
    bidder: aleo1esqchvevwn7n5p84e735w4dtwt2hdtu4dpguwgwy94tsxm2p7qpqmlrta4.private,
    amount: 90u64.private,
    is_winner: false.private,
    _nonce: 5952811863753971450641238938606857357746712138665944763541786901326522216736group.public
}"


Step 4: Finish the Auction
Call the finish transition function with the winning Bid record.

leo run finish "{
    owner: aleo1fxs9s0w97lmkwlcmgn0z3nuxufdee5yck9wqrs0umevp7qs0sg9q5xxxzh.private,
    bidder: aleo1esqchvevwn7n5p84e735w4dtwt2hdtu4dpguwgwy94tsxm2p7qpqmlrta4.private,
    amount: 90u64.private,
    is_winner: false.private,
    _nonce: 5952811863753971450641238938606857357746712138665944763541786901326522216736group.public
}"


Congratulations! You've run a private auction. We recommend going to provable.tools to generate new accounts and trying the same commands with those addresses.



A Basic Bank using Leo
Source Code

Summary
This program implements a bank that issues tokens to users and allows users to deposit tokens to accrue simple interest on their deposits.

User Flow
The bank issues users tokens via the issue function.
A user deposits tokens via the deposit function.
Upon a user's request to withdraw, the bank calculates the appropriate amount of compound interest and pays the user the principal and interest via the withdraw function.
Note that the program can be easily extended to include additional features such as a transfer function, which would allow users to transfer tokens to other users.

Bugs
You may have already guessed that this program has a few bugs. We list some of them below:

withdraw can only be invoked by the bank. A malicious bank could lock users' tokens by not invoking withdraw.
withdraw fails if the sum of the interest and principal is greater than the user's balance.
Users can increase their principal by depositing tokens multiple times, including immediately before withdrawal.
Integer division rounds down; if the calculated interest is too small, then it will be rounded down to zero.
Can you find any others?

There are, of course, ways to write a version of this application without these bugs. This could be a good exercise for the reader.

Language Features and Concepts
record declarations
assert_eq
core functions, e.g. BHP256::hash
record ownership
loops and bounded iteration
mappings
async/await
How to Run
Follow the Leo Installation Instructions.

This basic bank program can be run using the following bash script. Locally, it will execute Leo program functions to issue, deposit, and withdraw tokens between a bank and a user.

cd leo/examples/basic_bank
./run.sh

The .env file contains a private key and address. This is the account that will be used to sign transactions and is checked for record ownership. When executing programs as different parties, be sure to set the private_key field in .env to the appropriate value. You can check out how we've set things up in ./run.sh for a full example of how to run the program as different parties.

Walkthrough
Step 0: Issue Tokens
Step 1: Deposit Tokens
Step 2: Wait
Step 3: Withdraw Tokens
Issue Tokens
We will be playing the role of two parties.

The private key and address of the bank.
private_key: APrivateKey1zkpHtqVWT6fSHgUMNxsuVf7eaR6id2cj7TieKY1Z8CP5rCD
address: aleo1t0uer3jgtsgmx5tq6x6f9ecu8tr57rzzfnc2dgmcqldceal0ls9qf6st7a

The private key and address of the user.
private_key: APrivateKey1zkp75cpr5NNQpVWc5mfsD9Uf2wg6XvHknf82iwB636q3rtc
address: aleo1zeklp6dd8e764spe74xez6f8w27dlua3w7hl4z2uln03re52egpsv46ngg


Let's make some bank transactions. We'll take the role of the bank and issue 100 tokens to the user. We swap the private key into .env and run the issue transition function. The inputs are simply the recipient of the issuance and the amount.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkpHtqVWT6fSHgUMNxsuVf7eaR6id2cj7TieKY1Z8CP5rCD
" > .env

leo run issue aleo1zeklp6dd8e764spe74xez6f8w27dlua3w7hl4z2uln03re52egpsv46ngg 100u64


Output

 â€¢ {
  owner: aleo1zeklp6dd8e764spe74xez6f8w27dlua3w7hl4z2uln03re52egpsv46ngg.private,
  amount: 100u64.private,
  _nonce: 5747158428808897699391969939084459370750993398871840192272007071865455893612group.public
}


Deposit Tokens
Now, let's have the user deposit 50 of their tokens with the bank. We'll take the role of the user and call the deposit function, having the user use the output record that was issued to them by the bank. The inputs are the output record from the issue transition and the amount the user wishes to deposit.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkp75cpr5NNQpVWc5mfsD9Uf2wg6XvHknf82iwB636q3rtc
" > .env

leo run deposit "{
    owner: aleo1zeklp6dd8e764spe74xez6f8w27dlua3w7hl4z2uln03re52egpsv46ngg.private,
    amount: 100u64.private,
    _nonce: 4668394794828730542675887906815309351994017139223602571716627453741502624516group.public
}"  50u64


Output

 â€¢ {
  owner: aleo1zeklp6dd8e764spe74xez6f8w27dlua3w7hl4z2uln03re52egpsv46ngg.private,
  amount: 50u64.private,
  _nonce: 832449386206374072274231152033740843999312028336559467119808470542606777523group.public
}
 â€¢ {
  program_id: basic_bank.aleo,
  function_name: deposit,
  arguments: [
    1197470102489602745811042362685620817855019264965533852603090875444599354527field,
    50u64
  ]
}


You'll see that the output contains a new private record belonging to the user with 50 credits, and a Future indicating code to be run on-chain and its associated inputs.

Wait
With the 50 token deposit, let's say 15 periods of time pass with compounding interest at a rate of 12.34% on the principal amount.

You can run the calculation yourself, it comes out to 266 tokens accrued using those numbers.

Withdraw Tokens
Now, let's have the bank withdraw all tokens after 15 periods. Let's switch to the bank role, and call the withdraw transition function. The inputs are the recipient's address, amount, rate, and periods.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkpHtqVWT6fSHgUMNxsuVf7eaR6id2cj7TieKY1Z8CP5rCD
" > .env

leo run withdraw aleo1zeklp6dd8e764spe74xez6f8w27dlua3w7hl4z2uln03re52egpsv46ngg 50u64 1234u64 15u64


Output

 â€¢ {
  owner: aleo1zeklp6dd8e764spe74xez6f8w27dlua3w7hl4z2uln03re52egpsv46ngg.private,
  amount: 266u64.private,
  _nonce: 7051804730047578560256662070932795007350207323461845976313826737097831996144group.public
}
 â€¢ {
  program_id: basic_bank.aleo,
  function_name: withdraw,
  arguments: [
    1197470102489602745811042362685620817855019264965533852603090875444599354527field,
    50u64
  ]
}


You'll see here the withdrawal function creates a new private record for the user containing all 266 withdrawn tokens, and then outputs a Future which will be run on-chain.

A Voting Program using Leo
Source Code

Summary
vote.leo is a general vote program.

Anyone can issue new proposals, proposers can issue tickets to the voters, and voters can vote without exposing their identity.

This example is inspired by the aleo-vote example written by the Aleo community.

Noteworthy Features
Voter identity is concealed by privately passing a voter's ballot into a function. Proposal information and voting results are revealed using the public mapping datatype in Leo.

How to Run
Follow the Leo Installation Instructions.

This vote program can be run using the following bash script. Locally, it will execute Leo program functions to create proposals, create tickets, and make votes.

cd leo/examples/vote
./run.sh

The .env file contains a private key and network type. This is the account that will be used to sign transactions and is checked for record ownership. When executing programs as different parties, be sure to set the private_key field in .env to the appropriate value. You can check out how we've set things up in ./run.sh for a full example of how to run the program as different parties.

Walkthrough
Functions
Step 0: Create a Proposal
Step 1: Voter 1 issues a ticket and makes a vote
Step 2: Voter 2 issues a ticket and makes a vote
Step 3: How votes are tallied
Functions
Propose
Anyone can issue a new proposal publicly by calling the propose function.

Create Ticket
Proposers can create new tickets for proposals.

A ticket is a record with an owner and a proposal id pid. A ticket can be used to vote for a proposal identified by pid; it can only be used by the ticket owner. That is, only the owner can use that ticket to cast a vote.

Vote
A ticket owner can use their ticket record to vote agree / disagree with the specific proposal - pid. Since the ticket record can be used as an input privately, the voter's privacy is protected.

Create a Proposal
We will be playing the role of three parties.

The private key and address of the proposer.
private_key: APrivateKey1zkp8wKHF9zFX1j4YJrK3JhxtyKDmPbRu9LrnEW8Ki56UQ3G
address: aleo1rfez44epy0m7nv4pskvjy6vex64tnt0xy90fyhrg49cwe0t9ws8sh6nhhr

The private key and address of voter 1.
private_key: APrivateKey1zkpHmSu9zuhyuCJqVfQE8p82HXpCTLVa8Z2HUNaiy9mrug2
address: aleo1c45etea8czkyscyqawxs7auqjz08daaagp2zq4qjydkhxt997q9s77rsp2

The private key and address of voter 2.
private_key: APrivateKey1zkp6NHwbT7PkpnEFeBidz5ZkZ14W8WXZmJ6kjKbEHYdMmf2
address: aleo1uc6jphye8y9gfqtezrz240ak963sdgugd7s96qpuw6k7jz9axs8q2qnhxc


Let's propose a new ballot. Take on the role of the proposer and run the propose transition function. We've provided the necessary information as inputs to the propose function.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkp8wKHF9zFX1j4YJrK3JhxtyKDmPbRu9LrnEW8Ki56UQ3G
" > .env

leo run propose "{ 
  title: 2077160157502449938194577302446444field, 
  content: 1452374294790018907888397545906607852827800436field, 
  proposer: aleo1rfez44epy0m7nv4pskvjy6vex64tnt0xy90fyhrg49cwe0t9ws8sh6nhhr
}"


Output


 â€¢ {
  owner: aleo1rfez44epy0m7nv4pskvjy6vex64tnt0xy90fyhrg49cwe0t9ws8sh6nhhr.private,
  id: 2805252584833208809872967597325381727971256629741137995614832105537063464740field.private,
  info: {
    title: 2077160157502449938194577302446444field.private,
    content: 1452374294790018907888397545906607852827800436field.private,
    proposer: aleo1rfez44epy0m7nv4pskvjy6vex64tnt0xy90fyhrg49cwe0t9ws8sh6nhhr.private
  },
  _nonce: 7270749279509948287724447377218313625054368902761257869085068499107406906985group.public
}
 â€¢ {
  program_id: vote.aleo,
  function_name: propose,
  arguments: [
    2805252584833208809872967597325381727971256629741137995614832105537063464740field
  ]
}


You'll see that the output generates a new record with the proposal information and sets a public mapping with the proposal id as an argument input. The public mapping will be queryable on-chain.

Voter 1 makes a vote
Let's create a new private ticket to make a vote. Take on the role of voter 1 and run the new_ticket transition. The inputs take a unique ticket ID and the voter's public address.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkpHmSu9zuhyuCJqVfQE8p82HXpCTLVa8Z2HUNaiy9mrug2
" > .env

leo run new_ticket 2264670486490520844857553240576860973319410481267184439818180411609250173817field aleo1c45etea8czkyscyqawxs7auqjz08daaagp2zq4qjydkhxt997q9s77rsp2


Output

 â€¢ {
  owner: aleo1c45etea8czkyscyqawxs7auqjz08daaagp2zq4qjydkhxt997q9s77rsp2.private,
  pid: 2264670486490520844857553240576860973319410481267184439818180411609250173817field.private,
  _nonce: 3111099913449740827888947259874663727415985369111767658428258317443300847451group.public
}
 â€¢ {
  program_id: vote.aleo,
  function_name: new_ticket,
  arguments: [
    2264670486490520844857553240576860973319410481267184439818180411609250173817field
  ]
}


You'll see a new private ticket created belonging to the owner, and a public mapping in the vote program to track the ID of that ticket.

Voter 1 can now vote privately on their ticket. Call the agree or disagree transition function, which takes the voter's ticket output as the input.

leo run agree "{
  owner: aleo1c45etea8czkyscyqawxs7auqjz08daaagp2zq4qjydkhxt997q9s77rsp2.private,
  pid: 2264670486490520844857553240576860973319410481267184439818180411609250173817field.private,
  _nonce: 1738483341280375163846743812193292672860569105378494043894154684192972730518group.public
}"


Output

 â€¢ {
  program_id: vote.aleo,
  function_name: agree,
  arguments: [
    2264670486490520844857553240576860973319410481267184439818180411609250173817field
  ]
}



Voter 2 makes a vote
Let's create a new private ticket for voter 2. Take on the role of voter 1 and run the new_ticket transition. The inputs take a unique ticket ID and the voter's public address.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkp6NHwbT7PkpnEFeBidz5ZkZ14W8WXZmJ6kjKbEHYdMmf2
" > .env

leo run new_ticket 2158670485494560943857353240576760973319410481267184429818180411607250143681field aleo1uc6jphye8y9gfqtezrz240ak963sdgugd7s96qpuw6k7jz9axs8q2qnhxc


Output

 â€¢ {
  owner: aleo1uc6jphye8y9gfqtezrz240ak963sdgugd7s96qpuw6k7jz9axs8q2qnhxc.private,
  pid: 2158670485494560943857353240576760973319410481267184429818180411607250143681field.private,
  _nonce: 7213678168429828883374086447188635180072431460350128753904256765278199909612group.public
}
 â€¢ {
  program_id: vote.aleo,
  function_name: new_ticket,
  arguments: [
    2158670485494560943857353240576760973319410481267184429818180411607250143681field
  ]
}


Voter 2 can now vote privately on their ticket. Call the agree or disagree transition function, which takes the voter's ticket output as the input.

leo run disagree "{
  owner: aleo1uc6jphye8y9gfqtezrz240ak963sdgugd7s96qpuw6k7jz9axs8q2qnhxc.private,
  pid: 2158670485494560943857353240576760973319410481267184429818180411607250143681field.private,
  _nonce: 6511154004161574129036815174288926693337549214513234790975047364416273541105group.public
}"


Output

 â€¢ {
  program_id: vote.aleo,
  function_name: disagree,
  arguments: [
    2158670485494560943857353240576760973319410481267184429818180411607250143681field
  ]
}


How votes are tallied
Votes on the ticket are private. But the sum total of the agreements and disagreements are shown on-chain in the public mapping. You can query this data on-chain.

A Custom Token in Leo
Source Code

Summary
A transparent & shielded custom token in Leo.

How to Run
Follow the Leo Installation Instructions.

This token program can be run using the following bash script. Locally, it will execute Leo program functions to mint and transfer tokens publicly and privately.

cd leo/examples/token
./run.sh

The .env file contains a private key and network type. This is the account that will be used to sign transactions and is checked for record ownership. When executing programs as different parties, be sure to set the private_key field in .env to the appropriate value. You can check out how we've set things up in ./run.sh for a full example of how to run the program as different parties.

Walkthrough
Step 0: Public Mint
Step 1: Private Mint
Step 2: Public Transfer
Step 3: Private Transfer
Step 4: Public to Private Transfer
Step 5: Private to Public Transfer
We'll be conducting a transfer between two parties.

The private key and address of Alice.
private_key: APrivateKey1zkp1w8PTxrRgGfAtfKUSq43iQyVbdQHfhGbiNPEg2LVSEXR
address: aleo13ssze66adjjkt795z9u5wpq8h6kn0y2657726h4h3e3wfnez4vqsm3008q

The private key and address of Bob.
private_key: APrivateKey1zkpFo72g7N9iFt3JzzeG8CqsS5doAiXyFvNCgk2oHvjRCzF
address: aleo17vy26rpdhqx4598y5gp7nvaa9rk7tnvl6ufhvvf4calsrrqdaqyshdsf5z


Public Mint
Let's play Alice. Swap in her private key and publicly mint 100 tokens.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkp1w8PTxrRgGfAtfKUSq43iQyVbdQHfhGbiNPEg2LVSEXR
" > .env

leo run mint_public aleo13ssze66adjjkt795z9u5wpq8h6kn0y2657726h4h3e3wfnez4vqsm3008q 100u64


Output

 â€¢ {
  program_id: token.aleo,
  function_name: mint_public,
  arguments: [
    aleo13ssze66adjjkt795z9u5wpq8h6kn0y2657726h4h3e3wfnez4vqsm3008q,
    100u64
  ]
}


You can see the output of mint_public, which takes the arguments Alice's address and the amount of tokens to mint publicly. This information is shown on-chain and can be queried on a network.

Private Mint
Now let's privately mint 100 tokens for Bob. Switch to Bob's private key and privately mint 100 tokens for Bob.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkpFo72g7N9iFt3JzzeG8CqsS5doAiXyFvNCgk2oHvjRCzF
" > .env

leo run mint_private aleo17vy26rpdhqx4598y5gp7nvaa9rk7tnvl6ufhvvf4calsrrqdaqyshdsf5z 100u64


Output

 â€¢ {
  owner: aleo17vy26rpdhqx4598y5gp7nvaa9rk7tnvl6ufhvvf4calsrrqdaqyshdsf5z.private,
  amount: 100u64.private,
  _nonce: 4719474923967087502681846187174640869781874305919806595754990568074403149805group.public
}


The output is a private record.

Public Transfer
Let's publicly transfer 10 tokens from Alice to Bob. Swap the private key back to Alice and call the public transfer transition.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkp1w8PTxrRgGfAtfKUSq43iQyVbdQHfhGbiNPEg2LVSEXR
" > .env

leo run transfer_public aleo17vy26rpdhqx4598y5gp7nvaa9rk7tnvl6ufhvvf4calsrrqdaqyshdsf5z 10u64


Output

 â€¢ {
  program_id: token.aleo,
  function_name: transfer_public,
  arguments: [
    aleo13ssze66adjjkt795z9u5wpq8h6kn0y2657726h4h3e3wfnez4vqsm3008q,
    aleo17vy26rpdhqx4598y5gp7nvaa9rk7tnvl6ufhvvf4calsrrqdaqyshdsf5z,
    10u64
  ]
}


Again, we see the arguments used for the finalize function of transfer_public - Alice's address, Bob's address, and the amount to transfer. The public mapping will be queryable on-chain.

Private Transfer
Let's privately transfer 20 tokens from Bob to Alice. Switch to Bob's private key and call the private transfer transition.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkpFo72g7N9iFt3JzzeG8CqsS5doAiXyFvNCgk2oHvjRCzF
" > .env

leo run transfer_private "{
    owner: aleo17vy26rpdhqx4598y5gp7nvaa9rk7tnvl6ufhvvf4calsrrqdaqyshdsf5z.private,
    amount: 100u64.private,
    _nonce: 6586771265379155927089644749305420610382723873232320906747954786091923851913group.public
}" aleo13ssze66adjjkt795z9u5wpq8h6kn0y2657726h4h3e3wfnez4vqsm3008q 20u64


Output

 â€¢ {
  owner: aleo17vy26rpdhqx4598y5gp7nvaa9rk7tnvl6ufhvvf4calsrrqdaqyshdsf5z.private,
  amount: 80u64.private,
  _nonce: 7402942372117092417133095075129616994719981532373540395650657400913787695842group.public
}
 â€¢ {
  owner: aleo13ssze66adjjkt795z9u5wpq8h6kn0y2657726h4h3e3wfnez4vqsm3008q.private,
  amount: 20u64.private,
  _nonce: 2444690320093734417295179000152972034731859256625211879727315719617371330248group.public
}


The output of transfer_private is a record owned by Bob less the 20 tokens he privately transferred to Alice, and a record owned by Alice with the 20 tokens Bob transferred to Alice.

Public to Private Transfer
Let's convert 30 of Alice's public tokens into 30 private tokens for Bob. Switch the private key back to Alice.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkp1w8PTxrRgGfAtfKUSq43iQyVbdQHfhGbiNPEg2LVSEXR
" > .env

leo run transfer_public_to_private aleo17vy26rpdhqx4598y5gp7nvaa9rk7tnvl6ufhvvf4calsrrqdaqyshdsf5z 30u64


Output

 â€¢ {
  owner: aleo17vy26rpdhqx4598y5gp7nvaa9rk7tnvl6ufhvvf4calsrrqdaqyshdsf5z.private,
  amount: 30u64.private,
  _nonce: 2372167793514585424629802909684994302673167688345985265672131682042636755887group.public
}
 â€¢ {
  program_id: token.aleo,
  function_name: transfer_public_to_private,
  arguments: [
    aleo13ssze66adjjkt795z9u5wpq8h6kn0y2657726h4h3e3wfnez4vqsm3008q,
    30u64
  ]
}


Calling transfer_public_to_private, outputs a Future, which indicates code to be run on-chain, along with its associated inputs.

Private to Public Transfer
Let's convert 40 of Bob's private tokens into 40 public tokens for Alice. Switch the private key back to Bob.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkpFo72g7N9iFt3JzzeG8CqsS5doAiXyFvNCgk2oHvjRCzF
" > .env

leo run transfer_private_to_public "{
    owner: aleo17vy26rpdhqx4598y5gp7nvaa9rk7tnvl6ufhvvf4calsrrqdaqyshdsf5z.private,
    amount: 80u64.private,
    _nonce: 1852830456042139988098466781381363679605019151318121788109768539956661608520group.public
}" aleo13ssze66adjjkt795z9u5wpq8h6kn0y2657726h4h3e3wfnez4vqsm3008q 40u64


Output

 â€¢ {
  owner: aleo17vy26rpdhqx4598y5gp7nvaa9rk7tnvl6ufhvvf4calsrrqdaqyshdsf5z.private,
  amount: 40u64.private,
  _nonce: 2233440107615267344685761424001099994586652279869516904008515754794838882197group.public
}
 â€¢ {
  program_id: token.aleo,
  function_name: transfer_private_to_public,
  arguments: [
    aleo13ssze66adjjkt795z9u5wpq8h6kn0y2657726h4h3e3wfnez4vqsm3008q,
    40u64
  ]
}


When we call transfer_private_to_public, we take Bob's private record that contains 110 tokens, and outputs a record owned by Bob with 70 tokens, and then outputs a Future which will be run on-chain.

A Game of Tic-Tac-Toe in Leo
Source Code

Summary
We can play a standard game of Tic-Tac-Toe in Leo. I think we all know what a tictactoe board looks like:

â­• â• â­• â• âŒ

âž– âž• âž– âž• âž–

â­• â• â£âŒ â• â­•

âž– âž• âž– âž• âž–

âŒ â• âŒ â• â­•

Representing State
Leo allows users to define composite data types with the struct keyword. The game board is represented by a struct called Board, which contains three Rows. An alternative representation would be to use an array, however, these are not yet supported in Leo.

Language Features
struct declarations
conditional statements
early termination. Leo allows users to return from a function early using the return keyword.
How to Run
Follow the Leo Installation Instructions.

This tictactoe program can be run using the following bash script. Locally, it will execute Leo program functions to create and play a game of Tic Tac Toe.

cd tictactoe
./run.sh

Walkthrough
Step 0: Create a new board.
Step 1: Player 1 makes the first move.
Step 2: Player 2 makes the second move.
Step 3: Player 1 makes the third move.
Step 4: and so on...
Create a new board.
We generate the board, and then the players take turns executing the transition function make_move.

The inputs to the function are the player number, row position, column position, and the previous state of the board.

The output provided is the new state of the board and an evaluation of who won the game. 0u8 as the evaluation output means a draw if the board is complete or that the game is not yet over.

leo run new

Player 1 makes a move.
Have player 1 make the first move.

leo run make_move 1u8 1u8 1u8 "{ r1: { c1: 0u8, c2: 0u8, c3: 0u8 }, r2: { c1: 0u8, c2: 0u8, c3: 0u8 }, r3: { c1: 0u8, c2: 0u8, c3: 0u8 } }"


Player 2 makes a move.
Have player 2 make the second move.

leo run make_move 2u8 2u8 2u8 "{ r1: { c1: 1u8, c2: 0u8, c3: 0u8 }, r2: { c1: 0u8, c2: 0u8, c3: 0u8 }, r3: { c1: 0u8, c2: 0u8, c3: 0u8 } }"


Player 1 makes a move.
Have player 1 make the third move.

leo run make_move 1u8 3u8 1u8 "{ r1: { c1: 1u8, c2: 0u8, c3: 0u8 }, r2: { c1: 0u8, c2: 2u8, c3: 0u8 }, r3: { c1: 0u8, c2: 0u8, c3: 0u8 } }"


and so on...
If you follow the run script till the end, you'll see the players make a draw, with an output of 0u64.

This example does not utilize records, as it is primarily designed to demonstrate Leo language features rather than serve as a fully realistic example of a ZK game. A more complete implementation would involve passing records between players to maintain game state securely.

A Game of Battleship in Leo
Source Code

Contents
Contents
Summary
How to Run
1. Initializing the Players
2. Player 1 Places Ships on the Board
3: Player 1 Passes The Board To Player 2
4: Player 2 Places Ships On The Board
5: Passing The Board Back To Player 1
6: Player 1 Takes The 1st Turn
7: Player 2 Takes The 2nd Turn
8: Player 1 Takes The 3rd Turn
9: Player 2 Takes The 4th Turn
10. Who Wins?
ZK Battleship Privacy
Modeling the board and ships
Examples of valid board configurations:
Examples of invalid board configurations:
Validating a single ship at a time
Bit Counting
Adjacency Check
Splitting a row or column
Ensuring a bitstring is a power of 2
Validating all ships together in a single board
Ensure that players and boards cannot swap mid-game
Ensure that each player can only move once before the next player can move
Enforce constraints on valid moves, and force the player to give their opponent information about their opponent's previous move in order to continue playing
Winning the game
Summary
This Battleship implementation showcases a well-designed application within Leoâ€™s current constraints. However, some aspectsâ€”especially the bit manipulationâ€”might seem complex at first glance. To set expectations, this is a more advanced example due to the way the board is encoded and manipulated. Planned improvements to Leo could make implementations like this much simpler in the future.

Battleship is a game where two players lay their ships into secret configurations on their respective 8x8 grids, and then take turns firing upon each other's board. The game ends when one player has sunk all of the other player's ships.

This application was translated into Leo from the zk-battleship example written by the Aleo community - show them some love!

How to Run
Follow the Leo Installation Instructions.

This battleship program can be run using the following bash script. Locally, it will execute Leo program functions to create the board, place ships, and play a game of battleship.

cd battleship
./run.sh

The .env file contains a private key and address. This is the account that will be used to sign transactions and is checked for record ownership. When executing programs as different parties, be sure to set the private_key field in .env to the appropriate value. You can check out how we've set things up in ./run.sh for a full example of how to run the program as different parties.

1. Initializing the Players
In order to play battleship, there must be two players with two boards. Players will be represented by their Aleo address.

We will be playing the role of these two parties:

The private key and address of player 1.
private_key: APrivateKey1zkpGKaJY47BXb6knSqmT3JZnBUEGBDFAWz2nMVSsjwYpJmm
address: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy

The private key and address of player 2.
private_key: APrivateKey1zkp86FNGdKxjgAdgQZ967bqBanjuHkAaoRe19RK24ZCGsHH
address: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry


2. Player 1 Places Ships on the Board
Now, we need to make a board as Player 1. See the modeling the boards and ships section for information on valid ship bitstrings and placements on the board.

With player 1's private key, they initialize the board with the placement of 4 ships and the opponent's public address.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkpGKaJY47BXb6knSqmT3JZnBUEGBDFAWz2nMVSsjwYpJmm
" > .env

leo run initialize_board 34084860461056u64 551911718912u64 7u64 1157425104234217472u64 aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry


âž¡ï¸  Output

 â€¢ {
  owner: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  hits_and_misses: 0u64.private,
  played_tiles: 0u64.private,
  ships: 1157459741006397447u64.private,
  player_1: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  player_2: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  game_started: false.private,
  _nonce: 605849623036268790365773177565562473735086364071033205649960161942593750353group.public
}

Leo âœ… Finished 'battleship.aleo/initialize_board'


The output is a board_state record owned by Player 1. Notice that the game_started flag is false, as well as the composite ship configuration ships. 1157459741006397447u64 to a binary bitstring becomes 0001000000010000000111111000000010000000100000001000000000000111, or laid out in columns and rows:

0 0 0 1 0 0 0 0
0 0 0 1 0 0 0 0
0 0 0 1 1 1 1 1
1 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0
0 0 0 0 0 1 1 1

3: Player 1 Passes The Board To Player 2
Now, we can offer a battleship game to player 2. Run offer_battleship with the record you just created:

leo run offer_battleship "{
  owner: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  hits_and_misses: 0u64.private,
  played_tiles: 0u64.private,
  ships: 1157459741006397447u64.private,
  player_1: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  player_2: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  game_started: false.private,
  _nonce: 605849623036268790365773177565562473735086364071033205649960161942593750353group.public
}"


âž¡ï¸  Outputs

 â€¢ {
  owner: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  hits_and_misses: 0u64.private,
  played_tiles: 0u64.private,
  ships: 1157459741006397447u64.private,
  player_1: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  player_2: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  game_started: true.private,
  _nonce: 5443521912126792569907060514335205174032013684291524549930033539632156136027group.public
}
 â€¢ {
  owner: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  incoming_fire_coordinate: 0u64.private,
  player_1: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  player_2: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  prev_hit_or_miss: 0u64.private,
  _nonce: 6986401140057557061321899375524513841643724821230599181456639629979203966487group.public
}

Leo âœ… Finished 'battleship.aleo/offer_battleship'


The first output record is the updated board_state.record. Notice the game_started flag is now true. This board cannot be used to offer any other battleship games or accept any battleship game offers. Player 1 would need to initialize a new board and use that instead. The second output record is a dummy move.record - there are no fire coordinates included to play on Player 2's board, and no information about any previous Player 2 moves (Player 2 has not made any moves yet). This move.record is owned by Player 2, who must use that in combination with their own board_state.record to accept the game. Let's do that now.

4: Player 2 Places Ships On The Board
We switch our .env to player 2's private key and similarly run initialize_board to create a new and different board for player two.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkp86FNGdKxjgAdgQZ967bqBanjuHkAaoRe19RK24ZCGsHH
" > .env

leo run initialize_board 31u64 2207646875648u64 224u64 9042383626829824u64 aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy


âž¡ï¸  Output

 â€¢ {
  owner: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  hits_and_misses: 0u64.private,
  played_tiles: 0u64.private,
  ships: 9044591273705727u64.private,
  player_1: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  player_2: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  game_started: false.private,
  _nonce: 677929557867990662961068737825412945684193990901139603462104629310061710321group.public
}

âœ… Executed 'battleship.aleo/initialize_board'


Note, the output ships here is 9044591273705727u64, which in a bitstring is:

0 0 1 0 0 0 0 0
0 0 1 0 0 0 1 0
0 0 0 0 0 0 1 0
0 0 0 0 0 0 1 0
0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0
1 1 1 1 1 1 1 1

5: Passing The Board Back To Player 1
Now, we can accept Player 1's offer. Run start_battleship:

leo run start_battleship "{
  owner: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  hits_and_misses: 0u64.private,
  played_tiles: 0u64.private,
  ships: 9044591273705727u64.private,
  player_1: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  player_2: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  game_started: false.private,
  _nonce: 677929557867990662961068737825412945684193990901139603462104629310061710321group.public
}" "{
  owner: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  incoming_fire_coordinate: 0u64.private,
  player_1: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  player_2: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  prev_hit_or_miss: 0u64.private,
  _nonce: 6306786918362462465996698473371289503655844751914031374264794338640697795225group.public
}"


âž¡ï¸  Outputs

 â€¢ {
  owner: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  hits_and_misses: 0u64.private,
  played_tiles: 0u64.private,
  ships: 9044591273705727u64.private,
  player_1: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  player_2: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  game_started: true.private,
  _nonce: 499506036017893504519951074816367233238764881167148207158107765834843789278group.public
}
 â€¢ {
  owner: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  incoming_fire_coordinate: 0u64.private,
  player_1: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  player_2: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  prev_hit_or_miss: 0u64.private,
  _nonce: 7551593771072417773015833444631669906818701068612998340960968556531564726874group.public
}

âœ… Executed 'battleship.aleo/start_battleship'


Notice the outputs here are similar to offer_battleship. A dummy move.record is owned by Player 1, and Player 2 gets a board_state.record with the game_started flag updated. However, now that Player 1 has a move.record and a started board, they can begin to play.

6: Player 1 Takes The 1st Turn
We switch the .env back to player 1, and we run the transition function play.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkpGKaJY47BXb6knSqmT3JZnBUEGBDFAWz2nMVSsjwYpJmm
" > .env

leo run play "{
  owner: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  hits_and_misses: 0u64.private,
  played_tiles: 0u64.private,
  ships: 1157459741006397447u64.private,
  player_1: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  player_2: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  game_started: true.private,
  _nonce: 6313341191294792052861773157032837489809107102476040695601777954897783350080group.public
}" "{
  owner: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  incoming_fire_coordinate: 0u64.private,
  player_1: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  player_2: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  prev_hit_or_miss: 0u64.private,
  _nonce: 2798663115519921626400765401803177719929914180089719334947022448579691220488group.public
}" 1u64


âž¡ï¸  Outputs

 â€¢ {
  owner: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  hits_and_misses: 0u64.private,
  played_tiles: 1u64.private,
  ships: 1157459741006397447u64.private,
  player_1: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  player_2: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  game_started: true.private,
  _nonce: 5833516448655036599597838063894464861371198938108460526636526325286738488235group.public
}
 â€¢ {
  owner: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  incoming_fire_coordinate: 1u64.private,
  player_1: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  player_2: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  prev_hit_or_miss: 0u64.private,
  _nonce: 4383078917685812690935470339923943658033179718952229417171392956492546325808group.public
}

âœ… Executed 'battleship.aleo/play'


Player 1 has an updated board_state.record - they have a new played_tiles bitstring, which corresponds to the fire coordinate they just sent to Player 2. You can see that the incoming_fire_coordinate in the move.record owned by Player 2 matches exactly the input given by Player 1. Player 2 can now play this move tile and respond with a fire coordinate of their own, and they will also let Player 1 know whether their fire coordinate hit or miss Player 2's ships.

7: Player 2 Takes The 2nd Turn
We switch the .env back to player 2, and we run the transition function play.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkp86FNGdKxjgAdgQZ967bqBanjuHkAaoRe19RK24ZCGsHH
" > .env

leo run play "{
  owner: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  hits_and_misses: 0u64.private,
  played_tiles: 0u64.private,
  ships: 9044591273705727u64.private,
  player_1: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  player_2: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  game_started: true.private,
  _nonce: 6864275139988909612799168784231775829713739147830284979332684562641318182923group.public
}" "{
  owner: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  incoming_fire_coordinate: 1u64.private,
  player_1: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  player_2: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  prev_hit_or_miss: 0u64.private,
  _nonce: 8420474443174402614458578667801578345975509805478103542095622903412594983971group.public
}" 2048u64


âž¡ï¸  Outputs

 â€¢ {
  owner: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  hits_and_misses: 0u64.private,
  played_tiles: 2048u64.private,
  ships: 9044591273705727u64.private,
  player_1: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  player_2: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  game_started: true.private,
  _nonce: 6284479302801058138006361960649628992876976428745392660731784830148359328839group.public
}
 â€¢ {
  owner: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  incoming_fire_coordinate: 2048u64.private,
  player_1: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  player_2: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  prev_hit_or_miss: 1u64.private,
  _nonce: 8217837260140600949756911248177622179381338760298068527463640818659709985441group.public
}

âœ… Executed 'battleship.aleo/play'


Player 2 now has an updated board_state.record which includes their newly updated played_tiles, only containing the fire coordinate they just sent to Player 1. Player 1 now owns a new move.record which includes the hits_and_misses field. This contains only the result of Player 1's previous fire coordinate they had sent to Player 2. It will always be a single coordinate on the 8x8 grid if it's a hit. A miss is 0u64 (8x8 grid of 0s), whereas a hit is the u64 equivalent of their previous fire coordinate in bitstring form.

If you check Player 2's ships configuration, you'll note their entire bottom row is covered by two ships, so sample valid hits on the bottom row would be: 1u64, 2u64, 4u64, 8u64, 16u64, 32u64, 64u64, and 128u64. Since Player 1's first fire coordinate (1u64) was a hit, the hits_and_misses field is also 1u64.

Player 1's next move will consume this move.record, which will update Player 1's board with the hit-or-miss, as well as figure out the result of Player 2's fire coordinate. Now that Player 1 has some played_tiles, they can no longer choose an alread-played fire coordinate. For example, running aleo run play 'board_state.record' 'move.record' 1u64 will fail, because 1u64 has already been played.

8: Player 1 Takes The 3rd Turn
We switch the .env back to player 1, and we run the transition function play.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkpGKaJY47BXb6knSqmT3JZnBUEGBDFAWz2nMVSsjwYpJmm
" > .env

leo run play "{
  owner: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  hits_and_misses: 0u64.private,
  played_tiles: 1u64.private,
  ships: 1157459741006397447u64.private,
  player_1: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  player_2: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  game_started: true.private,
  _nonce: 1962122153746742645258971561783872712461616481157617568489391338473028502271group.public
}" "{
  owner: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  incoming_fire_coordinate: 2048u64.private,
  player_1: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  player_2: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  prev_hit_or_miss: 1u64.private,
  _nonce: 1204008848449868423802652577996848559012797694551224583683080100053831915439group.public
}" 2u64


âž¡ï¸  Outputs

 â€¢ {
  owner: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  hits_and_misses: 1u64.private,
  played_tiles: 3u64.private,
  ships: 1157459741006397447u64.private,
  player_1: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  player_2: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  game_started: true.private,
  _nonce: 5338125050531864311985370830280952305688629865354830939402745656578990650505group.public
}
 â€¢ {
  owner: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  incoming_fire_coordinate: 2u64.private,
  player_1: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  player_2: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  prev_hit_or_miss: 0u64.private,
  _nonce: 7971995563631235472540847437984726419106193784727086463494463811056252801811group.public
}

âœ… Executed 'battleship.aleo/play'


As before, both a board_state.record and move.record are created. The board_state.record now contains 3u64 as the played_tiles, which looks like this in bitstring form:

0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 1

The board_state.record hits_and_misses field has also been updated with the result of their previous move. The new move.record owned by Player 2 now contains information about whether Player 2's previous move was a hit or miss, as well as Player 1's new fire coordinate.

9: Player 2 Takes The 4th Turn
We switch the .env back to player 2, and we run the transition function play.

echo "
NETWORK=testnet
PRIVATE_KEY=APrivateKey1zkp86FNGdKxjgAdgQZ967bqBanjuHkAaoRe19RK24ZCGsHH
" > .env

leo run play "{
  owner: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  hits_and_misses: 0u64.private,
  played_tiles: 2048u64.private,
  ships: 9044591273705727u64.private,
  player_1: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  player_2: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  game_started: true.private,
  _nonce: 591128247205636061702123861968396246163831838278146623498909560875485861872group.public
}" "{
  owner: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  incoming_fire_coordinate: 2u64.private,
  player_1: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  player_2: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  prev_hit_or_miss: 0u64.private,
  _nonce: 4871574741887919250014604645502780786361650856453535231083359604148337116539group.public
}" 4u64


âž¡ï¸  Outputs

 â€¢ {
  owner: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  hits_and_misses: 0u64.private,
  played_tiles: 2052u64.private,
  ships: 9044591273705727u64.private,
  player_1: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  player_2: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  game_started: true.private,
  _nonce: 4866144015676673398767235148516158177034901439767024502676546368462039477864group.public
}
 â€¢ {
  owner: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  incoming_fire_coordinate: 4u64.private,
  player_1: aleo1wyvu96dvv0auq9e4qme54kjuhzglyfcf576h0g3nrrmrmr0505pqd6wnry.private,
  player_2: aleo15g9c69urtdhvfml0vjl8px07txmxsy454urhgzk57szmcuttpqgq5cvcdy.private,
  prev_hit_or_miss: 2u64.private,
  _nonce: 5304512645876453228434639693756897952439730718508628026257897445388710294282group.public
}

âœ… Executed 'battleship.aleo/play'


10. Who Wins?
Play continues back and forth between Player 1 and Player 2. When one player has a total of 14 flipped bits in their hits_and_misses field on their board_state.record, they have won the game.

ZK Battleship Privacy
How can we ensure that the ship configurations of each player remains secret, while being able to trustlessly and fairly play with their opponent? By taking advantage of selective privacy powered by zero knowledge proofs on Aleo.

Broadly speaking, we can follow this general strategy:

Create mathematical rules for placing the ships on the board, to ensure that neither player can cheat by stacking all their ships in one place, moving them off the board, or laying them across each other.

Ensure that the players and boards that begin a game cannot be swapped out.

Ensure that each player can only move once before the next player can move.

Enforce constraints on valid moves, and force the player to give their opponent information about their opponent's previous move in order to continue playing.

Modeling the board and ships
Most battleship representations in programs use a 64 character string or an array of arrays (8 arrays of 8 elements each) to model the board state. Unfortunately, Leo language don't represent strings well yet, nor can we use for or while loops. Luckily for us, Aleo has the unsigned 64 bit integer type, or u64. To represent every space on a battleship board, from top left to bottom right, we can use each bit in a u64. For example, an empty board would be: 0u64 =

0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0

Battleship is played with 4 different ship types - a ship of length 5, length 4, length 3, and length 2. Some versions of battleship have an extra length 3 ship or another extra ship type, however, we will stick to the most basic version for this project. In order to be a valid ship placement, a ship must be placed vertically or horizontally (no diagonals). On a physical board, a ship cannot break across rows or intersect with another ship, but ships are allowed to touch one another.

Similar to how we represent a board with a u64 bitstring, we can represent a ship horizontally as a bitstring. We "flip" the bits to represent a ship: | Length | Bitstring | u64 | | ------ | --------- | --- | | 5 | 11111 | 31u64| | 4 | 1111 | 15u64| | 3 | 111 | 7u64 | | 2 | 11 | 3u64 |

We can also represent a ship vertically as a bitstring. To show this, we need 7 "unflipped" bits (zeroes) in between the flipped bits so that the bits are adjacent vertically. | Length | Bitstring | u64 | | --- | --- | --- | | 5 | 1 00000001 00000001 00000001 00000001 | 4311810305u64 | | 4 | 1 00000001 00000001 00000001 | 16843009u64 | | 3 | 1 00000001 00000001 | 65793u64 | | 2 | 1 00000001 | 257u64 |

With a board model and ship bitstring models, we can now place ships on a board.

Examples of valid board configurations:
17870284429256033024u64

1 1 1 1 1 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 1  
0 0 0 0 0 0 0 1  
1 1 1 1 0 0 0 1  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 1 1  
0 0 0 0 0 0 0 0  

16383u64

0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 1 1 1 1 1 1  
1 1 1 1 1 1 1 1  

2157505700798988545u64

0 0 0 1 1 1 0 1  
1 1 1 1 0 0 0 1  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 1  
0 0 0 0 0 0 0 1  
0 0 0 0 0 0 0 1  
0 0 0 0 0 0 0 1  
0 0 0 0 0 0 0 1  

Examples of invalid board configurations:
Ships overlapping the bottom ship:
67503903u64

0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 1 0 0  
0 0 0 0 0 1 1 0  
0 0 0 0 0 1 1 1  
0 0 0 1 1 1 1 1  

Diagonal ships:
9242549787790754436u64

1 0 0 0 0 0 0 0  
0 1 0 0 0 1 0 0  
0 0 1 0 0 0 1 0  
0 0 0 1 0 0 0 0  
0 0 0 1 1 0 0 0  
0 0 1 0 0 0 0 1  
0 1 0 0 0 0 1 0  
1 0 0 0 0 1 0 0  

Ships splitting across rows and columns:
1297811850814034450u64

0 0 0 1 0 0 1 0  
0 0 0 0 0 0 1 0  
1 1 0 0 0 0 0 1  
0 0 0 0 0 0 0 0  
1 0 0 1 0 0 0 1  
0 0 0 1 0 0 0 0  
0 0 0 1 0 0 1 0  
0 0 0 1 0 0 1 0  

Given these rules, our strategy will be to validate each individual ship bitstring placement on a board, and then, if all the ships are valid, compose all the positions onto a board and validate that the board with all ships are valid. If each individual ship's position is valid, then all the ships together should be valid unless any overlapping occurs.

Validating a single ship at a time
To follow along with the code, all verification of ship bitstrings is done in verify.aleo. We know a ship is valid if all these conditions are met: If horizontal:

The correct number of bits is flipped (a ship of length 5 should not have 6 flipped bits)
All the bits are adjacent to each other.
The bits do not split a row.
If vertical:

The correct number of bits is flipped.
All the bits are adjacent to each other, vertically. This means that each flipped bit should be separated by exactly 7 unflipped bits.
The bits do not split a column.
If a ship is valid vertically or horizontally, then we know the ship is valid. We just need to check for the bit count, the adjacency of those bits, and make sure those bits do not split a row/column. However, we can't loop through the bit string to count bits, or to make sure those bits don't break across columns. We'll need to turn to special bitwise operations and hacks.

Bit Counting
See the "c_bitcount" closure to follow along with the code. 50 years ago, MIT AI Laboratory published HAKMEM, which was a series of tricks and hacks to speed up processing for bitwise operations. https://w3.pppl.gov/~hammett/work/2009/AIM-239-ocr.pdf We turned to HAKMEM 169 for bitcounting inspiration, although we've tweaked our implementation to be (hopefully) easier to understand. Before diving into details, let's build some intuition.

Let a,b,c,d be either 0 or 1. Given a polynomial 8a + 4b + 2c + d, how do we find the summation of a + b + c + d? If we subtract subsets of this polynomial, we'll be left with the summation.

Step 1: 8a + 4b + 2c + d
Step 2: -4a - 2b - c
Step 3: -2a - b
Step 4: - a
Step 5: = a + b + c + d

This polynomial is basically a bitwise representation of a number, so given a 4 bit number, e.g. 1011 or 13u64, we can follow these instructions to get the bit count. Step 2 is just subtracting the starting number but bit shifted to the right (equivalent to dividing by 2). Step 3 bit shifts the starting number to the right twice and is subtracted, and Step 4 bit shifts thrice and is subtracted. Put another way: Start with a 4-digit binary number A. A - (A >> 1) - (A >> 2) - (A >> 3) = B.

Step 1: 1101 = 13u64
Step 2: -0110 = 6u64
Step 3: -0011 = 3u64
Step 4: -0001 = 1u64
Step 5: =0011 = 3u64

To make this process work for any bit-length number, where the sum of the bits is left in groups of 4 bits, we'll need to use some bit-masking, so that the sum of one group of 4 does not interfere with the next group of 4. With a larger starting number, like 1111 0001 0111 0110, we will need the following bit maskings:

For A >> 1, we'll use 0111 0111 0111 .... (in u64, this is 8608480567731124087u64)
For A >> 2, we'll use 0011 0011 0011 .... (in u64, this is 3689348814741910323u64)
For A >> 3, we'll use 0001 0001 0001 .... (in u64, this is 1229782938247303441u64)


For example, finding the sums of groups of 4 with a 16-bit number we'll call A to yield the bit sum number B:

A:    1111 0001 0111 0110  
A>>1: 0111 1000 1011 1011  
A>>2: 0011 1100 0101 1101  
A>>3: 0001 1110 0010 1110  

A>>1: 0111 1000 1011 1011  
    & 0111 0111 0111 0111:  
      0111 0000 0011 0011  

A>>2: 0011 1100 0101 1101  
    & 0011 0011 0011 0011:  
      0011 0000 0001 0001  

A>>3: 0001 1110 0010 1110  
    & 0001 0001 0001 0001:  
      0001 0000 0000 0000  

A - (A>>1 & 0111....) - (A>>2 & 0011....) - (A>>3 & 0001....):
B:    0100 0001 0011 0010  
      4    1    3    2


The next step is to combine the summation of each of those 4-bit groups into sums of 8-bit groups. To do this, we'll use another bit trick. We will shift this number B to the right by 4 (B >> 4), and add that back to B. Then, we'll apply a bit masking of 0000 1111 0000 1111 .... (in u64, this is 1085102592571150095u64) to yield the sums of bits in groups of 8, a number we'll call C.

B:    0100 0001 0011 0010  
B>>4: 0000 0100 0001 0011  
      0100 0101 0100 0101  
      4    5    4    5

apply the bit mask  
      0000 1111 0000 1111  

C:    0000 0101 0000 0101  
      0    5    0    5

At this point, we've gone from a bit sum in groups of 4 to bit sums in groups of 8. That's great, but ultimately we want the total sum of bits in the original binary number. The final bit trick is to modulo C by 255. This is 2^8 - 1. For a bit of intuition, consider the number 1 0000 0001. If we take 1 0000 0001 mod 256, we're left with 1. If we take 1 0000 0001 mod 255, we're left with 2. Modding by 255 gives us the amount of bits beyond the first 255 numbers, as 255 is the largest number that can be represented with 8 bits.

A full summary of abbreviated steps to get the bit count, starting with a 64 bit integer A (closely following the c_bitcount closure in the verify.aleo code):

let A = 64 unsigned bit integer
let B = A - (A>>1 & 8608480567731124087u64) - (A>>2 & 3689348814741910323u64) - (A>>3 & 1229782938247303441u64)
let C = (B - B>>4) & 1085102592571150095u64
bit count = C mod 255u64


Adjacency Check
Given a ship's placement on the board and its bitstring representation (horizontally or vertically), we can determine if the bits are adjacent. Follow the c_adjacency_check closure in verify.aleo. Given the ship of length 2, we know it's horizontal bitstring is 11 (3u64) and it's vertical bitstring is 100000001 (257u64). If on the board, the ship starts at the bottom right corner, its horizontal ship placement string would be:
3u64

0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 1 1  

Vertical ship placement:
257u64

0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 1  
0 0 0 0 0 0 0 1  

If we move the ship to the left one column:
Horizontal 6u64

0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 1 1 0  

Vertical 514u64

0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 1 0  
0 0 0 0 0 0 1 0  

If we move the ship up one row:
Horizontal 768u64

0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 1 1  
0 0 0 0 0 0 0 0  

Vertical 65792u64

0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 1  
0 0 0 0 0 0 0 1  
0 0 0 0 0 0 0 0  

We can make the observation that the original bitstring is always shifted by a power of 2 to get to a new valid position on the board. Therefore, if we take the ship placement bitstring and divide by the ship bitstring (either horizontal or vertical), as long as the remaining number is a power of 2 (2^0, 2^1, 2^2, 2^3...), we know the ship's bits are adjacent.

To ensure that the remaining number is a power of 2, we can use a bit trick. See the bit trick for ensuring a bitstring is a power of 2 section.

In the code, you'll notice one extra step. Dividing a ship placement bitstring by a ship bitstring representation could result in 0, and then subtracting by 1 will result in an underflow. In that case, we know the ship placement is not valid, so we can set a number which is gauranteed to not be a power of 2.

Splitting a row or column
Follow the c_horizontal_check closure in verify.aleo to follow the code. Assume all the bits are adjacent (see the adjacency check section). The column case is trivial. We can be certain that if a ship bitstring splits columns, the division of that ship placement bitstring by its ship bitstring representation will not yield a power of 2, and it would have failed the adjacency check.

The horizontal case must be checked because a split row bitstring could still contain a ship with adjacent bits. To make this check easier, we will condense the 64 bitstring into an 8 bitstring by taking it modulo 255. If we assume that a bitstring is not splitting a row, then taking the ship placement bitstring modulo 255 will yield an 8 bit valid bitstring. If the original ship placement bitstring is not valid, then we will have an invalid 8 bit bitstring. E.g.:

1 1 1 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  

mod 255 = 11100000 (valid)

0 0 0 0 0 0 0 1  
1 1 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  
0 0 0 0 0 0 0 0  

mod 255 = 11000001 (invalid)

How do we know the 8 bit bitstring is valid or not? We can simply do an adjacency check, as before.

Ensuring a bitstring is a power of 2
Any power of 2 will have a single bit flipped. If we subtract 1 from that number, it will result in a complementary bitstring that, bitwise-anded with the original, will always result in 0.

E.g.

8:   1000
8-1: 0111
8&7: 0000 == 0

7:   0111
7-1: 0110
7&6: 0110 != 0

Validating all ships together in a single board
Give individual valid ship position bitstrings, we can combine all these together into a single board using bitwise or operators. See the create_board function in verify.aleo to follow the code. Once all ships are on the board, we can count the total number of bits, which should be 14 exactly for a ship of length 5, 4, 3, and 2.

Ensure that players and boards cannot swap mid-game
Board states are represented with the board_state record. Each board has a flag indicating whether a game has been started with the board. This flag is set when offering a battleship game to an opponent, or accepting a battleship game from an opponent. Move records are created only in 3 ways:

Offering a battleship game creates a dummy move record that sets the two players to the addresses set in the board state record.
Accepting a battleship game consumes the first dummy move record and checks that the move record contains the same two players as the board of the player accepting the game. Then, a new dummy move record is created and keeps the same two players.
A move record must be consumed in order to play and create the next move record. There's a check to ensure the players in the move record matches the players in the board, and the players in the next move record are automatically set.
The only way moves not matching a board can be combined is if the players begin multiple games with each other. As long as one player is honest and only accepts a single game with a particular opponent, only one set of moves can be played on one board between them.

Ensure that each player can only move once before the next player can move
A move record must be consumed in order to create the next move record. The owner of the move record changes with each play. Player A must spend a move record in order to create a move record containing their fire coordinate, and that move record will be owned by Player B. Player B must spend that move record in order to create the next move record, which will belong to Player A.

Enforce constraints on valid moves, and force the player to give their opponent information about their opponent's previous move in order to continue playing
A valid move for a player is a fire coordinate that has only one flipped bit in a u64. We can make sure only one bit is flipped with the powers of 2 bit trick. That single bit must be a coordinate that has not been played by that player before, which we check in board.aleo/update_played_tiles.

In order to give their next move to their opponent, a player must call the main.aleo/play function, which checks the opponent's fire coordinate on the current player's board. The move record being created is updated with whether that fire coordinate was a hit or a miss for the opponent.

Winning the game
Right now, the way to check when a game has been won is to count the number of hits on your hits_and_misses field on your board_state record. Once you have 14 hits, you've won the game.


Curated Resources
There's a lot more on Leo and Aleo out there! Here are some thing you might find interesting.

The Community
ðŸ’¬ Share what you are building in the #leo-language channel ðŸ’¬

https://discord.gg/aleo

If you're interested in learning more about Aleo:

ðŸ¦ | X (Twitter) ~ @ProvableHQ ~ https://twitter.com/ProvableHQ

ðŸ¦ | X (Twitter) ~ @AleoHQ ~ https://twitter.com/AleoHQ

ðŸ¤ | Community X (Twitter) ~ @aleocommunity ~ https://twitter.com/aleocommunity

More Resources
ðŸ™ | GitHub ~ https://github.com/ProvableHQ

ðŸ“œ | Leo Workshops ~ https://github.com/ProvableHQ/workshop

ðŸŽï¸ | Awesome Aleo ~ https://github.com/AleoNet/awesome-aleo

âœï¸ | Provable Blog ~ https://provable.com/blog

âœï¸ | Aleo Blog ~ https://aleo.org/blog

ðŸ“œ | Leo Whitepaper ~ https://eprint.iacr.org/2021/651.pdf

Talks and Videos
Talks and videos from the Aleo community.

Coinbase BUIDL - Learning LEO | Coding Private Application with ZK Cryptography
DEVCON - Aleo Developer Workshop: Leo Coding & Examples
DEVCON - What are ZK Proofs Good For? Applications to Anonymous Identity, Sybil Prevention and Moderation
DEVCON - Efficient Private Delegation of zkSNARK Provers
ICC - Web 3.0 for developers in TLV Howard Wu Aleo
ZK8 - Demystifying Zero-Knowledge Programming â€“ Howard Wu - Aleo
ETHCC - The Hitchhiker's Guide to ZK: An Aleo Developer Workshop
CoinGecko - Importance of Zero-knowledge Proofs w/ Alex Pruden
Thinking Crypto - Alex Pruden Interview - Aleo's Privacy Solutions - Zero Knowledge Proofs - a16z - Bitcoin & Crypto
The Interop - Zero-Knowledge Smart Contracts with Alex Pruden of Aleo
Axelar - Tech Talks with Aleo

Built on Leo
Coming soon!

Please fill out this form if you're building on Leo. The Leo team will ensure that submitted projects retain backwards compatibility and receive developer support.

https://github.com/ProvableHQ/grammars

Provable API Documentation
Overview
The Provable API provides access to the Aleo blockchain through RESTful endpoints.
Developers can query block-level information, transactions, programs, transitions, and more, as well as broadcast transactions. These endpoints are foundational for building applications and services in the Aleo ecosystem.

Rate Limiting
Rate limiting is enforced across all endpoints:

5 requests per second
100,000 requests per day
Abuse may result in blacklisting. For higher limits, contact explorer@provable.com.

Quick Links
ðŸš€ Get Started with API v2
Base URL: https://api.provable.com/v2/{network}

ðŸ“– Browse by Category
SnarkOS Core Endpoints
Blocks - Block data, state roots, and history
Transactions - Transaction queries and broadcasting
Committee - Validator and delegation info
Programs - Smart contract queries
Solutions - Prover solution broadcasting
Public API
Blocks - Block data, state roots, and history
Transactions - Transaction queries and broadcasting
Programs - Smart contract queries
Metrics - Block, transaction, and program analytics
Supply - Total and circulating supply
DeFi - DeFi metrics and token data
Staking - Delegation and staking data
Proving - Prover statistics and rewards
Address - Address-specific data
Delegated Proving
Submit Delegated Proof - Submit proofs for delegated execution
Record Scanning
Register Scanner - Register a new scanner
Get Owned Records - Retrieve owned records
Get Scanner Status - Check scanner status
Auth
Register for Auth - Register for authentication
Issue JWT - Issue a signed JWT
API v2 Reference
SnarkOS
Core blockchain endpoints that mirror SnarkOS client node functionality.

Blocks
Get latest block
Get latest block height
Get latest block hash
Get block by height or hash
Get block hash by transaction ID
Get transactions by block height
Get blocks in range
Get latest state root
Get state root by height
Get block height by state root
Get state path by commitment
Get state paths by commitments
Get height by hash
Get block history
Committee
Get latest committee
Get committee by height
Get delegators by validator
Programs
Get program by ID
Get transition ID by input/output ID
Get program mappings
Get latest edition of program
Get program by edition
Get program mapping value
Get program deployment transaction
Get program deployment by edition
Solutions
Broadcast solution
Transactions
Transaction by transaction ID
Transaction by transition ID
Confirmed transaction
Unconfirmed transaction
Broadcast transaction
Public API
Enhanced endpoints for explorer and analytics functionality.

Blocks
Latest Block
Latest Block Hash
Latest Block Height
Block by Height
Block by Hash
Find Block Hash by TX ID
Latest State Root
State Root by Height
Find Block Height by State Root
Find State Path by Commitment
State Paths by Commitments
Find Height by Hash
Block History
Transactions
Transactions by Address
Latest Transactions Summary
Transaction by TX ID
Find TX ID by Transition ID
Confirmed Transaction
Unconfirmed Transaction
Transactions by Block Height
Transactions by Block Hash
Transitions by Address
Broadcast Transaction
Programs
Program by ID
Latest Calls by Program ID
Latest Edition of Program
Program by Edition
Program Mapping Value
Program Mappings
Find Transition ID
Program Deployment TX
Program Deployment TX by Edition
Metrics
Latest Blocks Summary
Transaction Metrics Daily
Program Metrics
Puzzle Rewards Monthly
APY Monthly
APY for Current Validators
Program Metrics by Range
Validator Participation
Puzzle Rewards Daily
Total Prover Metrics
APY Last 24 Hours
Supply
Total Supply
Total Supply - Microcredits
Circulating Supply - Microcredits
Circulating Supply - Credits
DeFi
DeFi Total Value
Token Details
Token Price History
Compliance Freeze List
Staking
Latest Delegators
Proving
All Provers
Address
Staking Earnings by Address
Solutions by Address
Puzzle Rewards by Address
Delegated Proving
Submit delegated proof
Record Scanning
Register scanner
Get owned records
Get record tags
Get record serial numbers
Get scanner status
Get encrypted records
Auth
Register for auth
Issue JWT
API v1 Reference
Blocks
Get latest block
Get blocks in range
Get latest block height
Get latest block hash
Get block by height or hash
Get block hash by transaction ID
Get latest state root
Get state root by height
Get block height by state root
Get state path by commitment
Get height by hash
Get block history
Committee
Get latest committee
Get committee by height
Get delegators by validator
Programs
Get program by ID
Get latest edition of program
Get program by edition
Get program mappings
Get program mapping value
Get transition ID by input/output ID
Get program deployment transaction
Get program deployment by edition
Solutions
Broadcast solution
Supply
Get total supply
Get latest total supply
Get circulating supply
Get latest circulating supply
Transactions
Get transaction by id
Get transaction by transition ID
Get confirmed transaction
Get unconfirmed transaction
Get transactions by block identifier
Broadcast transaction

Latest Block
GET
https://api.provable.com/v2/mainnet/block/latest
Returns the latest block.

Responses
200
Latest block data

application/json
Schema
Example (auto)
Schema
block_hash
string
previous_hash
string
header
object
authority
object
ratifications
object[]
solutions
object
aborted_solution_ids
object[]
transactions
object[]
aborted_transaction_ids
object[]

Latest Block Height
GET
https://api.provable.com/v2/mainnet/block/height/latest
Returns the latest block height.

Responses
200
OK

application/json
Schema
Schema
integer
integer

Latest Block Hash
GET
https://api.provable.com/v2/mainnet/block/hash/latest
Returns the hash of the latest block.

Responses
200
Latest block hash

application/json
Schema
Example (auto)
Schema
hash
string

Block by Height or Hash
GET
https://api.provable.com/v2/mainnet/block/:height_or_hash
Returns a block by specified height or hash.

Request
Path Parameters
height_or_hash
string
required
Possible values: non-empty

Block height or block hash

Responses
200
Block by specified height or hash

application/json
Schema
Example (auto)



Find Block Hash by Transaction ID
GET
https://api.provable.com/v2/mainnet/find/blockHash/:txID
Returns the block hash containing the specified transaction.

Request
Path Parameters
txID
string
required
Transaction ID

Responses
200
Block hash for specified transaction id

application/json
Schema
Example (auto)
Schema
string
string

Transactions by Block Height
GET
https://api.provable.com/v2/mainnet/block/:height/transactions
Returns all transactions in the specified block.

Request
Path Parameters
height
string
required
Responses
200
Array of transactions at specified block height.

application/json
Schema
Example (auto)
Schema
Array [
type
string
index
integer
status
string
finalize
object[]
transaction
object
]
curl
http
CURL
curl -L 'https://api.provable.com/v2/mainnet/block/:height/transactions' \
-H 'Accept: application/json'


Request
Collapse all
Base URL
https://api.provable.com/v2/mainnet
Parameters
height â€” pathrequired
height
Send API Request
Response
Clear
Click the Send API Request button above and see the response here!

Previous
Find Block Hash by Transaction ID

Blocks in Range
GET
https://api.provable.com/v2/mainnet/blocks
Returns blocks within the specified range (max 50 blocks).

Request
Query Parameters
start
number
required
end
number
required
Responses
200
Array of specified blocks

application/json
Schema
Example (auto)
Schema

Latest State Root
GET
https://api.provable.com/v2/mainnet/stateRoot/latest
Returns the latest state root.

Responses
200
Latest state root

json
Schema
Example (auto)
default
Schema
string
string

State Root by Height
GET
https://api.provable.com/v2/mainnet/stateRoot/:height
Returns the state root at the specified height.

Request
Path Parameters
height
number
required
Block height
Find Block Height by State Root
GET
https://api.provable.com/v2/mainnet/find/blockHeight/:stateRoot
Returns the block height for the specified state root.

Request
Path Parameters
stateRoot
string
required
Responses
200
Block height of specified state root

application/json
Schema
default
State Path by Commitment
GET
https://api.provable.com/v2/mainnet/statePath/:commitment
Returns the state path for the specified commitment.

Request
Path Parameters
commitment
string
required
Responses
200
State path by commitment

application/json
Schema
Example (auto)
default
State Paths by Commitments
GET
https://api.provable.com/v2/mainnet/statePaths
Returns state paths for multiple commitments separated by comma.

Request
Query Parameters
commitments
string
required
comma-separated list of commitments

Responses
200
Array of state paths by commitments.

application/json
Schema
Example (auto)

Height by Hash
GET
https://api.provable.com/v2/mainnet/height/:hash
Returns the block height for the specified block hash.

Request
Path Parameters
hash
string
required
block hash

Responses
200
Block height

application/json
Schema
default
Schema

Historical values for credits.aleo mappings
GET
https://api.provable.com/v2/mainnet/block/:height/history/:mapping
Returns historical values for one of the following credits.aleo mappings at a given height.

bonded
delegated
metadata
unbonding
withdraw
Request
Path Parameters
height
string
required
mapping
string
required
Responses
200
Array of mapping values.

application/json
Schema
Example (auto)
Schema
Array [
string
Latest Committee
GET
https://api.provable.com/v2/mainnet/committee/latest
Returns the latest committee information.

id: Unique identifier for this committee.

starting_round: The round number when this committee started.

members: An object keyed by validator address. Each value is an array with:

Bonded Value â€“ total stake bonded to this validator (in microcredits).

Open Status â€“ true if the validator is currently open/active, false if not.

Commission (%) â€“ the validator's commission rate as a percentage.

total_stake: Sum of all bonded value across committee members.

Responses
200
Latest committee information.

application/json
Schema
Example (auto)
Schema
id
string
starting_round
integer
members
object
total_stake
integer

Committee by Height
GET
https://api.provable.com/v2/mainnet/committee/:height
Returns committee information by specified block height.

id: Unique identifier for this committee.

starting_round: The round number when this committee started.

members: An object keyed by validator address. Each value is an array with:

Bonded Value â€“ total stake bonded to this validator (in microcredits).

Open Status â€“ true if the validator is currently open/active, false if not.

Commission (%) â€“ the validator's commission rate as a percentage.

total_stake: Sum of all bonded value across committee members.

Request
Path Parameters
height
string
required
Responses
200
Committee information by block height

application/json
Schema
Example (auto)
Schema
id
string
starting_round
integer
members
object
total_stake
integer

Delegators by Validator Address
GET
https://api.provable.com/v2/mainnet/delegators/:validator
Returns delegators for the specified validator.

Request
Path Parameters
validator
string
required
Responses
200
Array of delegator addresses.

application/json
Schema
Example (auto)
Schema
Array [
string
]

Program by Program ID
GET
https://api.provable.com/v2/mainnet/program/:programID
Returns a program by that program's id, with an optional flag to include metadata.

Request
Path Parameters
programID
string
required
Query Parameters
metadata
boolean
Responses
200
Program

application/json
Schema
Example (auto)
Schema
program
string

Find Transition ID by Input or Output ID
GET
https://api.provable.com/v2/mainnet/find/transitionID/:inputOrOutputID
Returns the transition ID for the specified input or output ID.

Request
Path Parameters
inputOrOutputID
string
required
Responses
200
Transition ID

application/json
Schema
Example (auto)
Schema
string
string

Program Mappings by Program ID
GET
https://api.provable.com/v2/mainnet/program/:programID/mappings
Returns mappings for the specified program. Returns null if no mappings exist for that program.

Request
Path Parameters
programID
string
required
Responses
200
Array of mappings, null if none exist.

application/json
Schema
Example (auto)
Schema
Array [
string
]

Latest Edition of Program
GET
https://api.provable.com/v2/mainnet/program/:programID/latest_edition
Returns the latest edition number for the specified program.

Request
Path Parameters
programID
string
required
Responses
200
Latest edition number

application/json
Schema
Schema
integer
integer
Program by Edition
GET
https://api.provable.com/v2/mainnet/program/:programID/:edition
Returns specified edition of a program.

Request
Path Parameters
programID
string
required
edition
string
required
Responses
200
Program code by edition

application/json
Schema
Example (auto)
Schema

Program Mapping Value by Name
GET
https://api.provable.com/v2/mainnet/program/:programID/mapping/:mappingName/:key
Returns the value for a specific mapping key.

Request
Path Parameters
programID
string
required
mappingName
string
required
key
string
required
Query Parameters
metadata
boolean
Responses
200
Program mapping value

application/json
Schema
Example (auto)
Schema
string
string

Find Program Deployment Transaction
GET
https://api.provable.com/v2/mainnet/find/transactionID/deployment/:programID
Returns the deployment transaction ID for the specified program.

Request
Path Parameters
programID
string
required
Responses
200
Transaction ID

application/json
Schema
Example (auto)
Schema
string
string/

Find Program Deployment Transaction by Edition
GET
https://api.provable.com/v2/mainnet/find/transactionID/deployment/:programID/:edition
Returns the deployment transaction ID for the specified edition of a program.

Request
Path Parameters
programID
string
required
edition
string
required
Responses
200
Transaction ID

application/json
Schema
Example (auto)
Schema
string
string
Broadcast Solution
POST
https://api.provable.com/v2/mainnet/solution/broadcast
Broadcasts a solution to the network.

Request
application/json
Bodyrequired
object
object
Responses
200
Broadcast result

application/json
Schema
Example (auto)
Schema
string
string

Transaction by Transaction ID
GET
https://api.provable.com/v2/mainnet/transaction/:txID
Returns information for given transaction.

Request
Path Parameters
txID
string
required
Responses
200
Transaction data

application/json
Schema
Example (auto)
Schema
type
string
id
string
execution
object
fee
object

Find Transaction ID by Transition ID
GET
https://api.provable.com/v2/mainnet/find/transactionID/:transitionID
Returns the transaction ID for the specific transition.

Request
Path Parameters
transitionID
string
required
Responses
200
Transaction ID

application/json
Schema
Example (auto)
Schema
string
string
Confirmed Transaction
GET
https://api.provable.com/v2/mainnet/transaction/confirmed/:txID
Returns confirmed transaction information from the ledger.

Request
Path Parameters
txID
string
required
Responses
200
Transaction information

application/json
Schema
Example (auto)
Schema
status
string
type
string
index
integer
transaction
object
finalize
object[]
curl
http
CURL
curl -L 'https://api.provable.com/v2/mainnet/transaction/confirmed/:txID' \
-H 'Accept: application/json'


Request
Collapse all
Base URL
https://api.provable.com/v2/mainnet
Parameters
txID â€” pathrequired
txID
Send API Request
Response
Clear
Click the Send API Request button above and see the response here!

Previous
Find Transaction ID by Transition ID

Unconfirmed Transaction
GET
https://api.provable.com/v2/mainnet/transaction/unconfirmed/:txID
Returns unconfirmed transaction information.

Request
Path Parameters
txID
string
required
Responses
200
Transaction information

application/json
Schema
Example (auto)
Schema
type
string
id
string
execution
object
fee
object



Broadcast Transaction
POST
https://api.provable.com/v2/mainnet/transaction/broadcast
Broadcasts a transaction to the network.


Latest Block
GET
https://api.provable.com/v2/mainnet/blocks/latest
Returns the latest block data.

Responses
200
Latest block data

application/json
Schema
Example (auto)
Schema
block_hash
string
previous_hash
string
header
object
authority
object
ratifications
object[]
solutions
object
aborted_solution_ids
object[]
transactions
object[]
aborted_transaction_ids
object[]
curl
http
CURL
curl -L 'https://api.provable.com/v2/mainnet/blocks/latest' \
-H 'Accept: application/json'


Request
Collapse all
Base URL
https://api.provable.com/v2/mainnet
Send API Request
Response
Clear
Click the Send API Request button above and see the response here!

Previous
Broadcast Transaction

Latest Block Hash
GET
https://api.provable.com/v2/mainnet/blocks/latest/hash
Returns the hash of the latest block.

Responses
200
Latest block hash

application/json
Schema
Example (auto)
Schema
hash
string

Latest Block Height
GET
https://api.provable.com/v2/mainnet/blocks/latest/height
Returns the latest block height.

Responses
200
Latest block height

application/json
Schema
Example (auto)
Schema
height
integer
Block by Height
GET
https://api.provable.com/v2/mainnet/blocks/height/:height
Returns a block by specified height.

Request
Path Parameters
height
string
required
Responses
200
Block data

application/json
Schema
Example (auto)
Schema
block_hash
string
previous_hash
string
header
object
authority
object
ratifications
object[]
solutions
object
aborted_solution_ids
object[]
transactions
object[]
aborted_transaction_ids
object[]

Block by Hash
GET
https://api.provable.com/v2/mainnet/blocks/hash/:hash
Returns a block by specified hash.

Request
Path Parameters
hash
string
required
Responses
200
Block data

application/json
Schema
Example (auto)
Schema
block_hash
string
previous_hash
string
header
object
authority
object
ratifications
object[]
solutions
object
aborted_solution_ids
object[]
transactions
object[]
aborted_transaction_ids
object[]

Find Block Hash by Transaction ID
GET
https://api.provable.com/v2/mainnet/blocks/find/blockHash/:txID
Returns the block hash containing the specified transaction.

Request
Path Parameters
txID
string
required
Responses
200
Block hash

application/json
Schema
Example (auto)
Schema
hash
string

Latest State Root
GET
https://api.provable.com/v2/mainnet/blocks/latest/stateRoot
Returns the latest state root.

Responses
200
Latest state root

application/json
Schema
Example (auto)
Schema
stateRoot
string

State Root by Height
GET
https://api.provable.com/v2/mainnet/blocks/stateRoot/:height
Returns the state root at the specified height.

Request
Path Parameters
height
string
required
Responses
200
State root at specified height

application/json
Schema
Example (auto)
Schema
stateRoot
string

Find Block Height by State Root
GET
https://api.provable.com/v2/mainnet/blocks/find/blockHeight/:stateRoot
Returns the block height for the specified state root.

Request
Path Parameters
stateRoot
string
required
Responses
200
Block height

application/json
Schema
Example (auto)
Schema
height
integer

Find State Path by Commitment
GET
https://api.provable.com/v2/mainnet/blocks/find/statePath/:commitment
Returns the state path for the specified commitment.

Request
Path Parameters
commitment
string
required
Responses
200
State path

application/json
Schema
Example (auto)
Schema
string
string
State Paths by Commitments
GET
https://api.provable.com/v2/mainnet/blocks/find/statePaths
Returns state paths for multiple commitments separated by comma.

Request
Query Parameters
commitments
string
Comma-separated list of commitments

Responses
200
Array of state paths

application/json
Schema
Example (auto)
Schema
Array [
string
]

Find Block Height by Hash
GET
https://api.provable.com/v2/mainnet/blocks/find/heightByHash/:blockHash
Returns block height for specified block hash.

Request
Path Parameters
blockHash
string
required
Responses
200
Block height

application/json
Schema
Example (auto)
Schema
height
integer

Historical values for credits.aleo mappings
GET
https://api.provable.com/v2/mainnet/blocks/find/blockHistory/:blockHeight/:mapping
Returns historical values for one of the following credits.aleo mappings at a given height.

bonded
delegated
metadata
unbonding
withdraw
Request
Path Parameters
blockHeight
string
required
mapping
string
required
Responses
200
Array of mapping values

application/json
Schema
Example (auto)
Schema
Array [
string
]
Latest Transactions Summary
GET
https://api.provable.com/v2/mainnet/transactions/summary/latest
Returns information about the latest 1,000 transactions.

Responses
200
Transactions summary

application/json
Schema
Example (auto)
Schema
Array [
id
string
fee
integer
status
string
block_height
integer
block_timestamp
string
block_hash
string
transaction_type
string
program_id
string
function_id
string
]

Transaction by Transaction ID
GET
https://api.provable.com/v2/mainnet/transactions/:txID
Returns information for given transaction.

Request
Path Parameters
txID
string
required
Responses
200
Transaction data

application/json
Schema
Example (auto)
Schema
type
string
id
string
execution
object
global_state_root
string
proof
string
fee
object
fee_value
integer
block_height
integer
block_hash
string
block_timestamp
string
status
string

Find Transaction ID by Transition ID
GET
https://api.provable.com/v2/mainnet/transactions/find/transactionID/:transitionID
Returns the transaction ID for the specified transition.

Request
Path Parameters
transitionID
string
required
Responses
200
Transaction ID

application/json
Schema
Example (auto)
Schema
string
string

Confirmed Transaction
GET
https://api.provable.com/v2/mainnet/transactions/confirmed/:txID
Returns confirmed transaction information from the ledger.

Request
Path Parameters
txID
string
required
Responses
200
Transaction information

application/json
Schema
Example (auto)
Schema
status
string
type
string
index
integer
transaction
object

Unconfirmed Transaction
GET
https://api.provable.com/v2/mainnet/transactions/unconfirmed/:txID
Returns unconfirmed transaction information from the memory pool.

Request
Path Parameters
txID
string
required
Responses
200
Unconfirmed transaction information

application/json
Schema
Example (auto)
Schema
object
object

Transactions by Block Height
GET
https://api.provable.com/v2/mainnet/transactions/block/:height
Returns all transactions in the specified block.

Request
Path Parameters
height
string
required
Responses
200
Array of transactions at specified block height

application/json
Schema
Example (auto)
Schema
transactions
object[]
Transactions by Block Hash
GET
https://api.provable.com/v2/mainnet/transactions/block/:hash
Returns all transactions in the specified block.

Request
Path Parameters
hash
string
required
Responses
200
Array of transactions at specified block hash

application/json
Schema
Example (auto)
Schema
transactions
object[]
Transitions by Address
GET
https://api.provable.com/v2/mainnet/transitions/:address
Returns transitions for specified address.

Request
Path Parameters
address
string
required
Responses
200
Array of transitions

application/json
Schema
Example (auto)
Schema
Array [
id
string
transaction_status
string
block_height
integer
transaction_id
string
program_id
string
function_id
string
amount
string
block_timestamp
integer
sender_address
string
recipient_address
string
]



Broadcast Transaction
POST
https://api.provable.com/v2/mainnet/transactions/broadcast
Broadcasts a transaction to the network.

Responses
200
Transaction broadcast result

Program by Program ID
GET
https://api.provable.com/v2/mainnet/programs/:programID
Returns a program by that program's id, with an optional flag to include metadata.

Request
Path Parameters
programID
string
required
Query Parameters
metadata
boolean
Responses
200
Program

application/json
Schema
Example (auto)
Schema
id
string
block_height
integer
block_timestamp
string
transaction_id
string
program_owner
string
program
string
edition
integer

Latest Calls by Program ID
GET
https://api.provable.com/v2/mainnet/programs/:programID/latest-calls
Returns the latest 1000 calls to a specified program.

Request
Path Parameters
programID
string
required
Responses
200
Array of program calls/transactions

application/json
Schema
Example (auto)
Schema
Array [
transaction_id
string
function_id
string
block_number
integer
block_timestamp
string
status
string
]

Latest Edition of Program
GET
https://api.provable.com/v2/mainnet/programs/:programID/latest_edition
Returns the latest edition number for the specified program.

Request
Path Parameters
programID
string
required
Responses
200
Latest edition number

application/json
Schema
Example (auto)
Schema
string
string

Program by Edition
GET
https://api.provable.com/v2/mainnet/programs/:programID/:edition
Returns specified edition of a program.

Request
Path Parameters
programID
string
required
edition
string
required
Responses
200
Program by edition

application/json
Schema
Example (auto)
Schema
id
string
block_height
string
block_timestamp
string
transaction_id
string
program_owner
string
program
string
edition
integer

Program Mapping Value by Name
GET
https://api.provable.com/v2/mainnet/programs/program/:programID/mapping/:mappingName/:key
Returns the value for a specific mapping key.

Request
Path Parameters
programID
string
required
mappingName
string
required
key
string
required
Query Parameters
metadata
boolean
Responses
200
Program mapping value

application/json
Schema
Example (auto)
Schema
data
string
height
integer

Program Mappings by Program ID
GET
https://api.provable.com/v2/mainnet/programs/program/:programID/mappings
Returns mappings for the specified program. Returns null if no mappings exist.

Request
Path Parameters
programID
string
required
Responses
200
Array of mappings, null if none exist

application/json
Schema
Example (auto)
Schema
Array [
string
]

Find Transition ID by Input or Output ID
GET
https://api.provable.com/v2/mainnet/programs/find/transitionID/:inputOrOutputID
Returns the transition ID for the specified input or output ID.

Request
Path Parameters
inputOrOutputID
string
required
Responses
200
Transition ID

application/json
Schema
Example (auto)
Schema
string
string
Program Deployment Transaction
GET
https://api.provable.com/v2/mainnet/programs/program/:programID/deployment
Returns the deployment transaction ID for the specified program.

Request
Path Parameters
programID
string
required
Responses
200
Transaction ID

application/json
Schema
Example (auto)
Schema
transaction_id
string
Program Deployment Transaction by Edition
GET
https://api.provable.com/v2/mainnet/programs/program/:programID/edition/:edition/deployment
Returns the deployment transaction ID for the specified edition of a program.

Request
Path Parameters
programID
string
required
edition
string
required
Responses
200
Transaction ID

application/json
Schema
Example (auto)
Schema
transaction_id
string




Provable API Documentation
Overview
The Provable API provides access to the Aleo blockchain through RESTful endpoints.
Developers can query block-level information, transactions, programs, transitions, and more, as well as broadcast transactions. These endpoints are foundational for building applications and services in the Aleo ecosystem.

Rate Limiting
Rate limiting is enforced across all endpoints:

5 requests per second
100,000 requests per day
Abuse may result in blacklisting. For higher limits, contact explorer@provable.com.

Quick Links
ðŸš€ Get Started with API v2
Base URL: https://api.provable.com/v2/{network}

ðŸ“– Browse by Category
SnarkOS Core Endpoints
Blocks - Block data, state roots, and history
Transactions - Transaction queries and broadcasting
Committee - Validator and delegation info
Programs - Smart contract queries
Solutions - Prover solution broadcasting
Public API
Blocks - Block data, state roots, and history
Transactions - Transaction queries and broadcasting
Programs - Smart contract queries
Metrics - Block, transaction, and program analytics
Supply - Total and circulating supply
DeFi - DeFi metrics and token data
Staking - Delegation and staking data
Proving - Prover statistics and rewards
Address - Address-specific data
Delegated Proving
Submit Delegated Proof - Submit proofs for delegated execution
Record Scanning
Register Scanner - Register a new scanner
Get Owned Records - Retrieve owned records
Get Scanner Status - Check scanner status
Auth
Register for Auth - Register for authentication
Issue JWT - Issue a signed JWT
API v2 Reference
SnarkOS
Core blockchain endpoints that mirror SnarkOS client node functionality.

Blocks
Get latest block
Get latest block height
Get latest block hash
Get block by height or hash
Get block hash by transaction ID
Get transactions by block height
Get blocks in range
Get latest state root
Get state root by height
Get block height by state root
Get state path by commitment
Get state paths by commitments
Get height by hash
Get block history
Committee
Get latest committee
Get committee by height
Get delegators by validator
Programs
Get program by ID
Get transition ID by input/output ID
Get program mappings
Get latest edition of program
Get program by edition
Get program mapping value
Get program deployment transaction
Get program deployment by edition
Solutions
Broadcast solution
Transactions
Transaction by transaction ID
Transaction by transition ID
Confirmed transaction
Unconfirmed transaction
Broadcast transaction
Public API
Enhanced endpoints for explorer and analytics functionality.

Blocks
Latest Block
Latest Block Hash
Latest Block Height
Block by Height
Block by Hash
Find Block Hash by TX ID
Latest State Root
State Root by Height
Find Block Height by State Root
Find State Path by Commitment
State Paths by Commitments
Find Height by Hash
Block History
Transactions
Transactions by Address
Latest Transactions Summary
Transaction by TX ID
Find TX ID by Transition ID
Confirmed Transaction
Unconfirmed Transaction
Transactions by Block Height
Transactions by Block Hash
Transitions by Address
Broadcast Transaction
Programs
Program by ID
Latest Calls by Program ID
Latest Edition of Program
Program by Edition
Program Mapping Value
Program Mappings
Find Transition ID
Program Deployment TX
Program Deployment TX by Edition
Metrics
Latest Blocks Summary
Transaction Metrics Daily
Program Metrics
Puzzle Rewards Monthly
APY Monthly
APY for Current Validators
Program Metrics by Range
Validator Participation
Puzzle Rewards Daily
Total Prover Metrics
APY Last 24 Hours
Supply
Total Supply
Total Supply - Microcredits
Circulating Supply - Microcredits
Circulating Supply - Credits
DeFi
DeFi Total Value
Token Details
Token Price History
Compliance Freeze List
Staking
Latest Delegators
Proving
All Provers
Address
Staking Earnings by Address
Solutions by Address
Puzzle Rewards by Address
Delegated Proving
Submit delegated proof
Record Scanning
Register scanner
Get owned records
Get record tags
Get record serial numbers
Get scanner status
Get encrypted records
Auth
Register for auth
Issue JWT
API v1 Reference
Blocks
Get latest block
Get blocks in range
Get latest block height
Get latest block hash
Get block by height or hash
Get block hash by transaction ID
Get latest state root
Get state root by height
Get block height by state root
Get state path by commitment
Get height by hash
Get block history
Committee
Get latest committee
Get committee by height
Get delegators by validator
Programs
Get program by ID
Get latest edition of program
Get program by edition
Get program mappings
Get program mapping value
Get transition ID by input/output ID
Get program deployment transaction
Get program deployment by edition
Solutions
Broadcast solution
Supply
Get total supply
Get latest total supply
Get circulating supply
Get latest circulating supply
Transactions
Get transaction by id
Get transaction by transition ID
Get confirmed transaction
Get unconfirmed transaction
Get transactions by block identifier
Broadcast transaction

Accounts
An Aleo account is composed of an account private key, account view key, and an account address.

The account private key is used to authorize a transaction, which updates the global state of account records. The account view key is used to decrypt account records, which are encrypted under the user's account address. Lastly, the account address enables users to interact with one another, sending and receiving records that encode values and application data.

To protect user assets and record data, one should never disclose their account private key to any third parties. For real-world applications on Aleo, users should derive a compute key from their account private key to allow third parties to trustlessly run applications and generate transactions on a user's behalf.

User can also generate a new Aleo account using the utility sidebar on https://play.leo-lang.org/.

Account Private Key
An account private key is constructed from a randomly-sampled account seed. This account seed is used to generate:

a secret key for the account signature scheme,
a pseudorandom function seed for transaction serial numbers, and
a commitment randomness for the account commitment scheme.
Private Key Format
APrivateKey1zkp4X9ApjTb7Rv8EABfZRugXBhbPzCL245GyNtYJP5GYY2k


An account private key is formatted as a Base58 string, comprised of 59 characters. The account private key is encoded with a private key prefix that reads APrivateKey1, indicating that it is a private key and should not be shared with other users.

Account View Key
An Aleo account view key is derived from an account private key and enables users to decrypt their records from the global ledger. As account view keys are able to access every record in a user's account, this key can be used by third-party auditors to verify the complete history of an account.

The account view key is comprised of:

a secret key for the account encryption scheme.
View Key Format
AViewKey1nKB4qr9b5gK8wQvmM5sTPEuBwshtDdkCZB1SPWppAG9Y

An account view key is formatted as a Base58 string, comprised of 53 characters. The account view key is encoded with a view key prefix that reads AViewKey1, indicating that it is a view key and should only be shared with authorized parties.

Account Address
An Aleo account address is a unique identifier that allows users to transfer value and record data to one another in transactions.

The account address is comprised of:

a public key for the account encryption scheme.
Address Format
aleo1dg722m22fzpz6xjdrvl9tzu5t68zmypj5p74khlqcac0gvednygqxaax0j


An account address is formatted as a Bech32 string, comprised of 63 characters. The account address is encoded with an address prefix that reads aleo1.

Advanced Topics
The descriptions of algorithms below make use of the following definitions of mathematical objects:

Prime Fields
For a prime r, the prime field of order r is defined as the set of integers {0, 1, ..., r - 1} with addition and multiplication modulo r. In this document, we will use two prime fields:

Fscalar, of prime order p = 2111115437357092606062206234695386632838870926408408195193685246394721360383
Fbase, of prime order q = 8444461749428370424248824938781546531375899335154063827935233455917409239041
Prime Order Elliptic Curve Groups
In this document, we will consider the order-p subgroup of points on an elliptic curve defined over the base field Fbase.

Elements of this subgroup consist of a coordinate pair (x, y). The group has two associated operations: point addition, and point doubling. The group also has a distinguished point, the generator G, which is a fixed point of the group.

HashToField
For a finite field F, HashToField is a cryptographic hash function that takes as input either a sequence of bytes or a sequence of field elements and outputs a field element. The output is uniformly distributed over the field F.

HashToScalar
An instantiation of HashToField that output elements in the scalar field Fscalar. source code

EncodeToF
EncodeToF(x) is a function that encodes the Unicode string x into an element of Fbase.

Details of the encoding:

x is converted to its UTF-8 sequence of bytes b.
b is turned into an unsigned integer v that represents the little endian value of b.
v is reduced modulo the prime that defines the field Fbase.
Account Prefixes
Type	Human-Readable Prefix	Prefix Bytes
Account Private Key	bytes	APrivateKey1	[127, 134, 189, 116, 210, 221, 210, 137, 145, 18, 253]
Account View Key	bytes	AViewKey1	[ 14, 138, 223, 204, 247, 224, 122 ]
Account Address	string	aleo1	aleo1
Offline Accounts
In many instances such as enterprise settings, it is advisable to handle sensitive keys and data on isolated, offline machines. An Aleo account can be created on an offline machine and available for immediate use. In conjunction with account proving keys, a user can ensure their private key remains offline even for creating transactions.

While no solution is perfect, it is advisable to create a new Aleo account on a disconnected device to minimize the risk of leaking one's account private key to unintended parties.

Account Commitment Outputs
The account commitment output is used to create an account view key, which is comprised of an encryption secret key. This encryption secret key is a scalar field element derived from the account commitment output. To ensure the validity of the account view key, the account commitment output should be representable in the scalar field.

Create an Account
Given global instantiated Aleo parameters and subroutines.

Generate a Private Key
Sample a 32 byte seed from random

Construct private key components

sk_sig = HashToScalar(EncodeToF("AleoAccountSignatureSecretKey0") || seed)
r_sig = HashToScalar(EncodeToF("AleoAccountSignatureRandomizer0.0") || seed)
where || denotes concatenation, and HashToScalar denotes the Poseidon hash function, specifically with an input rate of 2. seed is converted into Field type before hashing.

3.private_key = (seed, (sk_sig, r_sig))

Generate a View Key
(sk_sig, r_sig) = private_key
view_key = sk_sig + r_sig + HashToScalar(sk_sig * G || r_sig * G)
where G is the generator of the base field, which is a vector of elliptic curve group elements generated by hashing a given input domain message to a curve point and repeatedly doubling it up to the size of the scalar field (in bits). + is scalar addition.

Generate an Address
address = view_key * G

Programs
A program is a fundamental data structure for representing application logic and application state.

Aleo introduces a new programming language called Aleo instructions that enables developers to write private web applications. Aleo instructions is a statically-typed programming language for writing privacy-preserving, secure programs on Aleo. By leveraging zero-knowledge proofs, Aleo instructions offers computational integrity for real-world applications.

Program Logic
Aleo instructions offers developers with an easy-to-use environment for writing programs. By designing an assembly language with syntax familiar to developers and composable in features, Aleo instructions is well-suited to integrate with existing developer frameworks to supercharge web apps with privacy and integrity.

program token.aleo;

record token:
    // The token owner.
    owner as address.private;
    // The token balance.
    amount as u64.private;

// The `mint` function initializes a new record with the
// specified number of tokens in `r1` for the receiver in `r0`.
function mint:
    input r0 as address.private;
    input r1 as u64.private;
    cast r0 r1 into r2 as token.record;
    output r2 as token.record;

// The `transfer` function sends the specified number of tokens
// to the receiver from the provided token record.
function transfer:
    // Input the sender's record.
    input r0 as token.record;
    // Input the token receiver.
    input r1 as address.private;
    // Input the token amount.
    input r2 as u64.private;

    // Checks the given token record has sufficient balance.
    // This `sub` operation is safe, and the proof will fail
    // if an underflow occurs. The output register `r3` holds
    // the change amount to be returned to the sender.
    sub r0.amount r2 into r3;

    // Produces a token record for the specified receiver.
    cast r1 r2 into r4 as token.record;

    // Produces a token record with the change amount for the sender.
    cast r0.owner r3 into r5 as token.record;

    // Output the receiver's record.
    output r4 as token.record;
    // Output the sender's change record.
    output r5 as token.record;


Program Data
Program ID
Each program has a unique program ID that is stored in the program manifest program.json. This program ID is used to indicate the program that was run in the consumption or production of records.

Program Input
To run a program, user-defined inputs are provided in the form of a program input. This input provided by the user is fully private and not revealed to the public network, unless the user intends for it to be public.

Program State
Each program is run with respect to user-provided program state on Aleo. In order to produce a valid state transition on Aleo, the user satisfies a series of programs encoded in records, which compose a transaction.

Program Output
Once a program is evaluated, its program output is produced, along with a zero-knowledge proof attesting to the validity of the output.

Limitation
Currently there are limits imposed on every program deployment to ensure validators processing times and therefore block times remain consistent and low. The limitation details can be found in the Leo documentation.

Generally these limits involve the number of constraints and variables enforced by snarkVM. A large portion of them comes from hashing, which occurs silently under the hood for all arguments and return values in function calls. One way to reduce these counts is to minimize the passing of large structs, arrays, or integers (which are sometimes represented as bits).

Records
A record is a fundamental data structure for encoding user assets and application state.

Each account record contains information that specifies the record owner, its stored value, and its application state. Records in Aleo are consumed and newly created from a transition function. A transaction will store multiple transitions, each of which is responsible for the consumption and creation of its individual records. Optionally, if the visibility of an entry in the record is private, it is be encrypted using the owner's address secret key.

Components of a Record
An Aleo record is serialized in the following format:

Parameter	Type	Description
owner	address	The address public key of the owner of the program record
data	Map<Identifier, Entry>	A data payload containing arbitrary application-dependent information. Each entry can either be public or private.
nonce	group	The serial number nonce of the program record
version	u8	The version of the program record
An example record:

{
  owner: aleo13ssze66adjjkt795z9u5wpq8h6kn0y2657726h4h3e3wfnez4vqsm3008q.private,
  amount: 100u64.private,
  _nonce: 5861592911433819692697358191094794940442348980903696700646555355124091569429group.public,
  version: 1u8.public
}


Owner
aleo13ssze66adjjkt795z9u5wpq8h6kn0y2657726h4h3e3wfnez4vqsm3008q

The record owner is an account address, and specifies the party who is authorized to spend the record.

Data
100u64.private

The record can encode arbitrary application information. The "amount" key is the data payload that the record carries. An entry which has a visibility of private is encrypted and stored on the ledger. This enables users to securely and privately transfer record data and values between one another over the public network. Only the sender and receiver with their corresponding account view keys are able to decrypt the private entries.

Nonce
5861592911433819692697358191094794940442348980903696700646555355124091569429group

The serial number nonce is used to create a unique identifier for each record, and is computed via a PRF evaluation of the address secret key ask of the owner and the record's serial number.

Version
1u8.public

The version field specifies the version of the program record, which determines how the record commitment is derived and what privacy features are available.

Record v0
Uses the BHP hash to derive the record commitment
No sender ciphertext is included
Can only be decrypted with an accountâ€™s view key
Allowed before Consensus V8, but disallowed after
Record v1
Uses a BHP commitment with a nonce to derive the record commitment, where the nonce is generated from the record view key
Enhanced privacy with hiding properties
Includes encrypted sender ciphertext, allowing users to determine which address sent them a record
Can be decrypted with the record view key without sharing an accountâ€™s view key
Required after Consensus V8
For a practical demonstration of a record in Aleo, watch the video here (Version 0). More record details can be found in transitions.

Diving into the Concepts
To understand how to use records, we must understand the design principles behind Aleo. Autonomous Ledger Execution Offchain (Aleo) is a layer-1 blockchain that combines general-purpose programmability with privacy by default. The core idea behind Aleo is ZEXE or zero-knowledge execution initially written in this research paper in 2018. It first introduced the record model which extends the UTXO model from Zcash and enables storing and encrypting arbitrary data (user assets and application states), rather than just values of specific assets or tokens.

Privacy
There are generally four different types of privacy that relate to blockchains.

Aleo fulfils three of them:

 Private inputs (messages)
 Private outputs (state changes)
 Private user
 Private function
Initially, Aleo was aiming for function privacy as well (as detailed in the original ZEXE paper) but decided against it as it would have led to worse performance and longer proving times.

Comparing state storage in blockchains
There are two main state models used in blockchains - UTXO (unspent transaction output) and the account model (introduced by Ethereum).

Aleo uses a variation of the UTXO model - the record model.

Account vs UTXO

Source: galaxy.com



Account Model
In the account model as used in Ethereum, the application state can be found by referencing a particular address.

As such, anyone would be able to view the activities of any account, simply with the knowledge of the address.

Ethereum Storage Diagram

Source: ethereum.org



Ethereum World State Diagram

Source: Article by Lucas Saldanha



Record Model
In the record model, the application state, along with its owner are encrypted and stored on the blockchain.

Aleo Records Diagram

Source: Zexe: Enabling Decentralized Private Computation



Aleo World State Diagram

Source: Zexe: Enabling Decentralized Private Computation



Updating State
In the record model, applications update their state by consuming records containing the old state, and producing new records that contain the updated state. Records that have been used will be marked as spent and cannot be used again.

UTXO diagram

Source: adapulse.io



The consumption and production of records is typically done in a transition function. A transaction in Aleo can contain up to 32 transitions, one of which is reserved for the transaction fee.

Transaction in Aleo

Why is the Record Model Useful?
In the account-based model, an application's data is stored in a persistent location tied to the application's account, and updates are made directly to this stored data. For a typical token transfer transaction using this model, user balances would be stored in a table mapping user account addresses to their respective balances. When User A transfers money to User B, A's balance in the table is reduced, and B's balance is increased by the same amount. If we were to try making the transactions private (hiding the amount transferred and the identities of A and B), instead of storing actual balances, the application can store commitments to these balances. Transactions would then update these commitments rather than the actual balances. However, while this approach hides transaction values, it does not hide user identities. To also hide user identities, every transaction would need to update all commitments in the table, which becomes increasingly inefficient as the number of users grows. Although the account model is more intuitive for developers, it uses account addresses to index global state. This means that while a private account model can achieve privacy for inputs and outputs, it still compromises user privacy since account addresses cannot be encrypted. Another issue with the private account model is the lack of concurrency, as only one user can access and update the entire program state at a time. Aleo's record model uses program IDs to uniquely identify programs instead of account addresses. This improves privacy and enables programs to have internal states. This approach is more efficient and solves the concurrency issue.

Aleo Credits
Overview
The official currency of Aleo Network are called Aleo Credits. All fees paid for transactions, as well as rewards for staking and mining, are in the form of Aleo Credits.

Unlike other popular Blockchains like Ethereum, there is no special transfer transaction type. Instead, a native program called credits.aleo governs transfers, usage, and ownership of Aleo Credits. All value transfers on the Aleo Network are done by calling functions in the credits.aleo program via Execute transactions. This enables users to send Aleo Credits privately, publicly, or a mix of both as well as initiate staking and other advanced on-chain operations with Aleo credits.

Aleo Credits are denominated as either credits or microcredits, where the smallest unit is 1 microcredit (equal to 0.000001 credit). The credits.aleo program function parameters take amounts in microcredits. There is a denomination table here for reference.

The same credits.aleo program also hosts all staking-related functions and states. For more information about staking functionality, please refer to the Staking documentation.

A small selection of the credit transfer functions available in credits.aleo is visualized below:

program credits.aleo

Public Inputs:
(receiver, amount)

Public Outputs:
(sender, receiver, amount)

Public Inputs:
(receiver, amount)

Public Outputs:
(signer, receiver, amount)

Private (Hidden) Inputs:
record

Private (Hidden) Outputs:
record

Private (Hidden) Inputs:
record

Public Outputs:
(receiver, amount)

Public Inputs:
(amount)

Private Outputs:
record

transfer_public

transfer_public_as_signer

transfer_private

transfer_private_to_public

transfer_public_to_private

function caller (aleo1123...)

receiver (aleo1456...)

txn signer (aleo1123...)

receiver (aleo1456...)

function caller (hidden)

receiver (hidden)

function caller (hidden)

receiver (aleo1456...)

function caller (aleo1123...)

receiver (hidden)

note
Important distinction between function caller and transaction signer:

Function Caller: The immediate function caller, which could be an intermediate program or contract that initiated the current function call
Transaction Signer: The original transaction signer who initiated the entire transaction, regardless of how many intermediate programs are involved in the call chain
important
Private transfers or any functions involving records should use a private key controlled account address as the recipient. This is because:

Records are encrypted with the recipient's public key and can only be decrypted with the corresponding private key
A program address is derived from a hash function and has no associated private key, making it incapable of decrypting any records
Records should never be sent to a program address because they would become permanently inaccessible
When performing private transfers or any operations involving records, always ensure the recipient is a user account address (controlled by a private key) rather than a program address.

Public/Private Credits
There are two main ways to hold Aleo Credits on the network:

Private Balances via credits Records
The first method is owning a credits record which enables a participant in the Aleo network to hold a private balance of Aleo credits.

record credits:
    owner as address.private;
    microcredits as u64.private;

A user's total private credits balance will consist of all unspent credits records owned by the user with a non-zero microcredits value. These records are analogous to UTXOs in Bitcoin. It is generally the responsibility of a wallet application to scan the chain for records that belong to a user and determine which are spent and unspent in order to calculate the user's total private balance and private transaction history.

Public Balances via the account Mapping
The second method is by holding a balance in the account mapping in the credits.aleo program on the Aleo network. This mapping is an on-chain key-value store that is maintained and updated by Aleo validators at each block. This public balance is visible to all participants in the network and is analogous to the account balances in Ethereum.

mapping account:
    key owner as address.public;
    value microcredits as u64.public;

The total public credits balance of a user is the value of the account mapping at the user's address. Users can hold both private and public balances simultaneously.

Transferring Aleo Credits
There are five transfer functions available within credits.aleo.

transfer_private
Takes a credits record owned by the sender, subtracts an amount from it, and adds that amount to a new record owned by the receiver. This function is 100% private and does not affect the account mapping.

Input Parameters:

credits.record - The sender's record containing the credits to transfer
address.private - The receiver's address (private)
u64.private - The amount of microcredits to transfer in u64 (private)
record1 owner:user1address balance:10000u64

amount:4000u64

recipient:user2address

record2 owner:user1address amount:6000u64

record3 owner:user2address balance:4000u64

user1

transfer_private

user2

transfer_private_to_public
Takes a credits record owned by the sender, subtracts an amount from it, and adds that amount to the account mapping of the receiver. This function is 50% private and 50% public. It consumes a record as a private input and generates a public balance in the account mapping entry belonging to the receiver.

Input Parameters:

credits.record - The sender's record containing the credits to transfer
address.public - The receiver's address (public)
u64.public - The amount of microcredits to transfer in u64 (public)
credits.aleo

record3 owner:user2address balance:4000u64

amount:3000u64

recipient:user3address

record4 owner:user2address amount:1000u64

account mapping
key:user3address
value:3000u64

user1

transfer_private_to_public

transfer_public
Subtracts an amount of credits stored in the account mapping of the credits.aleo program, and adds that amount to the account mapping of the receiver. This function is 100% public and does not consume or generate any records.

Input Parameters:

address.public - The receiver's address (public)
u64.public - The amount of microcredits to transfer in u64 (public)
recipient:user2address amount:3000u64

credits.aleo

Before Transfer

account mapping
key:intermediate_program.aleo
value:3000u64

account mapping
key:user2address
value:0u64

After Transfer

account mapping
key:intermediate_program.aleo
value:0u64

account mapping
key:user2address
value:3000u64

txn signer (aleo1123...)

intermediate_program.aleo

transfer_public

note
The mapping key being modified is intermediate_program.aleo, which this is the "from" address in this transfer, not the transaction signer's address.

transfer_public_to_private
Subtracts an amount credits stored in the account mapping of the credits.aleo program and adds that amount to a new private record owned by the receiver. This function is 50% private and 50% public. It publicly consumes a balance in the account mapping entry belonging to the sender and generates a private record as a private output.

Input Parameters:

address.private - The receiver's address (private)
u64.public - The amount of microcredits to transfer in u64 (public)
recipient:user2address amount:3000u64

record5 owner:user2address amount:3000u64

credits.aleo

Before Transfer

account mapping
key:caller
value:3000u64

After Transfer

account mapping
key:caller
value:0u64

caller (aleo1123...)

transfer_public_to_private

user2

note
The mapping key being modified is same as transfer_public, where the "from" address in this transfer is the immediate caller of the function. Not the signer's address, if there is an intermediate program in between.

transfer_public_as_signer
Similar to transfer_public, this function subtracts an amount of credits stored in the account mapping of the credits.aleo program, and adds that amount to the account mapping of the receiver. However, this function uses the signer's address as the sender instead of the caller's address, ensures that the "from" context is always the original transaction initiator. This function is 100% public and does not consume or generate any records.

Input Parameters:

address.public - The receiver's address (public)
u64.public - The amount of microcredits to transfer in u64 (public)
recipient:user2address amount:3000u64

credits.aleo

Before Transfer

account mapping
key:txn signer
value:3000u64

account mapping
key:user2address
value:0u64

After Transfer

account mapping
key:txn signer
value:0u64

account mapping
key:user2address
value:3000u64

txn signer (aleo1123...)

intermediate_program.aleo

transfer_public_as_signer

note
The mapping key being modified is the transaction signer, which this is the "from" address in this transfer, not the intermediate program address.

tip
A program can use transfer_public_from_signer to receive funds from a user to itself, then use transfer_public to transfer funds from itself back to the user.

Transactions
A transaction is a fundamental data structure for publishing a new program or a set of state transitions on the ledger. On Aleo, a transaction is issued locally by a user using their Aleo private key, which corresponds to an on-chain Aleo account. Using tools like Leo CLI, Provable SDK or ecosystem wallet adapters such as Puzzle Wallet SDK.

Types of Transactions
Execute Transaction
The execution transaction represents a call to an Aleo program function. Below is the structure of an execution transaction response:

Parameter	Type	Description
type	string	The type of transaction (execute)
id	string	The ID of transaction, computed via the Merkle Tree Digest of the transition IDs
execution	object	The execution transaction info
fee	object	The execution transaction fee
Execution Object Info
Parameter	Type	Description
global_state_root	u16	The global state root of the merkle tree
transitions	array	The transitions
proof	string	ZK proof of the execution
Relationship of Transaction and Transition
A Transaction is the top-level unit that represents a complete operation. A Transition is a lower-level component that represents an individual state change within a Transaction.
A Transaction can contain multiple Transition objects. An Execution, which is part of a Transaction, includes a collection of Transitions.
A Transaction may contain multiple Transitions, especially in cases involving multiple cross-program calls.
For more information of a Transition, please refer to Transitions.

Building an execution transaction using Leo CLI
Required Details:

Program ID (name of deployed program)
Function name to execute
Arguments to the function
Network ID (testnet or mainnet)
Private key of the caller (or specify in .env from project directory)
Optional Parameters:

Broadcast flag (to send to the network or not)
Private fees
Priority fees
Deploy Transaction
The deployment transaction publishes an Aleo program to the network.

Parameter	Type	Description
type	string	The type of transaction (deploy)
id	string	The ID of transaction, computed via the Merkle Tree Digest of the transition IDs
owner	object	The owner address and signature
deployment	object	The deployment transaction info
fee	object	The deployment transaction fee
Deployment Object Info
Parameter	Type	Description
global_state_root	u16	The global state root of the merkle tree
transitions	array	The transitions
Building a deployment transaction
Required Details:

Compiled Leo program in Aleo Instructions
Network ID (testnet or mainnet)
Private key of the deployer (or specify in .env from project directory)
Optional Parameters:

Private fees
Priority fees
Fee Transaction
A fee transaction represents the network fee paid for processing. Rejected transactions are included in blocks as confirmed "rejected" transactions. In those cases, a new transaction ID is generated alongside a valid fee transaction to ensure the fee is charged. In normal successful execution case, the fee is recorded as a transition object within the execution or deployment transaction.

Parameter	Type	Description
type	string	The type of transaction (fee)
id	string	The ID of transaction, computed via the Merkle Tree Digest of the transition IDs
fee	object	The rejected transaction fee
Transaction fees are calculated based on the size of the transaction and how complicated operations the validators need to do. Fees can be paid in public or private with Aleo Credits records. For more detailed information about transaction fees, please refer to Transaction Fees.

Transaction Lifecycle
ðŸŒ ALEO NETWORK

ðŸ–¥ï¸ LOCAL CLIENT

ðŸ” External Prover

Execute

Deploy

Generate
Locally

Delegate Proving
Self-Paid Fee

Delegate Proving
Fee Master

User Pays

Prover Pays

Accepted

Rejected

Aborted

ðŸ”‘ User Initiates
Private Key + Inputs

ðŸ“‹ Transaction Type

ðŸ“¥ Download Programs
& SRS or use cached

ðŸ” Add Program
to VM Process

âœï¸ Authorization
Sign Function Call

ðŸ›¤ï¸ Proving & Fee Strategy

ðŸ“ Leo Compilation
Source â†’ Aleo Bytecode

ðŸ”§ Key Synthesis
Generate Verifying Keys

ðŸ’° Fee Calculation
Based on Program Size

âœï¸ Authorization
Sign Deployment

ðŸ“¦ Deploy Transaction
Assembly

âš™ï¸ Local Execution
Run VM & Generate Proofs

ðŸ’¸ Generate Fee
Single-Transition + Proof

ðŸ“¦ Execute Transaction
Assembly

âœï¸ Sign Authorization
and Fee

ðŸ¤ Authorization Only
No Fee Signature

ðŸ” Trustless Delegation
Execution Proving

ðŸ’° Who Pays Fee?

âœ… Return Proofs
User Fee Applied

âœ… Return Proofs
Prover Fee Applied

ðŸ“¡ Broadcast to Validators

â³ Mempool
Unconfirmed Transaction

âœ…âŒðŸš«
Decision

âœ… Add to Block
ConfirmedTransaction::Accepted

ðŸ’¸ Add Fees to Block
ConfirmedTransaction::Rejected

ðŸš« Transaction Aborted
No Block Inclusion

ðŸ”„ Finalize
State Updates

ðŸ¤ Consensus Check
AleoBFT

âœ… Commit Block
Once Quorum Reached

Determining Transaction Status
Transactions processed by Aleo validators achieve one of the following states:

Status	Description
accepted	The underlying deployment or execution was successful, and the associated fee was consumed. The transaction has a confirmed ID.
rejected	The deployment or execution logic failed. Validators process the fee as an independent fee transaction. The original transaction has an unconfirmed ID, while the fee transaction has a confirmed ID.
aborted	Both the deployment/execution logic and fee processing failed. The transaction is aborted.
note
Transactions may not be included in any block when not selected from the mempool by validators during high network load conditions.

Method 1: Parsing Transactions from Blocks
Transaction status can be determined by processing blocks retrieved via:

GET /<network>/block/{height} - snarkOS node endpoint
Get block by height or hash on the Provable explorer
Transaction status can be determined from a block response as follows:

Accepted Transactions
Get the list of transactions using echo response | jq .transactions
The transaction JSON contains "status": "accepted"
The transaction id is present in echo transaction | jq .transaction.id
Rejected Transactions
Get the list of transactions using echo response | jq .transactions
The transaction JSON contains "status": "rejected"
The confirmed transaction id is present in echo transaction | jq .transaction.id
The associated unconfirmed transaction id can be acquired by:
Calling GET /<network>/unconfirmed/{confirmed id} and calling echo transaction | jq .transaction.id
You can also hit https://api.explorer.provable.com/v1/mainnet/transaction/unconfirmed/{ID}
Aborted Transactions
Get the list of aborted ids using echo response | jq .aborted_transaction_ids
SDK - getConfirmedTransaction
import { AleoNetworkClient } from '@provablehq/sdk/mainnet.js';

const net  = new AleoNetworkClient('https://api.explorer.provable.com/v1');   
const txId = 'at14v8nt94d7xmsp3dq2glpzft6xw3x42ne753mlt8uenn8zw76dsqqc65jnf';                                

const status = await net.getConfirmedTransaction(txId);
console.log(status.status);


Method 2: Directly Querying Transaction Status
An alternative way to get feedback on the status of transactions, is to call the following endpoint.

GET /<network>/transaction/confirmed/{transaction id} on a fully synced snarkOS node REST endpoint
Get transaction by ID on the Provable explorer
If the transaction was accepted, echo $transaction | jq .type will say "execute"
If the transaction was rejected, echo $transaction | jq .type will say "fee"

note
Currently no API endpoint is available to quickly check whether a transaction was aborted.

Given a confirmed transaction id, you can find the block it was included in using:

GET /<network>/find/blockHash//{transaction id} on a fully synced snarkOS node REST endpoint
Get block hash for transaction ID on the Provable explorer
SDK - fetchData and getBlockByHash
import { AleoNetworkClient } from '@provablehq/sdk/mainnet.js';

const net  = new AleoNetworkClient('https://api.explorer.provable.com/v1');   
const txId = 'at14v8nt94d7xmsp3dq2glpzft6xw3x42ne753mlt8uenn8zw76dsqqc65jnf'; 
// Get block hash using fetchData
const res = await net.fetchData('/find/blockHash/' + txId);   
// Get block by using getBlockByHash 
const block = await net.getBlockByHash(res)
// Get block height by response json
console.log(block.header.metadata.height);


Parsing the Sender Address from transfer_public or transfer_public_as_signer Executions
Note that the sender address might be an externally owned account (EOA), i.e. owned by a user, or it might be the address of an Aleo program.

The sender address of a Transaction is present as the first argument of the first output. The following will return a human readable string containing the public values of the first output.

echo $transaction | jq '.execution.transitions[0].outputs[0].value'


Unfortunately, the current snarkOS and explorer REST endpoints return execution outputs as a string which is not compatible with JSON. You'll still need to extract the first value from it. The sender address can be parsed for example using a regex or by parsing out the 5th line:

echo $(echo $transaction | jq '.execution.transitions[0].outputs[0].value') | sed -n '5p'


Summarized Block Contents
A block contains confirmed transactions.

A confirmed transaction can either have status "accepted" or "rejected", and type "deploy" or "execute", and it contains a "transaction" and optional "rejected" object.

A "transaction" can have type "fee", "execute" or "deploy".
A "rejected" can have type "execution" or "deployment".
{
  â€¦,
  "transactions": [
    "status": "accepted"/"rejected"
    "type": "deploy"/"execute",
    "transaction": {
      â€¦,
      "type": "fee"/"execute"/"deploy"
    }
 "rejected": {
      â€¦,
      "type": "execution"/"deployment"
    } 
  ],
  "unconfirmed_transaction_ids": [...]
}


Transaction Fees
A transaction fee is a fee that is required in order to process a transaction on the Aleo network. Below, we describe the way in which Deploy and Execute transactions are priced. At the time of writing, puzzle solutions are free.

Aleo Credits Denomination Table
Denomination	Size of Transaction	Value	Example
microcredit	Byte	1	Smallest denomination
millicredit	Kilobyte (KB)	1000 microcredits	Most transactions average between 3 and 10 millicredits
credit	Megabyte (MB)	1000 millicredits	Largest denomination
Types of Transaction Fees
Deployment Base Fee
This is what you pay for deploying a program to the Aleo network. Deployment fees consist of the following parts:

Storage Cost: Determined by the amount of raw bytes of your program. The cost is calculated as size_in_bytes Ã— DEPLOYMENT_FEE_MULTIPLIER, where DEPLOYMENT_FEE_MULTIPLIER is currently 1 millicredit per byte.
Namespace Cost: The smaller your program name, the more you pay. There is no namespace cost if your program name is 10 characters or longer.
Synthesis Cost: To process your program into a circuit for zero knowledge proofs. The cost is based on the number of variables and constraints: (num_variables + num_constraints).
Constructor Cost: The operations performed in the program's constructor are also accounted for in the deployment fee. The constructor currently has a 100Ã— fee multiplier compared to the finalize cost.
Execution Base Fee
This is what you pay for executing program functions on the Aleo network.

Execution Cost: Determined by the amount of raw bytes of your execution transaction. For transactions smaller than 5,000 bytes (5 KB), the cost is linear: size_in_bytes. For larger transactions, a quadratic penalty applies: size_in_bytesÂ² / 5000. This quadratic formula discourages excessively large transactions.
Finalize Cost: Based on the operations performed in your function's finalize scope. Each operation has a specific cost in microcredits, including:
Mapping operations (get, set, remove, contains)
Hash operations (different costs for different hash functions)
Cryptographic operations (ECDSA verification, etc.)
Arithmetic and logical operations
These per-operation costs vary depending on the consensus fee version.
Proof Verification: There is minimal execution cost for proof verification, as verifying zero knowledge proofs is computationally cheap. The expected proof size is included in the cost calculation.
Priority Fee
Priority fees are optional fees that allow users to bid for higher transaction priority in the mempool. With the approval of ARC-0005, priority fees are now supported and effectively created a fee market for transaction ordering.

The network maintains a priority queue for transactions that include a nonzero priority fee. This priority queue is processed before the standard transaction queue when sending transactions to the BFT consensus layer.

notes on current design
Priority fees for transactions already in the mempool cannot be updated.
There is no protection against starvation: if the priority pool stays full enough, transmissions from the standard queue will not be sent to the BFT.
Batch building is not atomic w.r.t. the memory pool.
Estimating Fees
The fee determination logic is defined in a file called cost.rs. There are multiple ways to estimate fees for your transactions:

Using the SDK
You can use the SDK's ProgramManager to estimate fees programmatically:

estimateExecutionFee - Estimate the execution fee for an Aleo function
estimateFeeForAuthorization - Estimate the fee for an authorization
Using Leo CLI
You can also use Leo CLI to estimate the fees for your transaction. Example as below:

First, generate a example program using leo example.

leo example lottery
cd lottery

Then use leo deploy to estimate the deployment fees for your transaction.

leo deploy --network testnet --endpoint https://api.explorer.provable.com/v1


Or use leo execute to estimate the execution fees for your transaction.

leo execute main 1u32 2u32 --endpoint https://api.explorer.provable.com/v1 --network testnet 


This method works without needing to fund the private key and will look something like below:
Deployment

ðŸ“Š Deployment Summary for helloworld.aleo
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Total Variables:      16,995
  Total Constraints:    12,927
  Max Variables:        2,097,152
  Max Constraints:      2,097,152

ðŸ’° Cost Breakdown (credits)
  Transaction Storage:  0.879000
  Program Synthesis:    0.029922
  Namespace:            1.000000
  Constructor:          0.002000
  Priority Fee:         0.000000
  Total Fee:            1.910922
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Execution

ðŸ“Š Execution Summary for helloworld.aleo
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ’° Cost Breakdown (credits)
  Transaction Storage:  0.001321
  Onâ€‘chain Execution:   0.000000
  Priority Fee:         0.000000
  Total Fee:            0.001321
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Fees Visibility
On Aleo, each transaction contains a dedicated fee transition. The fee may be provided by the sender or by a sponsor, and it can be paid either publicly or privately. The fee amounts themselves (base and optional priority) are always public, what differs is the onâ€‘ledger visibility of the payer.

Public fee payment
Paid from a public account. The payerâ€™s address and the total fee (base + priority) are visible on the ledger. The payer publicly signs the fee transition, and the amount is deducted from their public balance during finalize.

important
For public fees, the payerâ€™s public account must have sufficient balance at verification time.

Private fee payment
Paid from a private credits.record. The payerâ€™s address is not revealed, a private change record is produced. Only the fee amounts and a public link to the target transaction are disclosed. To keep a private transaction fully private, the fee should be paid privately.

Fee Sponsorship
A separate party can provide the fee via an independent fee authorization that is combined with the senderâ€™s execution authorization. Sponsors may pay publicly or privately. For maximum sender privacy a privateâ€‘sponsored fee is preferred, public sponsorship links the sponsorâ€™s address to the target transaction ID.

note
Every fee transition carries a public field binding it to a specific deployment or execution ID, ensuring the fee is verifiably associated with the intended transaction.

special case
All transactions require a base fee, except the transaction that contains only a single call to credits.aleo/split or credits.aleo/upgrade may omit the base fee (a priority fee may still be included). Any multiâ€‘transition transaction requires a fee.

Transitions
A transition represents a private and optional public state transition, which Aleo validators process to change state (e.g. to transfer private or public tokens to an Aleo address).

Components of a Transition
An Aleo transition is serialized in the following format:

Parameter	Type	Description
id	finite field element	The transition id, which is computed via the Merkle tree digest formed from the Input and Output IDs
program_id	string	The program ID, which is associated with a verification key on a globally maintained map on the ledger.
function_name	string	The function name, which is used to compute a function_id using the program_id.
inputs	array of Inputs	The transition Inputs, which can be a constant, public, private, or inputRecord
outputs	array of Outputs	The transition Outputs, which can be a constant, public, private, outputRecord or Future
tpk	group element	The transition public key, equivalent to r * G
tcm	finite field element	The transition commitment, hash of transition view key (tvk)
scm	finite field element	Signer commitment, hash of the owner address and root transition view key (root_tvk)
Transition Public Key (TPK)
The transition public key (tpk) is computed as part of the transition key generation process:

Sample Random Nonce: A random nonce is generated as a field element

Compute Transition Secret Key (r): The transition secret key r is computed as:

r = HashToScalar(serial_number_domain || sk_sig || nonce)


Where sk_sig is the signature secret key from the account's private key and || denotes concatenation

Compute Transition Public Key: The tpk is computed as:

tpk = r * G

Where G is the generator point

The tpk is equivalent to r * G and serves as the random nonce used to verify the digital signature provided by the owner in a transaction.

Transition View Key (TVK)
The transition view key (tvk) is computed after the transition public key generation:

Compute Transition View Key: The tvk is computed as:

tvk = (signer_address * r).to_x_coordinate()

Where the result is converted to its x-coordinate as a field element

The tvk is used in the encryption process for private inputs and outputs.

Transition Commitment (TCM)
The transition commitment (tcm) is computed as:

tcm = Hash(tvk)

Where tvk is the transition view key computed in the previous step. This commitment provides a cryptographic binding to the transition view key while maintaining privacy.

Signer Commitment (SCM)
The signer commitment (scm) is computed as:

scm = Hash(signer.to_x_coordinate() || root_tvk)

Where:

signer.to_x_coordinate() is the x-coordinate of the signer's address
root_tvk is the root transition view key when multiple circuits are involved
The commitment binds the signer's identity to the root transition view key
The signer commitment serves as a cryptographic proof that links the transition to its creator while preserving privacy properties.

Record
Input Record
An inputRecord consists of a record_commitment, gamma, record_view_key, serial_number, and a tag. When a record is used as input to a transition, it is computed to its serial number through the following process:

Record View Key Computation: The record view key is computed as (record.nonce * view_key).to_x_coordinate(). nonce is computed from randomizer * G where randomizer = Hash(tvk || index).

Record Commitment: There are currently two versions of record commitment:

Version 0: Hash of (program_id || record_name || record) without the last 8 version bits
Version 1: Take the Version 0 hash, append with version bits, then:
Construct commitment nonce: Hash(commitment_domain || record_view_key)
Compute the record commitment using the above nonce
note
Version 0 records from credits.aleo are required to upgrade by calling the upgrade() function.

Generator H Computation: A generator H is computed as HashToGroup(serial_number_domain || commitment) using the Poseidon hash-to-group function with the serial number domain and commitment.

Gamma Calculation: gamma is calculated as sk_sig * H, where sk_sig is from the owner's private key, and h_r is computed as r * H for verification purposes.

Serial Number Derivation: The serial_number is computed by calling Record::serial_number_from_gamma(gamma, commitment), which:

First calculates sn_nonce as Hash(serial_number_domain || (COFACTOR * gamma).to_x_coordinate())
Then computes serial_number as Commit((serial_number_domain || commitment).to_bits_le(), sn_nonce)
Tag Calculation: The tag is computed as Record::tag(sk_tag, commitment), where sk_tag is derived from the graph key.

The serial number is disclosed on the ledger to publicly announce that the record has been spent, preventing double-spending while maintaining privacy. The tag is used to keep track of records that are spendable by the user.

Output Record
An outputRecord consists of a record_commitment, checksum, record_ciphertext, and sender_ciphertext. When a record is produced as output from a transition, it is computed through the following process:

Record Commitment: There are currently two versions of record commitment:

Version 0: Hash of (program_id || record_name || record) without the last 8 version bits
Version 1: Take the Version 0 hash, append with version bits, then:
Construct commitment nonce: Hash(commitment_domain || record_view_key)
Compute the record commitment using the above nonce
Record Encryption Randomizer: The encryption randomizer for the record data is computed as Hash(tvk || index), where tvk is the transition view key and index is the field element representation of the output register locator.

Record View Key Generation: The record view key is computed as (owner_address * randomizer).to_x_coordinate(), where owner_address is the record owner's address and randomizer is from step 2.

Record Encryption: The record_ciphertext is computed by:

Generating multiple randomizers using Hash(encryption_domain || record_view_key) based on the number of field elements needed
Encrypting each private field element by adding the corresponding randomizer: encrypted_field[i] = plaintext_field[i] + randomizer[i]
Constant and public entries remain unencrypted
Checksum Calculation: The checksum is computed as a hash of the record_ciphertext converted to little-endian bits and is used to verify the integrity of the encrypted record.

Sender Ciphertext: The sender_ciphertext is computed using a different randomizer distinct from the record encryption randomizer:

Sender Ciphertext Randomizer: Computed as Hash(encryption_domain || record_view_key || 1)
Encrypting the signer's address x-coordinate: sender_ciphertext = signer_address.to_x_coordinate() + randomizer
Record checksum and commitment are publicly visible on the ledger, while the record ciphertext contains the encrypted record data that can only be decrypted by the record owner. The sender ciphertext provides an encrypted reference to the transaction signer while maintaining privacy.

info
In the latest record version, commitments appear random even for similar records, making it difficult to associate them with specific data. The use of a view key ensures that only the record owner can correlate commitments with the actual data, offering enhanced privacy against traffic analysis and pattern matching.

Non-Record Ciphertext
Non-record ciphertext are encrypted data that hides private information on Aleo network and used to protect private inputs and outputs. Records can only be decrypted by the owner's view key, while non-record plaintext ciphertext can be decrypted using a plaintext view key derived from the function caller's view key.

Encryption
1: Create a Plaintext View Key
The plaintext view key is computed as Hash(function_id || tvk || index)
Where:
function_id is the unique identifier of the function being executed
tvk is the transition view key from the request
index is the field element representation of:
For inputs: the input index (cast from u16)
For outputs: (num_inputs + output_index)
Each private input and output gets its own unique plaintext view key
2: Generate Randomizers
Determine the number of randomizers needed based on the plaintext structure
Generate randomizers using Hash(encryption_domain || plaintext_view_key) with num_randomizers as number of outputs
One randomizer is created for each field element in the plaintext
3: Encrypt the Plaintext
Convert the plaintext to field elements
Add each randomizer to the corresponding field element:
encrypted_field[i] = plaintext_field[i] + randomizer[i]
Create the ciphertext from the encrypted field elements
4: Compute Ciphertext Hash
Convert the ciphertext to field elements
Compute the ciphertext hash as Hash(ciphertext_fields)
This hash serves as the output ID for verification
Decryption
1: Recreate the Plaintext View Key
Use the same method as encryption
Compute plaintext_view_key = (tpk * view_key).to_x_coordinate()
Where tpk is the transition public key (r * G) and view_key is the account view key
This works because the signer address is basically a scalar multiplication of view_key on generator G
2: Regenerate the Same Randomizers
Determine the number of randomizers needed (same as encryption)
Use the same hash function: Hash(encryption_domain || plaintext_view_key) with num_randomizers as number of outputs
3: Decrypt the Ciphertext
Subtract each randomizer from the corresponding encrypted field element:
plaintext_field[i] = encrypted_field[i] - randomizer[i]
Reconstruct the original plaintext from the decrypted field elements


Blocks
A block is a fundamental data structure for organizing Aleo transactions over time.

Components of a Block
An Aleo block is serialized in the following format:

Parameter	Type	Description
block_hash	string	The hash of the block
previous_hash	string	The hash of the previous block
header	object	The header of the block
transactions	array	The transactions in the block
ratificactions	array	The ratifications for proving rewards in the block
coinbase	string	The coinbase puzzle solution constructed by accumulating the individual prover solutions.
signature	string	The signature for the block
Transactions
The transactions are a list of all transactions that are included in the specified block.

Block Header
The block header contains components that summarize the state of the specified block, as well as the state of the ledger at this point in history. See the components of a block header for more details.

Components of a Block Header
An Aleo block header is serialized in the following format:

Parameter	Type	Description
previous_state_root	string	The Merkle root representing the blocks in the ledger up to the previous block.
transactions_root	string	The Merkle root representing the transactions in the block.
finalize_root	string	The Merkle root representing the on-chain finalize including the current block.
ratifications_root	string	The Merkle root representing the ratifications in the block.
coinbase_accumulator_point	string	The accumulator point of the coinbase puzzle.
metadata	object	The metadata of the block.
Metadata
Parameter	Type	Description
network	u16	The network ID of the block
round	u64	The round that produced this block - 8 bytes
height	u32	The height of this block - 4 bytes
total_supply_in_microcredits	u64	The total supply of microcredits - 8 bytes
cumulative_weight	u128	The cumulative weight for this block - 16 bytes
cumulative_proof_weight	u128	The cumulative proof target for this block - 16 bytes
coinbase_target	u64	The coinbase target for this block - 8 bytes
proof_target	u64	The proof target for this block - 8 bytes
last_coinbase_target	u64	The coinbase target for the last coinbase - 8 bytes
last_coinbase_timestamp	u64	The Unix timestamp (UTC) for the last coinbase - 8 bytes
timestamp	i64	The Unix timestamp (UTC) for this block - 8 bytes


Public vs. Private State
Introduction
The concept of Zero Knowledge proofs was first introduced in 1985 in the paper The Knowledge Complexity of Interactive Proof Systems. However, it is only in recent years that the groundbreaking technology has been feasible to be applicable to blockchains.

Zcash was one of the earliest chains to utilize the power of zero knowledge proofs to provide privacy to an account's balance. Unlike traditional cryptocurrencies like Bitcoin, where transaction details are publicly visible on the blockchain, Zcash enables users to shield their transactions, rendering them completely opaque to outside observers. It utilizes zk-SNARKs (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge), a type of zero-knowledge proof system that allows parties to verify the validity of a computation without revealing the underlying data.

In even more recent times, we have seen several Ethereum virtual machine-compatible Layer-2 chains that have employed zero-knowledge cryptography techniques to solve Ethereum's scalability issues. They use zk-rollups, which compute multiple state changes off-chain, followed by posting the summary of those transactions and proofs on-chain. This helps to reduce transaction fees significantly. However, all of them utilize zero-knowledge technology mainly for scalability reasons.

Aleo is a new layer-1 blockchain that combines general-purpose programmability with privacy by default. Unlike the other chains, Aleo is one of the first blockchains to utilize zero-knowledge for both privacy and scalability.

Privacy
There are generally four different types of privacy that relate to blockchains, of which Aleo fulfils three:

 Private inputs (messages)
 Private outputs (state changes)
 Private user
 Private function
The core belief at Aleo is that privacy is necessary in order for blockchains to have mainstream adoption. For instance, how many of us would be comfortable revealing our bank account numbers if anyone in public were able to trace all the transactions we have ever made?

Aleo State Storage
In order to have privacy native to a chain, Aleo uses a record model for application state storage, which is similar to the UTXO model in Bitcoin. However, Aleo provides developers the option to make application states public should they choose to do so. Public states are stored using the account model as done in Ethereum.

Storing Private States via Record
Records are a fundamental data structure that can contain any arbitrary payload and are used for encoding user assets or application states. A record represents a certain state of a program in the global state, for example, the balance of an account or your identity document.

An Aleo record is serialized in the following format:

Parameter	Type	Description
owner	address	The address public key of the owner of the program record
data	map	A data payload containing arbitrary application-dependent information
nonce	group	The serial number nonce of the program record
Records are tied to programs deployed on Aleo, and only the owner has permissions to alter the state of the record.

Records are private by default and are stored as ciphertext on-chain. For more information on how Records are encrypted, please refer to the Output Record.

Storing Public State via Mapping
A public state in Aleo is stored in the form of a mapping, which are key-value pairs. Anyone is able to query the state of the mapping by querying the Aleo blockchain explorer.

Switching Between Privacy States
By supporting both private and public storage states, an interesting feature emerges in Aleo where states can be converted from private to public and vice versa.

An example of such a use case would be in a poker game. The state of the shuffled deck after dealing the cards to players should be kept private initially. Proceeding, as the "flop" reveals the top 3 cards, the state of those cards should be revealed to the public.

View Key
Aleo has a unique feature known as a view key for each account. The view key allows one to decrypt all transactions of it's account. It is different from the private key in that it does not provide the permission to spend the records.

Private Inputs and Outputs of Programs
Apart from stored program states being private, the program function inputs and outputs can also be made private or public. The following shows an example of an Aleo program which adds two input numbers and stores the result into a record known as 'sum'. The developer has the choice to specify if the input of a program transition function should be public or private. The individual record fields can also be made public or private via the 'public' modifier. As Aleo is private by default, the fields are considered as private if the modifier is not specified.

program sum.aleo {
    record sum {
        public owner: address,
        amount: u64,
    }

    transition main(public a: u64, b: u64) -> sum {
        let c: u64 = a + b;
        return sum {
            owner: self.caller,
            amount: c,
        };
    }
}

More information on how private inputs and outputs are encrypted, please refer to here.

Public vs. Private States
The choice to store an application state as public or private should depend on the particular use case of the program. Instead of being a chain that is completely private or completely public, Aleo believes in a hybrid approach that offers developers a choice.

Aleo's model is more suitable for real-world applications, which often rely on a combination of public and private information.

A practical example for this is voting. As stated by the Aleo founder, Howard Wu, "In elections, people want to vote, but they donâ€™t want to show other people how they voted. The tally of the votes needs to be public to understand the outcome. Having private votes and public tallies ends up being a capable functionality in applications here."

Conclusion
Aleo is one of the very first few layer-1 blockchains that emphasizes programmable privacy. Developers are able to choose if they wish to make certain states of their program public or private. This opens up a whole new set of interesting applications that cannot be built easily with other blockchains. This is certainly an exciting chain to keep an eye out for.


Async Programming Model
The finalize model was introduced to naturally enable a novel hybrid programming model, where the first part of a program is executed off-chain and the second part is executed on-chain. However, this model had its shortcomings, mainly that it was not possible define the ordering in which code was finalized.

For example, suppose we have a function A first calls B and then calls C. The finalization order would be the order in which the off-chain components of the function finished, e.g B, C, A.

To enable more expressive programs, the finalize model was deprecated in favor of the async/await model. This model borrows heavily from asynchronous programming models in other programming languages, but has some restrictions that are specific to the Aleo blockchain. Users familiar with asynchronous programming should find its instantiation in Leo familiar.

More information about async/await model can be found here.

At a high-level, on-chain code is asynchronous code that does not return a value. Instead it returns a Future. Futures can be composed to execute simply one after another or through complex control flow.

The rules in the async/await model are:

Async functions can only be called from an async transition.
Async functions cannot return values.
Async transitions cannot be called inside a conditional block.
An async function call, returns a Future, which is code to be executed later.
An async transition call, returns an optional value, and must return a single Future, which is code to be executed later.
A Future produced by an async transition call cannot be returned.
A Future can be passed into an async function call and must be awaited.
All Futures must either be consumed by an async function call or returned as an output.

Intro to zkSNARK
In this section we cover the general intuition of a zk proof, we outline the steps in creating a zksnark, we define the actors in a zk proof mainly the prover and verifier. We also introduce the elements in a zkproof like the witness, intermediate representation, trusted setups, structured reference strings and random oracles. We also give the context of where the zksnark proof is used in Aleo.

Introduction
In traditional proof systems, like those we encounter in high school, we provide evidence to a verifier to demonstrate our possession of certain information. However, this typically involves divulging that information to the verifier, which can be a security concern. In contrast, Zero-Knowledge (ZK) proofs address this issue by ensuring that neither party trusts the other entirely. The verifier doesn't trust the prover to possess the information, and the prover doesn't trust the verifier to keep it confidential. This might seem like an insurmountable challenge, but through the realms of mathematics and cryptography, solutions have emerged. Enter zkSNARKsâ€”short for Zero-Knowledge Succinct Non-Interactive Argument of Knowledgeâ€”a cryptographic marvel that allows one to prove possession of specific information without actually disclosing that information itself.

Let us break down these words:
Zero-Knowledge: In a zero-knowledge scenario, neither the prover nor the verifier gains any new information beyond what they're supposed to know. Essentially, the verifier gains confidence that the prover possesses the claimed information, while the prover demonstrates their knowledge without disclosing the specifics.
Succinct: The proof generated by the prover is compact, making it easily distributable across a network and requiring minimal computational resources for verification.
Non-Interactive: The process of proof and verification involves minimal back-and-forth between the prover and verifier, streamlining the interaction to ensure efficiency.
But how do they work?
In the realm of blockchains, zkSNARKs serve dual roles: enhancing scalability and bolstering privacy. To break it down, zkSNARKs operate as proof systems between a prover (let's call her Alice) and one or more verifiers (let's name them Bob). These systems come into play in the following scenarios:

The prover holds sensitive information but seeks to convince the verifier of its possession without divulging the specifics. For instance, imagine proving that a user meets the legal age requirement (above 18 years) without disclosing the exact age.
In another scenario, the prover might be a supercomputer whose services the verifier requires. However, since the verifier can't entirely trust the prover, they need assurance that the computation was carried out faithfully and hasn't been tampered with. This use case is critical for scalability and ensuring computational integrity. For example, in a ZK Roll-ups (Layer 2), zkSNARKs are utilized to demonstrate to the layer 1 (predominantly Ethereum) chain that transactions have been executed accurately since the previous roll-up.
To formulate these scenarios as ZK proofs we follow a few steps:

We begin by crafting code that represents the statement under scrutiny. In the initial example scenario above, this code might accept an input (such as age), perform a comparison to determine if it exceeds 18, and subsequently yield a true or false outcome. In the second instance, the code could resemble that of a sequencer. This sequencer would receive the present state of an L2 system, arrange incoming transactions, execute them in a specified sequence, and furnish the resulting state.

The next step is to convert this code into a polynomial represented as its linear factors and the quotient polynomial. The Scientific community has established a mathematical way to convert any program into a polynomial of this form. We shall explain this process as used in Aleo in an example later in the docs. In essence, the steps followed for this process are

Flattening - conversion of code to logic gate representation.
R1CS - converting the flattened form into a Rank 1 constraint system. The idea is every logic gate represents a single constraint that must be correct for the final result to be correct. The output at each logic gate forms the witness. [PLONK and AIR are other intermidiate arthimetic representations commonly used]
QAP - Quadratic arthimetic Programs that can convert all the constraint drawn by R1CS into a single constraint and makes verification of a zk proof much simpler
The witness refers to the additional information provided by the prover alongside the proof. This information serves as evidence to validate the truthfulness of the statement being proven. It acts as the supporting evidence that enables the verifier to confirm the accuracy of the proof without needing to know the underlying details.

For a ZKSnark the prover and verifier must engage in a trusted set-up which is where the prover commits to an evaluation of the polynomial created for a value chosen by the set of verifiers. This ensures that the prover uses the correct polynomial and cannot cheat.

Now we are ready to perform the actual proof exchange and verification. But all zk proof system are probablistic which means the verifier's confidence in the prover increases proportionally to the number of satisfactory verifications. To make this exchange with as much minimal interactions as possible we take the help of Interactive Random Oracles that facilitate the communication between the prover and verifier in one go and establishes negligible probability of a tampered proof. [Some proof system also use commitment scheme like KZG]

In the upcoming sections, we'll delve into the protocol implemented by Aleo that ensures complete privacy. However, before we explore that, it's important to understand how zero-knowledge proofs (zkps) contribute to Aleo's privacy measures.

Aleo operates as a fully private blockchain, where the entirety of a user's account state remains confidential, known solely to the user and inaccessible to anyone else on the chain (to those who dont know the user's view key). Despite this, users need to conduct transactions on the blockchain and transition to new states that gain network consensus. To achieve this, Aleo treats every piece of sensitive user data, requiring consensus, as a "Record". With each user transaction, the input record(s) are invalidated, and new private record(s) representing the updated state are generated. For every transaction, a zk proof is created to ensure the accurate execution of new record creation. These new records are encrypted and stored on the chain alongside proofs of their creation, maintaining their privacy while allowing network validation through proof verification.

Aleo Virtual Machine (AVM)
The Aleo Virtual Machine (AVM) is a computational platform integral to the Aleo blockchain, designed to run privacy-focused applications. It operates as a stack machine that executes queued instructions. Its primary function is to construct arithmetic circuits described as Rank-1 Constraint System (R1CS), from each instruction in a function.

After constructing the R1CS, corresponding proofs are generated using a variation of Marlin algorithm called Varuna. This approach allows for succinct verification of arbitrary computations by leveraging a universal and updatable Structured Reference String (SRS).

It was formalised and implemented in the Aleo Network as ARC-0002.

Key Features of the AVM
Privacy Preservation: The AVM executes transactions and contracts while maintaining the confidentiality of the data involved. This is done using zk-SNARKs, which allow the verification of the correctness of computations without revealing the inputs or internal state.
Deterministic Execution: Like other blockchain virtual machines, the AVM ensures that contract execution is deterministic, meaning it produces the same output given the same initial state and inputs across all nodes.
Scalability: The use of zk-SNARKs also aids scalability. Since the computational load of verifying a zero-knowledge proof is less than repeatedly executing the computation, the AVM can handle more complex operations at a larger scale compared to traditional systems.
AVMâ€™s Architecture and Design
The AVM is virtual machine that operates on a last-in, first-out (LIFO) principle where data is stacked and the most recently added data is the first to be accessed or removed. This design is conducive to the execution of complex arithmetic circuits that are essential for the privacy-preserving features of Aleo. The AVM's architecture is designed to support the execution of private applications by leveraging zero-knowledge proofs. It uses Leo (high-level programming language), which compiles down into an intermediate representation known as AVM opcodes. These opcodes are then used to construct the R1CS, which are essential for generating zero-knowledge proofs. Check the full list here

The AVM architecture can be broken down into several key components and characteristics:

Instruction Set Architecture (ISA)
The Instruction Set Architecture of the AVM is custom-designed to support operations required for zero-knowledge proofs, especially zk-SNARKs. This set of instructions is optimized to handle complex mathematical operations efficiently, such as those involving elliptic curves, which are crucial for creating and verifying zero-knowledge proofs.

Execution Environment
The execution environment of the AVM provides the runtime in which smart contracts are executed. This environment is tightly controlled and deterministic, meaning that given the same initial state and inputs, the execution will always produce the same output. This determinism is essential for maintaining consensus across the blockchain network.

Memory Management
AVM features a structured memory model to manage both transient and persistent data:

Stack: Used for temporary storage during the execution of instructions. This is typically where variables, temporary results, and stack frames (context for function calls) are stored.
Heap: For dynamic allocation of memory during execution, supporting more complex data structures necessary for advanced contract functionality.
Storage: This refers to the persistent state of contracts on the blockchain. Unlike stack and heap, storage data persists between transactions and is part of the blockchain's state.
State Transition System
The state transition system in the AVM defines how the state of the blockchain changes in response to transactions:

Transactions: These are submitted by users and can include smart contract interactions or simple transfers. They change the state of the blockchain.
State Transitions: Each transaction processed by the AVM results in a state transition, updating the blockchain's global state according to predefined rules.
Privacy Enforcement: During state transitions, the AVM ensures that all operations uphold the privacy guarantees promised by zero-knowledge proofs. This means sensitive data remains encrypted, and only the validity of transactions is verified.
A Merkle tree is used to represent the global state. One of the biggest challenges is to also include encrypted information in this global state.

The transaction data is not stored directly but through encrypted transitions.

AVS Global State Source: trapdoortech.com

Smart Contract Compilation and Deployment
Leo Programming Language: Smart contracts are written in Leo, a Domain Specific Language (DSL) designed for expressing the semantics of Aleo and zero-knowledge. Leo code is compiled into AVM bytecode.
Bytecode Execution: The compiled bytecode is what the AVM directly executes. This bytecode is optimized for the AVM's execution environment, ensuring efficient processing and privacy preservation.
Networking and Consensus Layer Integration
Although not a direct part of the AVM, the virtual machine operates within the broader context of Aleo's network architecture:

Block Propagation and Validation: The AVM's execution outcomes influence block validation and propagation across the network.
Consensus Mechanism: The AVM interfaces with the blockchain's consensus mechanism by providing guarantees about the correctness of executed transactions through zero-knowledge proofs, thus facilitating a secure and verifiable agreement on the state of the ledger.
AVM Execution Flow

Execution Flow
Compilation: Developers write their contracts in Leo, which compiles into AVM bytecode.
Deployment: Bytecode is deployed to the Aleo network, where it is executed by the AVM.
Execution: When a contract is called, the AVM processes the bytecode, leveraging zk-SNARKs to maintain privacy. The outputs verify that the contract executed correctly without revealing any sensitive information.
Aleo Account Keys
An Aleo account is similar to accounts on other blockchain platforms but designed with a focus on privacy, leveraging cryptographic techniques unique to the platform. Here's a detailed breakdown of the components of an Aleo account and the processes involved in generating addresses, public keys, and private keys:

Account Structure
Private Key: This is the secret key that an account holder must protect. It is used to sign transactions and prove ownership of the account. In Aleo, the private key is typically a large random number.
Public Key: Derived from the private key using cryptographic algorithms, the public key is used to receive transactions. It is safe to share publicly as it does not expose the private key.
Address: The address is a user-friendly representation of the public key. It is what other users will use to send Aleo to your account. The address is usually derived from the public key through a series of cryptographic hash functions and encoding techniques, ensuring it is both unique and verifiable.
Key Generation
Aleo generates private and public keys using elliptic curve cryptography (ECC) through a process that involves several key components and cryptographic principles. The core of this process is based on the properties of elliptic curves and the discrete logarithm problem, which provides the security foundation for the cryptographic operations. Here's a detailed explanation of how Aleo leverages elliptic curve cryptography for generating private and public keys:

Private Key: generated as a random scalar from a finite field defined by the elliptic curve. This key must remain secret and secure.
View Key: derived by multiplying the private key with the base point (a predefined point on the curve). This operation in ECC is non-invertible, which means you cannot derive the private key from the view key.
Compute Key: similarly to the view key, itâ€™s derived from the private key. It can be used to delegate the execution of a transaction to a third party.
Address: derived from the compute key
Key Generation Flow Source: trapdoortech.com

Integration with Wallets and Applications
In practice, Aleo accounts are often managed through wallets, which automate many of the processes described above. Wallets provide user interfaces for generating keys, creating and signing transactions, and managing balances without needing deep technical knowledge of the underlying cryptographic processes.

R1CS
Aleo Virtual Machine leverages a type of intermediate representation for their circuits called â€œRank-1 Constrained Systemâ€ (R1CS). This format is used to express computations as a system of equations that can later be formally verified.

Definition and Structure of R1CS
R1CS is essentially a set of linear equations over a field, structured to represent computational problems. Each constraint in an R1CS is an equation of the form:

(
a
0
+
a
1
x
1
+
.
.
.
+
a
n
x
n
)
(
b
0
+
b
1
y
1
+
.
.
.
+
b
m
y
m
)
=
(
c
0
+
c
1
z
1
+
.
.
.
+
c
l
z
l
)
(a 
0
â€‹
 +a 
1
â€‹
 x 
1
â€‹
 +...+a 
n
â€‹
 x 
n
â€‹
 )(b 
0
â€‹
 +b 
1
â€‹
 y 
1
â€‹
 +...+b 
m
â€‹
 y 
m
â€‹
 )=(c 
0
â€‹
 +c 
1
â€‹
 z 
1
â€‹
 +...+c 
l
â€‹
 z 
l
â€‹
 )
Where 
x
i
,
y
j
,
z
k
x 
i
â€‹
 ,y 
j
â€‹
 ,z 
k
â€‹
  are variables and 
a
i
,
b
j
,
c
k
a 
i
â€‹
 ,b 
j
â€‹
 ,c 
k
â€‹
  are constant from the given field. These constraints are designed to ensure that if the variables satisfy the left side of the equations, they must also satisfy the right side. Check the Schwartz-Zippel Lemma more further details.

R1CS flow in the AVM
Circuit Generation
Leo programs are compiled into â€œAleo instructionsâ€: an assembly-like language that the AVM can understand.
Aleo Instructions are compiled into R1CS circuit representation.
R1CS circuits are exported and potentially deployed to the network.
Proof Generation
Once a program is represented as an R1CS, Aleo uses this representation to generate zero-knowledge proofs. These proofs allow a prover (the one executing the program) to convince a verifier (Aleoâ€™s verifier network of nodes) that they have correctly executed the logic included in the program without revealing the specific inputs or internal state of the computation.

Verification
The verifier, who receives only the proof and the public outputs (if any), checks the proof against the R1CS circuit to ensure that the computation was performed correctly. This verification process does not require the verifier to know the specific details of the computation, thus maintaining privacy.

Inclusion Proofs
Inclusion proofs are like a special handshake or password that gets you past verifier without revealing the actual element. In Aleo, inclusion proofs are like digital receipts that verify transactions without compromising users' privacy.

Inclusion proofs are a part of Merkle tree data structures, which are used in cryptographic systems to efficiently prove that a piece of data is part of a set of data. An inclusion proof, in this context, is a proof that a certain element is included in a set without revealing the entire set.

In SnarkVM function inclusion_proving_key() returns the proving key for inclusion circuit and inclusion_verifying_key() returns the verifying key for inclusion circuit. As the name implies, the inclusion proving key is used to prove that a certain element is included in a set, while the inclusion verifying key is used to verify that the proof is correct.

In Aleo, to execute a function, a user uses the synthesizer in a similar way as the deployment process. As such, the user will produce ð‘›+1 transition proofs if they wish to execute a function call that triggers ð‘› nested calls. The synthesizer is run with the actual values (as opposed to random values) for the inputs as well as the different registers in the circuits.

In addition to producing these proofs, a user also produces ð‘›+1 â€œinclusion proofsâ€. These inclusion proofs are used to prove that any record being used as input in the transition or function call indeed exists. Inclusion proofs prove that records exist either in some previous block that has been included in the blockchain, or in one of the previous transition outputs.

An inclusion proof also publicly outputs the serial numbers (also called a nullifier in ZCash-like systems) that uniquely identify the records without leaking any information about them. This way, records cannot be consumed more than once. (In addition, the network enforces that no serial number is seen twice within the same transaction.)

Note: All of these different proofs are eventually aggregated together into a single proof using Varunaâ€™s batching capabilities.

Overview
Edwards BLS12	BLS12-377
Curve Type	Twisted Edwards	Barreto-Lynn-Scott
Scalar Field Size	251 bits	253 bits
Base Field Size	253 bits	377 bits
G1 Compressed Size*	32 bytes	48 bytes
G2 Compressed Size*	N/A	96 bytes
* rounded to multiples of 8 bytes.

Keccak
The sponge construction Sponge[f, pad, r] is a function that takes a variable-length input and produces a fixed-length output (the hash value). The permutation f is a function that takes a fixed-length input and produces a fixed-length output, defined as f = Keccak-f[b], where b := 25 * 2^l is the width of the permutation, and l is the log width of the permutation. For our case, l = 6, thus b = 1600. The padding rule pad is a function that takes a variable-length input and produces a fixed-length output. In Keccak, pad is a multi-rate padding, defined as pad(M) = M || 0x01 || 0x00â€¦0x00 || 0x80, where M is the input data, and 0x01 || 0x00â€¦0x00 || 0x80 is the padding. In SHA-3, pad is a SHAKE, defined as pad(M) = M || 0x06 || 0x00â€¦0x00 || 0x80, where M is the input data, and 0x06 || 0x00â€¦0x00 || 0x80 is the padding. The bitrate r is the number of bits that are absorbed into the sponge state in each iteration of the absorbing phase. In addition, the capacity is defined as c := b - r.

Edwards BLS12
Scalar Field
Modulus
Integer Representation
2111115437357092606062206234695386632838870926408408195193685246394721360383


Hexadecimal Representation
04aad957a68b2955982d1347970dec005293a3afc43c8afeb95aee9ac33fd9ff


U64 Representation (Little-Endian)
[13356249993388743167, 5950279507993463550, 10965441865914903552, 336320092672043349]


Root of Unity
Integer Representation
319259817323897909850357899558356952867916286821886696195104543796545181129


Hexadecimal Representation
00b4b1d4c7e5e163b1af246173fdb411bdb82ac32901dcb9d289433ff2b7d5c9


U64 Representation (Little-Endian)
[15170730761708361161, 13670723686578117817, 12803492266614043665, 50861023252832611]


Base Field
Modulus
Integer Representation
8444461749428370424248824938781546531375899335154063827935233455917409239041


Hexadecimal Representation
12ab655e9a2ca55660b44d1e5c37b00159aa76fed00000010a11800000000001


U64 Representation (Little-Endian)
[725501752471715841, 6461107452199829505, 6968279316240510977, 1345280370688173398]


Root of Unity
Integer Representation
5928890464389279575069867463136436689218492512582288454256978381122364252082


Hexadecimal Representation
0d1ba211c5cc349cd7aacc7c597248269a14cda3ec99772b3c3d3ca739381fb2


U64 Representation (Little-Endian)
[4340692304772210610, 11102725085307959083, 15540458298643990566, 944526744080888988]


Edit this page
Last updated on Aug 11, 2025 by

BLS12-377
Scalar Field
Modulus
Integer Representation
8444461749428370424248824938781546531375899335154063827935233455917409239041


Hexadecimal Representation
12ab655e9a2ca55660b44d1e5c37b00159aa76fed00000010a11800000000001


U64 Representation (Little-Endian)
[725501752471715841, 6461107452199829505, 6968279316240510977, 1345280370688173398]


Root of Unity
Integer Representation
5928890464389279575069867463136436689218492512582288454256978381122364252082


Hexadecimal Representation
0d1ba211c5cc349cd7aacc7c597248269a14cda3ec99772b3c3d3ca739381fb2


U64 Representation (Little-Endian)
[4340692304772210610, 11102725085307959083, 15540458298643990566, 944526744080888988]


Base Field
Modulus
Integer Representation
258664426012969094010652733694893533536393512754914660539884262666720468348340822774968888139573360124440321458177


Hexadecimal Representation
01ae3a4617c510eac63b05c06ca1493b1a22d9f300f5138f1ef3622fba094800170b5d44300000008508c00000000001


U64 Representation (Little-Endian)
[9586122913090633729, 1660523435060625408, 2230234197602682880, 1883307231910630287, 14284016967150029115, 121098312706494698]


Root of Unity
Integer Representation
146552004846884389553264564610149105174701957497228680529098805315416492923550540437026734404078567406251254115855


Hexadecimal Representation
00f3c1414ef58c54f95564f4cbc1b61fee086c1fe367c33776da78169a7f3950f1bd15c3898dd1af1c104955744e6e0f


U64 Representation (Little-Endian)
[2022196864061697551, 17419102863309525423, 8564289679875062096, 17152078065055548215, 17966377291017729567, 68610905582439508]


Edit this page
Last updated on Aug 11, 2025 by zklimaleo

Core Architecture
Aleo is focused on permissionless private programmability, which means the ability for anyone to codify any logic onto the Aleo blockchain without asking for anyone's permission. This is achieved through two key components:

SnarkVM (AleoVM): The off-chain execution environment that serves as the virtual machine for Aleo. SnarkVM is essentially AleoVM, which allows for the execution of Aleo programs and generation of zero-knowledge proofs. By utilizing SnarkVM and encryption, anyone can execute logic in a privacy-preserving manner.

SnarkOS: The blockchain node client of Aleo, powered by AleoBFT consensus mechanism. SnarkOS implements the AleoBFT protocol, which ensures secure and efficient consensus among network participants.

Together, these components form a complementary system where SnarkVM handles zero-knowledge off-chain execution, while SnarkOS serves as the network client that verifies the correctness of these off-chain computations by validating the submitted zero-knowledge proofs (zk-SNARKs).

This architecture enables two key capabilities:

For users: The ability to maintain data privacy while interacting with decentralized applications (programs) on Aleo through off-chain computation and zero-knowledge proofs
For developers: The ability to create privacy-preserving decentralized applications using Leo programming language or Aleo instructions and deploy them to the network
For more detailed information on these components, check out specification section in reference, which covers SnarkVM and SnarkOS in depth.

Aleo Roadmap
Aleo is consistently improving its protocol to enhance privacy, scalability, and usability. The roadmap outlines key initiatives and projects that aim to strengthen the network's infrastructure, introduce new features, and optimize performance. By following the roadmap, developers and users can stay informed about upcoming releases and participate in the evolution of the Aleo ecosystem.

For the latest updates on Aleo's development progress and future milestones, visit the official Aleo Roadmap.

What makes Aleo permissionless, private and programmable ?
An overview of the Aleo network architecture will help contextualize the concepts introduced in the learn section.

overview

All these components at play in this diagram together give rise to permissionless programmable privacy.

Components
User
The User initiates private transactions by preparing inputs and generating zero-knowledge proofs (ZKPs) for their actions. Users can generate these proofs locally or delegate this task to a Third Party Prover for efficiency.

Proof Generation
This is the process where the user (or a third party) computes a zero-knowledge proof for a transaction. Proof generation can be performed:

Locally by the user using their own device.
Delegated to a Third Party Prover (such as a wallet provider), which can handle the computational workload on behalf of the user. This delegation is optional and does not compromise the privacy of the user's data, as authorization/signing is separate from proving.
Third Party Prover
A Third Party Prover is an external service that users can optionally delegate proof generation to. This entity receives the necessary data from the user, generates the proof, and returns it to the user for submission. This improves efficiency, especially for users with limited computational resources.

Client
The Client acts as the interface between the user and the Aleo network. It receives the proof and transaction data from the user (via RPC), and submits transactions to the network. The client also receives new blocks and data from the network, relaying relevant information back to the user.

Prover (Miner)
Provers (sometimes called "miners") are network participants who generate SNARK proofs for coinbase puzzles. Their primary role is to improve the efficiency of proof generation, which can lead to faster transaction confirmation times and a better user experience. Provers are not part of the consensus process; instead, they contribute computational resources to help solve cryptographic puzzles, submit solutions to validators, and earn coinbase rewards from doing so.

Validators
Validators are responsible for verifying the correctness of submitted zero-knowledge proofs and maintaining consensus using the AleoBFT protocol. Their responsibilities include:

Proof Verification: Checking the validity of the proofs attached to transactions.
Consensus: Participating in AleoBFT, a Byzantine Fault Tolerant protocol, to agree on the next block.
Ledger Storage: Recording verified transactions in the ledger as part of a new block.
There are multiple validators (Validator 1, Validator 2, ..., Validator n), and they coordinate to ensure the integrity and security of the network.

Ledger (Data Storage)
The Ledger is the blockchain's data storage layer. It stores all verified transactions and blocks, ensuring an immutable and publicly verifiable record of all activity on the network.

User flow of executing a Private Transaction
User prepares inputs.

Fetches program from Node.

Executes required function from fetched program locally using snarkvm.

Broadcasts the output proof result along with the inputs and outputs to a client node. In the cases of private execution, the inputs and outputs are encrypted.

Validator verifies proof and consensus is held.

If transaction is verified, then it is stored in the ledger in a new block.

Now the transaction is fully complete.

Aleo Network
aleo_network

In the Aleo blockchain ecosystem, the network architecture encompasses two distinct components: the consensus network and the peer-to-peer (P2P) network. Within this framework, there exist three fundamental node types: Validators, Provers, and Clients.

Validator
Validators are integral components of both the consensus and P2P networks. They typically operate on port 5000 for the consensus network and port 4130 for the P2P network. Validators establish connections with one another via port 5000 to establish a cohesive consensus network. It's noteworthy that Clients and Provers are restricted from accessing the consensus network.

The primary mandate of Validator nodes revolves around adhering to AleoBFT rules to facilitate the generation of new blocks.

Within the Aleo P2P Network, Clients and Provers engage in mutual connections through P2P mechanisms. Additionally, they establish connections with a predetermined set of Validator nodes to access the latest blocks from the consensus network.

Client
Clients serve a pivotal role in the ecosystem by synchronizing blocks generated by the consensus network and updating ledger accordingly. Through Client's RPC, users gain access to real-time ledger state of the Aleo network and can broadcast transactions to the network. The inclusion of transactions in new blocks signifies their successful execution within the network.

Prover
Prover nodes undertake the responsibility of synchronizing CoinbasePuzzles generated by the consensus network. They execute the requisite algorithms to derive solutions that meet specified criteria. Subsequently, Provers broadcast these solutions across the P2P network for transmission to the consensus network. Upon integration of these solutions into new blocks by the consensus network, Provers are entitled to receive corresponding CoinbaseReward incentives.

SnarkVM
The snarkVM library allows users to write and execute transactions in an efficient, yet privacy-preserving manner by leveraging zero-knowledge succinct non-interactive arguments of knowledge (zk-SNARKs) and encryption.

This creates an off-chain, trustless computing environment, where programs are executed privately, securely and with unlimited runtime.

Who uses snarkVM ?
Developers - Leverage snarkVM to create aleo programs that power private dApps.
Users - Gain privacy from the ability to compute zk-SNARKs and encrypt off-chain.
Validators - Verify transactions submitted by users using Varuna.
Architectural Components
snarkVM synthesizer - used to translate code into circuits that are compatible with the underlying zk-SNARK cryptographic proof system (Varuna).
snarkVM algorithms - the implementation and execution of the proof system and the primitives that support it
snarkVM ledger - data structures and methods that enable storage and interaction with the Aleo blockchain.
SnarkOS
SnarkOS is a decentralized operating system for zero-knowledge applications. This code forms the backbone of Aleo network, which verifies transactions and stores the encrypted state of applications in a publicly-verifiable manner.

The network client has to take care of verifying the transactions computed off chain using snarkvm, allowing all snarkOS nodes to reach consensus and to store the private and non private state in Aleo's distributed ledger.

Aleo Node Options
An Aleo node can be run in three modes.

Client
Prover
Validator
JWT Authentication
The snarkOS accepts runtime parameters for JWT authentication:

--jwt-secret: An optional base64-encoded JWT secret used for token generation and validation
--jwt-timestamp: An optional UNIX timestamp used to determine the validity of the token
Protected Endpoints
The following endpoints require valid JWT authentication:

/{network}/node/address - Get node address information
/{network}/program/{id}/mapping/{name} - Access program mapping data
/{network}/db_backup?path={path} - Database backup operations
Who uses snarkOS ?
Everyone involved in Aleo uses snarkOS both to submit transactions and to fetch their data.

Client
A client in the Aleo network is a node that serves blockchain data and interacts with the network without participating in consensus or block production. Clients play a crucial role in the ecosystem by providing access to blockchain data and facilitating user interactions with the network.

Key features of an Aleo client:

Data Retrieval: Clients can fetch and serve blockchain data, including blocks, transactions, and state information, to users and applications.

Transaction Submission: Users can submit new transactions to the network through client nodes.

Network Interaction: Clients maintain connections with other nodes to stay updated with the latest blockchain state.

Lightweight Operation: Compared to validators and provers, clients have lower hardware requirements, making them more accessible to run.

API Access: Many clients expose REST APIs, allowing developers to build applications that interact with the Aleo network.

To run an Aleo client node:

Ensure your system meets the minimum requirements:

OS: Ubuntu 22.04 (LTS), macOS Sonoma or later, Windows 11 or later
CPU: 32-cores
RAM: 32GB of memory
Storage: 300GB of disk space (PCIe Gen 3 x4 NVME SSD or better)
Network: 100Mbps of upload and download bandwidth
Install snarkOS following the instructions in the Build Guide.

Start the client node by running:

./run-client.sh

Or use the following command for more control:

snarkos start --client

By running a client node, you contribute to the decentralization and robustness of the Aleo network while gaining direct access to its data and functionality.

How to get the ledger data
Option 1 â€“ Sync entire folder with gcloud cp
Blind copy â€“ copies everything, even if already present. Requires Google Cloud SDK

Mainnet
gcloud storage cp -r gs://snarkos-mainnet/uncompressed/ledger-0 {local-ledger-path}


Testnet
gcloud storage cp -r gs://snarkos-testnet/uncompressed/ledger-1 {local-ledger-path}


Canary
gcloud storage cp -r gs://snarkos-canary/uncompressed/ledger-2 {local-ledger-path}


Option 2 â€“ Sync only missing or updated files with gcloud rsync
Smart sync â€“ only copies changes, optionally deletes outdated files. Requires Google Cloud SDK

Mainnet
gcloud storage rsync gs://snarkos-mainnet/uncompressed/ledger-0 {local-ledger-path}


Testnet
gcloud storage rsync gs://snarkos-testnet/uncompressed/ledger-1 {local-ledger-path}


Canary
gcloud storage rsync gs://snarkos-canary/uncompressed/ledger-2 {local-ledger-path}


Useful flags:

--recursive â†’ copy all subdirectories
--delete-unmatched-destination-objects â†’ remove local files that donâ€™t exist in the source (ensures a clean mirror)
Option 3 â€“ Download the entire ledger from scratch with wget
Mainnet
wget -c https://storage.googleapis.com/snarkos-mainnet/latest.tar -O {local-ledger-path}


Testnet
wget -c https://storage.googleapis.com/snarkos-testnet/latest.tar -O {local-ledger-path}


Canary
wget -c https://storage.googleapis.com/snarkos-canary/latest.tar -O {local-ledger-path}


Option 4 â€“ Download the entire ledger with aria2 (multi-connection, parallel download)
Install first: sudo apt install -y aria2 on Ubuntu, brew install aria2 on macOS

Mainnet
aria2c -x 16 -s 16 -c https://snapshots.provable.com/mainnet/latest.tar


Testnet
aria2c -x 16 -s 16 -c https://snapshots.provable.com/testnet/latest.tar


Canary
aria2c -x 16 -s 16 -c https://snapshots.provable.com/canary/latest.tar


Deprecated alternative sources
Mainnet â†’ https://ledger.aleo.network/mainnet/snapshot/latest.txt
Testnet â†’ https://ledger.aleo.network/testnet/snapshot/latest.txt
Canary â†’ https://ledger.aleo.network/canary/snapshot/latest.txt

Introduction
The Aleo blockchain introduces a computational puzzle aimed at incentivizing the acceleration of zkSNARKs and Aleo-specific program optimizations. Historically, puzzles on Aleo's test networks targeted the generation of entire proofs or focused on optimizing computationally intensive aspects of proof generation, such as Multi-Scalar Multiplications (MSM) and Number Theoretic Transforms (NTT). However, advancements in these areas have reduced their dominance in proof generation time, prompting a new focus for the next iteration.

The puzzle sets its sights on enhancing synthesis, otherwise known as witness generation. This area is particularly crucial for Aleo, as it represents a significant portion of the time spent in generating proof for Aleo programs. By directing efforts towards synthesis, the puzzle aims to address a critical bottleneck specific to Aleo's ecosystem, ensuring a more streamlined and efficient process for developers and users alike. This strategic emphasis not only caters to the unique needs of Aleo's platform but also fosters innovation and optimizations in the broader ecosystem.

info
For more detailed information of the puzzle, please refer to the specification.

Role and Incentives of Provers
Anyone can run a prover. Provers does not participate in Aleo's network consensus. They run specific algorithms to solve the Puzzle and obtain a Solution that satisfies the proof_target. This Solution is then broadcasted to the network. After the consensus network verifies and include the Solution in a block, the Prover receives puzzle_reward as incentives.

The economic incentive for Provers is similar to PoW in Bitcoin, but unlike Bitcoin, Aleo's network doesn't employ a winner-takes-all strategy. As long as the Solution satisfies proof_target, it is accepted by the network. The puzzle_reward incentivized Prover directly proportional to their computational power relative to the entire network in every epoch. This approach ensures fairer and more stable rewards for Provers. It's noteworthy that the puzzle_reward decreases gradually over 10 years time, until it reaches the minimum threshold in year 9 and becomes constant after that.

Goals of the Puzzle
The puzzle has been designed with the following goals in mind.

Hardness: Ensure that no adversary can compute solutions to the puzzle faster than through random guessing. This requires the system to be memoryless, or non-amortizable, meaning that the probability of winning does not depend on the time spent computing a solution.

System Safety: The design and its implementation must prevent attacker-controlled inputs from causing denial of service (DoS) attacks, crashes, code execution, or any other unexpected changes to the system.

Uniquely-Determined Circuits: Maintain the soundness and uniqueness of opcode circuits in zero-knowledge proofs, preventing the existence of multiple valid assignments that could allow for cheaper puzzle attempts.

Consistency in Resource Consumption: Distribute the puzzle running time and resource consumption to minimize variance and the risk of extreme behaviors, aiming for a distribution that is more Gaussian-like than power-law-like.

Maximizing Usefulness: The majority of the computation should focus on "useful" algorithms.

Puzzle Design
Overview
Below is a high-level description of the puzzle:

Provers construct puzzle solutions and broadcast them to the network.

Validators aggregate solutions and transactions into a set for the next block via the consensus mechanism.

The set of solutions cannot exceed the MAX_SOLUTIONS allowed in a block.
Validators are not required to verify solutions beforehand.
During block production, validators will process solutions in order, accepting up to MAX_SOLUTIONS valid solutions and aborting the rest. The ledger state is updated accordingly.

The validator maintains a ledger which stores the:
latest_epoch_hash: The latest epoch hash.
latest_proof_target: The minimum target a solution must reach to be accepted.
cumulative_proof_target: The aggregated sum of proof targets for valid solutions in an epoch, from the previous block.
coinbase_target: The expected sum of proof targets, which acts as a threshold for difficulty adjustment.
A solution is valid if its:
epoch_hash matches the ledger's latest_epoch_hash
proof_target, computed for each solution, meets the latest_proof_target.
Fewer than MAX_SOLUTIONS solutions have already been accepted for this block.
A valid solution is rewarded proportionally to its share of the sum of the proof_targets for the set of accepted solutions.
Each proof_target is added to cumulative_proof_target.
The next_coinbase_target and next_proof_target are updated according to the ASERT retargeting algorithm in each block. The next_coinbase_target and next_proof_target are decreased if time between current coinbase_timestamp and last_coinbase_timestamp is longer than the anchor_time and remains the same if shorter or same.
If the updated cumulative_proof_target exceeds half of the coinbase_target, the cumulative_proof_target is reset and the latest coinbase_target and coinbase_timestamp become the new retargeting parameters to calculate next coinbase_target.
If the block height advances to the next epoch, the latest_epoch_hash is updated.
Solution
A Solution consists:

solution_id: SolutionID<N> A unique identifier for a puzzle solution, which must be unique among all solutions submitted to the network. The protocol enforces uniqueness by rejecting any solution whose solution ID has already been recorded in the ledger. The solution ID is constructed from the 3-tuple (address, epoch_hash, counter), which together form a per-attempt nonce. This nonce is then used to seed an RNG, ensuring that each puzzle attempt deterministically generates unique, random internal values.
address: Address<N> The address that is rewarded, if the puzzle solution is valid for the current proof target.
epoch_hash: N::Blockhash The current epoch block hash. A valid solution for the current epoch must use the current epoch hash. If any other epoch hash is used, the puzzle solution should always be invalid.
counter: u64 A counter that is varied across multiple attempts of the puzzle for a given address and epoch hash.
target: u64 The proof target value that this solution claims to meet. A solution is only valid if its target is greater than or equal to the current proof_target required by the network. The higher the target, the greater the share of the reward the solution can earn.
K-ary Merkle Tree
The puzzle use a K-ary Merkle Tree of DEPTH 8 and ARITY 8.
The leaf and path hash functions is SHA-256.
The puzzle produce a Merkle root, which is converted into a solution proof_target. The target is compared against the latest_proof_target which determines whether or not the solution is valid.
Synthesis Puzzle
The synthesis puzzle emphasizes synthesizing a valid R1CS assignment as the key computational element of the puzzle.

The steps for constructing a solution for synthesis puzzle are given below:

Construct an attempt-specific nonce (SolutionID) from the address, epoch_hash, and counter.
Sample an EpochProgram using the epoch_hash.
Sample an attempt-specific set of inputs using an RNG seeded by the nonce (SolutionID).
Synthesize the R1CS for the EpochProgram and puzzle inputs.
Convert the R1CS assignment into a sequence of Merkle leaves.
Compute the Merkle root and convert it into a proof_target.
If the proof_target meets the latest_proof_target, submit the address, epoch_hash, and counter as a solution. Otherwise, repeat the steps above.
Sampling Programs
Each epoch, an EpochProgram is sampled using the epoch_hash. The epoch_hash is used to seed an RNG, which selects a sequence of abstract instructions according to some fixed distribution. The abstract instructions are then concretized into a valid program using the Register Table to correctly track the active set of registers.

Instructions are sampled from a defined instruction set by weight. The weight is set according to the output entropy.

Each entry in the instruction set is a vector of at most NUM_SEQUENCE_INSTRUCTIONS is returned, each consisting of a tuple with:

The instruction as defined here.
The operands, which can be:
Ephemeral
Input
Literal
Register
RegisterOffset
The destinations:
Ephemeral
Register
Destinations
Ephemeral destinations are locally available registers that are not added to the register table. They can be used later in the sequence, but are not available afterwards.

Register destinations are registers stored in the register table.

Operands
Register operands indicate that the register to be used must be the most recent element in the register table.

Ephemeral operands are registers locally available to the sequence. They must be an ephemeral destination from a previous instruction in the sequence.

Input operands reference the original inputs to the program.

Literal operands specify constants to be used as operands.

Register offsets indicate that the register to be used must be from the RegisterTable, offset by an index. That is, the 0-th index is the most recent element in the register table, the 1-st index is the second most recent and so on.

Register Table
The register table initializes and stores active registers while constructing the epoch program. The table contains a 2-deep stack of registers for each LiteralType. The table is initialized according to the preamble below.

Preamble

input r0 as boolean.public;
input r1 as boolean.public;
input r2 as i8.public;
input r3 as i8.public;
input r4 as i16.public;
input r5 as i16.public;
input r6 as i32.public;
input r7 as i32.public;
input r8 as i64.public;
input r9 as i64.public;
input r10 as i128.public;
input r11 as i128.public;
input r12 as field.public;
input r13 as field.public;

is.eq r1 r0 into r14;
is.eq r3 r2 into r15;
is.eq r5 r4 into r16;
is.eq r7 r6 into r17;
is.eq r9 r8 into r18;
is.eq r11 r10 into r19;

hash.psd2 r12 into r20 as u8;
hash.psd2 r13 into r21 as u8;
hash.psd2 r12 into r22 as u16;
hash.psd2 r13 into r23 as u16;
hash.psd2 r12 into r24 as u32;
hash.psd2 r13 into r25 as u32;
hash.psd2 r12 into r26 as u64;
hash.psd2 r13 into r27 as u64;
hash.psd2 r12 into r28 as u128;
hash.psd2 r13 into r29 as u128;

mul.w r3 r2 into r30;
mul.w r5 r4 into r31;
mul.w r7 r6 into r32;
mul.w r9 r8 into r33;
mul.w r11 r10 into r34;

ternary r15 r30 r2 into r35;
ternary r16 r31 r4 into r36;
ternary r17 r32 r6 into r37;
ternary r18 r33 r8 into r38;
ternary r19 r34 r10 into r39;

Instruction Variants
Below are the all instruction variants in the puzzle and whether or not they are sampled.

Abs: No
AbsWrapped: Yes
Add: Yes
AddWrapped: Yes
And: Yes
AssertEq: No
AssertNeq: No
BranchEq: No
BranchNeq: No
Cast: No
CastLossy: Yes
CommitBhp256: No
CommitBhp512: No
CommitBhp768: No
CommitBhp1024: No
CommitPed64: No
CommitPed128: No
Div: Yes
DivWrapped: Yes
Double: No
Gt: Yes
Gte: Yes
HashBhp256: Yes
HashBhp512: No
HashBhp768: No
HashBhp1024: No
HashKeccak256: No
HashKeccak384: No
HashKeccak512: No
HashPed64: Yes
HashPed128: No
HashPsd2: No
HashPsd4: No
HashPsd8: No
HashSha3256: No
HashSha3384: No
HashSha3512: No
Inv: Yes
IsEq: Yes
IsNeq: Yes
Lt: Yes
Lte: Yes
Mod: Yes
Mul: Yes
MulWrapped: Yes
Nand: Yes
Neg: Yes
Nor: Yes
Not: Yes
Or: Yes
Pow: Yes
PowWrapped: Yes
Rem: No
RemWrapped: Yes
Shl: No
ShlWrapped: Yes
Shr: No
ShrWrapped: Yes
Sqrt: No
Square: Yes
Sub: No
SubWrapped: Yes
Ternary: Yes
Xor: Yes
Epochs
An epoch is a period of 360 blocks. At the start of each epoch, a new puzzle program is generated using a hash of the previous block. This program is the same for all provers during the epoch and changes every epoch to prevent precomputation and ensure fairness.

Key points:

The epoch_hash is deterministically generated from the previous block_hash at the epoch start.
The epoch_hash seeds a random number generator to sample instructions for the new EpochProgram.
All Solutions in an epoch must use the current epoch_hash and EpochProgram.
The EpochProgram is cached and used for the entire epoch.
Targets update are completely independent of epochs and happen on every single block based on the cumulative_proof_target from Solutions.
Puzzle rewards
Aleo issues new ALEO tokens as coinbase rewards whenever valid puzzle solutions are submitted. The coinbase reward is distributed between provers and validators according to a fixed ratio, with the total reward calculated based on network parameters and proof targets.

The total coinbase reward is split as follows:

2/3 to provers: Paid to the puzzle solvers who submitted valid solutions
1/3 to validators: Included in the block reward and distributed to active stakers
This distribution is implemented in the puzzle_reward() function:

pub const fn puzzle_reward(coinbase_reward: u64) -> u64 {
    coinbase_reward.saturating_mul(2).saturating_div(3)
}

Coinbase Reward
The coinbase reward is calculated using the formula:

R_coinbase = R_anchor * min(P, C_R) / C

Where:

R_anchor: Anchor block reward (maximum possible coinbase reward for a given block before any adjustments are made based on the actual proof targets submitted)
P: Combined proof target from all solutions in the current epoch
C_R: Remaining coinbase target (coinbase target minus cumulative proof target)
C: Current coinbase target
note
The remaining proof target is the minimum of:

Combined proof target from current solutions
Remaining coinbase target (coinbase target minus cumulative proof target from the same epoch)
This ensures that rewards cannot exceed the available coinbase target for the epoch.

Anchor Block Reward
The anchor block reward serves as the maximum possible coinbase reward for a given block. It is calculated using timestamps to combat block time volatility and better align with human timescales:

R_anchor = max(floor((2 * S * T_A * T_R) / (T_Y10 * (T_Y10 + 1))), R_Y9)


Where:

S: Starting supply (1.5 billion ALEO)
T_A: Anchor time (25 seconds)
T_R: Remaining seconds until year 10
T_Y10: Number of seconds elapsed in 10 years
R_Y9: Minimum reward at year 9
The anchor reward decreases over time until year 9, after which it remains fixed at the year 9 baseline.

Coinbase Target
The coinbase target is calculated using the ASERT retarget algorithm:

T_{i+1} = T_i * 2^(INV * (D - A) / TAU)

Where:

T_i: Current target
D: Drift (actual time elapsed)
A: Anchor time (expected time elapsed)
TAU: Half-life in seconds
INV: Inverse flag (-1 for increasing difficulty, 1 for decreasing)
The algorithm adjusts the target based on how quickly the current epoch advances compared to the expected half-epoch time.

Target Updates
The coinbase target and proof target are both updated on every block to ensure the puzzle remains fair and adapts to network conditions.

Coinbase Target:
The coinbase target is recalculated every block using the ASERT algorithm, which takes into account the previous coinbase target, timestamps, anchor time, and the number of blocks. The formula is:
next_coinbase_target = ASERT(last_coinbase_target, last_timestamp, current_timestamp, anchor_time, blocks_per_epoch)


Proof Target:
After updating the coinbase target, the proof target is set based on the new coinbase target, which is 1/4 of the coinbase target:
proof_target = (coinbase_target >> 2) + 1

When the cumulative proof target reaches at least half of the coinbase target (cumulative_proof_target >= coinbase_target / 2), the following steps occur:

The cumulative proof target is reset to zero.
The coinbase target is updated with new last_coinbase_target and new last_timestamp.
The proof target is recalculated based on the new coinbase target.
Individual Prover Rewards
Each prover receives a portion of the puzzle reward proportional to their contribution:

Individual Reward = Puzzle Reward * (Individual Proof Target / Combined Proof Target)


This approach avoids a winner-takes-all outcome by distributing rewards more equitably among provers, based on the proportion of their individual contributions.

ARC-46 Staking for Puzzle Solution Submissions
As the Aleo Network grows, ensuring long-term security, stability, and fair participation is critical to the success of the ecosystem. The ARC-46 is voted and accepted by the Aleo community. The goal of this ARC is to align prover incentives with the overall networkâ€™s health, and gradually adjust up economic requirements for provers as the network matures.

This ARC proposes a mechanism requiring provers on the Aleo Network to stake a specific amount of Aleo credits to be eligible to submit a specific number of solutions per epoch. This feature is programmatic, with a stepwise increase in the required amount of stake over a two-year period following the activation of this ARC.

Before ARC-46, provers are able to participate in Proof of Succinct Work and earn puzzle rewards without any entry or exit requirements. This ARC contemplates introducing entry requirements for provers, and while exit requirements are desirable, they are out of scope for this ARC at this time.

To participate as a prover on the Aleo network, this ARC proposes requiring the prover to stake a minimum number of Aleo Credits (X) to submit 1 solution per epoch. As such, if the prover wishes to submit 2 solutions per epoch, they must stake 2*X Aleo credits on the Aleo network. This approach ensures that pools do not gain any advantage over individual provers, ensuring fairness for all parties submitting solutions. As expected, once the prover submits their allotment of solutions per epoch, all subsequent solutions submitted by the prover will be rejected.

There is no requirement that the prover must stake to any specific validator. Rather, in consensus, the protocol will enforce that the prover submitting solutions has an adequate amount of stake that is bonded to a validator on the Aleo Network.

Key Objectives
Sybil Resistance - Aligning stake with number of solutions per epoch ensures that provers cannot bypass this new cryptoeconomic mechanism by creating new identities on-chain. In addition, this new cryptoeconomic mechanism makes it economically costly for malicious actors to create numerous identities (Sybil attacks) to flood the network with malformed solutions.
BFT Security - The proposed timetable ensures that provers gradually increase their stake participation to achieve at least the availability threshold of the Aleo Network within 2 years. This ensures that provers contribute to the underlying security of the Aleo Network.
Economic Growth - A transparent schedule increase in the staking requirement allows the network to adapt to its growing value and security needs without introducing sudden economic impacts or shocks. By ensuring provers contribute to staking, this ensures that their earned rewards are then directly utilized by the Aleo Network itself.
Specification
The staking requirement will increase in a stepwise function over 2 years on a quarterly basis. Namely, each quarter, the amount of stake required to submit 1 solution per epoch will increase for provers.

The following outlines the timetable for introducing the stepwise staking requirements for provers to continue participating on the Aleo Network:

Effective Date	Quarter	Stake Required Per Solution Per Epoch
Activation (Month 0)	Q0	100,000
Month 3	Q1	250,000
Month 6	Q2	500,000
Month 9	Q3	750,000
Month 12	Q4	1,000,000
Month 15	Q5	1,250,000
Month 18	Q6	1,500,000
Month 21	Q7	2,000,000
Month 24	Q8	2,500,000
Benefits
This ARC benefits three main parties: validators, provers, and long-term holders of Aleo Credits.

Validators are likely to receive increased delegations from provers as the staking requirements are rolled out over the next two years, enhancing their participation and rewards. Provers benefit by earning additional staking yield on their token rewards through the staking process, further aligning their incentives with the networkâ€™s security and long-term growth. Long-term token holders gain increased confidence that Aleo Credits are being actively used to secure the network and are delegated appropriately, supporting the networkâ€™s health.

Future Plans
ARC-43: Extending the Puzzle to a Full SNARK
ARC-43 proposes extending the current synthesis-focused puzzle to a full Succinct Non-interactive Argument of Knowledge (SNARK). This extension aims to address current bottlenecks and leverage recent hardware advancements. The full proposal can be found here.

Key Changes:

Increased Instruction Count: Expand the puzzle by orders of magnitude beyond current consensus verification limits
Expanded Instruction Set: Include richer opcodes with larger operands for greater complexity
zkSNARK Verification: Implement succinct puzzle proof verification to improve block verification times
Benefits:

Incentivizes dedicated hardware development for full SNARK acceleration
Significantly improves block verification performance
Enhances puzzle complexity and security through larger instruction sets
Leverages recent GPU and FPGA acceleration advancements
Technical Approach:

Built on existing proof system and elliptic curve to minimize technical risk
Extends to SNARK (not zkSNARK) to maintain non-malleability and prevent grindability
Phased implementation to allow gradual hardware upgrades

Validators
Role and Function of Validator Nodes in the Network
Validator nodes in the Aleo network form a consensus network and determine block generation through the Aleo Byzantine Fault Tolerance ([AleoBFT])(./consensus.md) consensus protocol. Validators acquire voting power by staking AleoCredits, with the node's voting power directly proportional to the amount of AleoCredits staked. AleoBFT ensures that when a new block is generated, it receives approval from over 2/3 of the votes, indicating consensus among honest validators. This effectively ensures network security and prevents attacks from malicious nodes. Once a block is formed, it achieves finalized, meaning blocks and the transactions they contain will not be reverted.

Economic Incentives for Validator Nodes
The mechanism of AleoBFT ensures that if a malicious node attempts to attack the network, it would need to acquire at least 1/3 of the voting power to prevent the production of new blocks.. This implies that the more AleoCredits staked in the network, the more secure the consensus network becomes. To incentivize validator nodes to stake their AleoCredits, each block produced includes a corresponding BlockReward for validator nodes. The proportion of BlockReward that validator nodes receive is consistent with the proportion of AleoCredits they have staked.

Become a Validator Node
To become a validator node, one needs to stake a minimum of 10,000,000 (10 million) AleoCredits. Once the staking transaction is accepted by the consensus network, the new validator node can immediately participate in the consensus and receive BlockReward incentives, thanks to the improvements made by AleoBFT over Narwhal Bullshark.

When one possesses only a small amount of AleoCredits, although unable to become an independent validator node, they can participate in staking through delegation.

Due to the fact that validator nodes in the network communicate with each other to obtain status information, the more validator nodes there are, the greater the magnitude of network communication required, with communication complexity being O(n). The increase in communication complexity leads to longer block generation times. In the Aleo network, the maximum number of validator nodes is limited to 200 to balance decentralization and network efficiency.

Delegated Staking
Delegated staking allows users to stake AleoCredits on a specific validator node through a Program (Aleo's smart contract). The voting power gained from staking AleoCredits is also delegated to the respective validator node. Users receive BlockReward incentives in proportion to their stake, while validators may charge a certain percentage of fees set within the Program. Various wallets and browsers provide users with the functionality to delegate stake. Users can view fee percentages of various validators on their UI interface, facilitating the staking process.

Users can cancel their stake at any time. After cancellation, users can withdraw the AleoCredits refunded from the cancellation to their balance after 360 blocks.

How validators confirm transactions/solutions
image-20240422165659999

The process by which validator nodes confirm Transactions and Solutions involves the following steps:

Transactions/Solutions enter the validator nodes' mempool via the P2P network or RPC.
Validator nodes select some Transactions/Solutions from the mempool and include them in a BatchPropose (in addition to Transactions and Solutions, BatchPropose needs to contain 2f + 1 BatchCertificates from the previous round) and broadcast it to other validator nodes.
Upon receiving BatchPropose, other validator nodes validate its legitimacy, sign the BatchPropose to generate BatchSignature, and return the BatchSignature to the originating validator node.
When the originating validator node receives more than 2f + 1 BatchSignatures, it aggregates them into a BatchCertificate and broadcasts it to other validator nodes.
All nodes execute and repeat this process, resulting in a DAG formed by the BatchCertificates. When the DAG is committed, a new block is produced, and Transactions and Solutions are included in the new block.
image-20240422175911657

Consensus
Overview
Aleo Network employs a unique consensus mechanism known as AleoBFT to achieve a secure and resilient consensus system with instant finality for block confirmation. This mechanism combines proof-of-stake (POS) to ensure that validators are rewarded for maintaining the overall system integrity and performance.

Aleo Network is run and maintained by three groups of participants:

Stakers - Delegate staked Aleo Credits (AC) to help onboard more validators and participate in consensus on the Network.
Provers - Utilize specialized hardware to generate proofs and solve coinbase puzzles, contributing to the security of the network.
Validators - Validate transactions by verifying zero knowledge (ZK) proofs and actively participate in the consensus process on the network.
Check this FAQs out in regards of the groups mentioned above.

Everyone can become a staker by locking up their Aleo Credits for a certain period of time to support the security of the Aleo Network. While the minimum amount to stake is 1 AC, stakers will only start earning rewards once they have staked at least 10 ACs. Stakers help lower the barriers to becoming a validator by delegating their stakes to validators of their choice.

Learn more about stakers at here.

Provers are required to run specialized GPUs and CPUs to generate solutions in SNARK proofs for PoSW (Proof-of-Succinct-Work) coinbase puzzles. They are rewarded based on their efficiency and effectiveness in generating solutions to the puzzles. It's important to note that provers do not produce blocks, but they are incentivized to improve the process of generating proofs, reducing costs, and decreasing latency for program execution.

Learn more about provers at here.

Validators play a crucial role in securing the network through AleoBFT (to be discussed further below) and must have at least 10 million AC of stakes to get started. The main function of validators is to verify ZK proofs and validate transactions before including them in a confirmed block.

Learn more about validators at here.

AleoBFT
AleoBFT is a new hybrid architecture for consensus. It is a DAG-based BFT protocol inspired by Narwhal and Bullshark. It incentivises validators to preserve network liveness and provers to scale proving capacity for Aleo ecosystem.

AleoBFT guarantees instant finality once validators achieve consensus for each block. With instant finality, not only validators enjoy better node stability but also creates smooth experience for applications developers and users. And this guarantee makes interoperability with other ecosystem simpler.

AleoBFT provers are computing core components of ZK proofs and receive shares of coinbase rewards by solving and producing these coinbase proofs, which is called Proof of Succint Work (PoSW). This incentivise provers to also become a validator themselves by accumulate and stake 10 million ACs. By having broader rewards distribution, it helps Aleo Network to achieve greater proving capacity, further decentralise and scaling Aleo network and fortifies censorship-resistence guarantee.

info
For detailed technical specifications of AleoBFT, please refer to the AleoBFT specification.

Bullshark and Narwhal
Bullshark
Bullshark is a DAG(Directed Acyclic Graph)-based BFT (Byzantine Fault Tolerance) protocol, it separate the network communication layer from the ordering (consensus) logic. Each message contains a set of transactions, and a set of references to previous messages. Together, all the messages form a DAG that keeps growing â€“ a message is a vertex and its references are edges. A vertex can be a proposal and an edge can be a vote.

While different parties may see slightly different DAGs at any point in time due to the asynchronous nature of the network, each validator can still totally (fully) orders all the vertices (blocks) without sending a single extra message by just looking at its local view of the DAG.

The DAG being used here is round-based DAG, each vertex is associated with round number, each round has at most n vertices. Each validator broadcasts one message per round and each message references at least n âˆ’ f messages in previous round. n is the total number of validating nodes in the network and f is the number of Byzantine nodes. Below shows a diagram of how it looks like with n = 4 and f = 1.

DAG1 Diagram 1: Round-based DAG
Image from https://decentralizedthoughts.github.io/2022-06-28-DAG-meets-BFT/

Ordering Logic
A predefined leader is elected in every even round and the vertex associated with it is referred as anchor. Anchor is a more suitable term to describe here because unlike typical leader-based protocols where the leader has to do all the works at each round and disseminate data to all other nodes, the anchor here only get chosen to commit its casual history once gather enough votes (2f + 1) (3 in this example).

Each vertex in odd round can contribute one vote for the anchor in previous round. The anchor is commited if it has at least f + 1 (2 in this example) votes. Once anchor is committed, its casual history is ordered by some deterministic rule. Green-outlined vertices shown in Diagram 2 is Anchor 2 (A2) casual history. Diagram 3 shows A2 is committed with 3 votes but A1 is also committed althought with only 1 vote thanks to the reliability property of the DAG, where transactions broadcast by honest validators are eventually received by all other honest validators.

DAG2 Diagram 2: Anchor and casual history
Image from https://decentralizedthoughts.github.io/2022-06-28-DAG-meets-BFT/

DAG3 Diagram 3: Commit rule
Image from https://decentralizedthoughts.github.io/2022-06-28-DAG-meets-BFT/

Due to asynchronous nature of the network, the local views of the DAG might differ for different parties. A1 might have committed by other validator. As shown in diagram 4, validator 2 sees two (f + 1) votes for anchor A1 and thus commits it even though validator 1 has not.

DAG4 Diagram 4: Different local view
Image from https://decentralizedthoughts.github.io/2022-06-28-DAG-meets-BFT/

Because to commit an anchor requires f + 1 (2 in this example) votes and each vertex in the DAG has at least n âˆ’ f (3 in this example) edges to vertices from the previous round, it is guaranteed that if some party commits an anchor A then all anchors in higher rounds will have a path to at least one vertex that voted for A, and thus will have a path to A.

This is also means that if there is no path to a anchor A from a future anchor, then no party committed A and it is safe to skip it. Diagram 5 shows that A2 is not committed by any party and thus A2 is safe to skip.

DAG5 Diagram 5: Skipping uncommitted anchor
Image from https://decentralizedthoughts.github.io/2022-06-28-DAG-meets-BFT/

When an achor is committed, the validator checks if there's a path to previous uncommitted anchor. If there is, it will commit the previous anchor as well. This process is repeated until it reaches previous committed anchor. Diagram 5 shows that A3 is committed and A1 is in the path of A3 thus A1 is committed as well.

Achors' histories are then ordered by some deterministic order and finally forming a total order or a chain of blocks.

DAG6 Diagram 6: Total order
Image from https://www.youtube.com/watch?v=aW1-XcGzJ8M

Narwhal
Narwhal is a DAG-based Mempool abstraction protocol. Instead of the proposing validator sending all transactions in a block to the other validators they just send references or certificates of availability for blocks at each round.

A single validator will run multiple workers as separate processes or instances and a single primary. The workers are responsible for receiving transactions and stream transactions in batches to corresponding workers of other validators. Example worker 1 of validator 1 sends transactions to worker 1 of validator 2, worker 2 of validator 1 sends transactions to worker 2 of validator 2 and so on.

Narwhal Diagram 7: Narwhal Design
image from https://www.youtube.com/watch?v=NGOXVSFzYdI

Every workers within a validator sends batches hash (digest) to its primary. The primary then sends the digest to all other validators along with n - f certificates from previous round.

Each validator then checks if the digest is from the same round and if it's worker has stored transactions batches that corresponds to the digest. If it is, the validator cast a vote by sending its signature back to the sending primary.

A certificate is created after the sender collects n - f signatures from different validators and send this certificate back to all other validators. This certificate is then used as reference in the next round.

Whenever a certificate is received, it means the block will be available for download. Therefore, certificate is often referred as a proof of availability and thus ensuring data availability.

Narwhal2 Diagram 8: A round in Narwhal
image from https://www.youtube.com/watch?v=NGOXVSFzYdI

Narwhal3 Diagram 9: Another view of a round
image from https://www.youtube.com/watch?v=NGOXVSFzYdI


Staking
What is staking?
Staking is an economic security mechanism used to secure decentralized networks that rely on Proof of Stake (PoS) as their consensus mechanism. Unlike Proof of Work (PoW), where miners compete to solve cryptographic puzzles in order to add new blocks, PoS selects validators at random for each block to confirm transactions and validate block data. This approach replaces competitive mining with a randomized, stake-based selection process, where validators earn rewards based on their participation rather than computational power.

To become a validator and participate in consensus, a minimum stake of 10,000,000 ACs is required. This ensures that the network is economically secured by validators with a significant investment in the system. However, not everyone has the resources to meet this threshold individually. Staking allows users to delegate their ACs to support validators, helping them become active participants in the consensus process while sharing in the rewards.

How to become a staker?
Stakers are individuals or organizations who lock up or delegate Aleo Credits (ACs) to support validators in participating in consensus on the network. In return, they earn rewards proportional to the amount of ACs they have staked, reflecting their contribution to network security. This allows users who do not run validator nodes to still participate in the consensus process and receive staking rewards. Stakers are sometimes refer as delegators because they delegate their stakes to validators.

Anyone holding ACs can become a staker. Native staking is available starting from 10,000 ACs, there are also liquid staking options available for holders who has less than 10,000 ACs. To get started, users can utilize various tools developed by the Aleo ecosystemâ€”such as staking platforms or supported wallets.

disclaimer
The community tools are developed by third parties within the Aleo ecosystem. Aleo does not endorse, review, or audit these tools, and users are solely responsible for their use.

Native Staking
Native staking enables token holders to interact on-chain and stake their Aleo Credits (ACs) directly, without the need to rely on third-party programs or custodial services. The native staking functions are made available in the credits.aleo program, the same program that host every Aleo Credit. There are staking rules enforced in the credits.aleo program:

Self-bond minimums for validators (â‰¥ 100 credits)
Delegation minimums for stakers (â‰¥ 10 000 credits)
Automatic removal of validators that drop below 10 M total stake
Time-locked unbonding (360 blocks) before re-claiming stakes
The source code in Aleo Instructions can be found here.

Function glossary
Function	Caller	Purpose
bond_validator	Validator (self-bond)	Creates a validator or tops-up self-bonded stake and sets commission + withdrawal address
bond_public	Staker	Bonds (delegates) stake to an existing validator that is open to new stake
unbond_public	Validator or Staker	Starts the unbonding timer for some or all of the bonded amount
claim_unbond_public	Anyone	After the timer has expired, transfers the unbonded amount to the staker's withdrawal address
Staking related mappings
The staking system in Aleo uses several key mappings to track validator and delegator states:

committee
Contains the active validator set with their committee state:

Whether the validator is open to new stakers (is_open)
The commission percentage (0-100) that the validator keeps from rewards
/// The `committee` mapping contains the active validator set and their corresponding stake.
mapping committee:
    // The key represents the address of the validator.
    key as address.public;
    // The value represents the committee state of the validator.
    value as committee_state.public;

// The `committee_state` struct tracks the total stake of the validator, and whether they are open to new stakers.
struct committee_state:
    // The boolean flag indicating if the validator is open to new stakers.
    is_open as boolean;
    // The percentage amount (from 0 to 100, inclusive) of rewards that retained by the validator.
    commission as u8;


delegated
Tracks the total amount of microcredits bonded to each validator address (including both self-bonded and delegator bonds). This mapping is used to determine if a validator meets the minimum 10 million credits threshold to join the committee.

// The `delegated` mapping tracks the total amount of microcredits that are prebonded and bonded to validator addresses.
// Note: The mapping includes both prebonded and bonded microcredits. However, it does not contain unbonding microcredits.
mapping delegated:
    // The key represents the address of the validator.
    key as address.public;
    // The value represents the amount of microcredits bonded to the validator, by the validator and its delegators.
    value as u64.public;


note
Prebonding microcredits is where a delegator has attempted to bond to a validator address that is not yet included in the active committee set. In this case, the delegator's credits are locked up, and the delegator does not actively participate in staking rewards or voting.

metadata
Stores global staking statistics:

metadata[aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc] - Number of active committee members
metadata[aleo1qgqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqanmpl0] - Number of delegators (capped at 100,000)
/// The `metadata` mapping stores:
///   - The number of members in the committee.
///   - The number of delegators.
mapping metadata:
    // The key represents the index at which the count is stored.
    //    - This address (aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc) stores the number of **members** in the committee.
    //    - This address (aleo1qgqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqanmpl0) stores the number of **delegators**.
    key as address.public;
    // The value represents the count.
    value as u32.public;


bonded
Maps each staker's address to their bond state, which includes:

The validator address they're bonded to
The amount of microcredits currently bonded
// The `bonded` mapping represents the amount of microcredits that are currently bonded.
mapping bonded:
    // The key represents the address of the staker, which includes the validators and their delegators.
    key as address.public;
    // The value represents the bond state.
    value as bond_state.public;

// The `bond_state` struct tracks the amount of microcredits that are currently bonded to the specified validator.
struct bond_state:
    // The address of the validator.
    validator as address;
    // The amount of microcredits that are currently bonded to the specified validator.
    microcredits as u64;


unbonding
Tracks stakers who have initiated the unbonding process:

The amount of microcredits currently unbonding
The block height when unbonding will be complete (360 blocks from initiation)
// The `unbonding` mapping contains a set of stakers with their unbonding microcredits and unlock height.
mapping unbonding:
    // The key represents the address of the staker, which includes the validators and their delegators.
    key as address.public;
    // The value represents the unbond state.
    value as unbond_state.public;

// The `unbond_state` struct tracks the microcredits that are currently unbonding, along with the unlock height.
struct unbond_state:
    // The amount of microcredits that are currently unbonding.
    microcredits as u64;
    // The block height at which the unbonding will be complete, and can be claimed.
    height as u32;


withdraw
Maps each staker's address to their withdrawal address, which is where rewards and unbonded amounts are sent.

// The `withdraw` mapping contains the staking address and their corresponding withdrawal address.
mapping withdraw:
    // The key represents the staking address of the owner.
    key as address.public;
    // The value represents the withdrawal address of the owner.
    value as address.public;


Becoming or topping-up as a validator
To become a validator or top-up the self-bonded stake, execute the bond_validator function using the validator address:

leo execute credits.aleo/bond_validator <withdrawal_address> <amount> <commission_percentage> --network mainnet --endpoint https://api.explorer.provable.com/v1 --broadcast 


function bond_validator:
    // Input the withdrawal address.
    input r0 as address.public;
    // Input the amount of microcredits to bond.
    input r1 as u64.public;
    // Input the commission percentage.
    input r2 as u8.public;

withdrawal_address â€“ a separate address that will receive rewards and unbonded stake. Must be different from the validator address.
amount_in_microcredits â€“ minimum 1 AC. To enter the committee you need â‰¥ 10 millions ACs combining self-bond + delegation.
commission_percentage â€“ integer 0-100 that defines the share of rewards kept by the validator.
What happens on-chain:

The amount is subtracted from the validator's public account balance.
bonded[validator] is written/updated with the new self-bond amount.
delegated[validator] is updated (self-bond counts towards total delegation).
If the total delegation is â‰¥ 10 millions ACs and the validator was not in committee yet, they are added and metadata[committee_size] is incremented. (Subjected to network maximum committee size that can be increased with protocol upgrades)
Delegating to a validator
If you are not running a validator, you can still participate in the network by delegating your Aleo Credits to a validator and earn rewards based on their performance.

Choosing a validator
Before you delegate, inspect the candidate validator's on-chain stats. You can query committee, delegated, and bonded mappings via API endpoints or block explorers to learn:

Total stake â€“ how much ACs have been delegated to the validator.
Self-bond â€“ validator's own stake (at least 100 ACs is required).
Commission â€“ the % of rewards the validator keeps (0â€“100).
Is open â€“ only validators with is_open = true can accept new stake.
A healthy validator typically has:

At least 10 millions ACs total stake (otherwise it is not in the committee and earns no block rewards).
Consistent uptime / performance (check explorers).
Steps to delegate
Decide the amount you want to delegate (â‰¥ 10 000 AC).
important
Must keep minimum bonded balance of â‰¥â€¯10â€¯000â€¯ALEO bonded at all times.

Ensure that amount is available in your public account balance.
Choose a withdrawal address (can reuse current signer address or another address).
Execute bond_public function from credits.aleo using Leo CLI:
leo execute credits.aleo/bond_public <validator_address> <withdrawal_address> <amount> --network mainnet --endpoint https://api.explorer.provable.com/v1 --broadcast 


function bond_public:
    // Input the validator's address.
    input r0 as address.public;
    // Input the withdrawal address.
    input r1 as address.public;
    // Input the amount of microcredits to bond.
    input r2 as u64.public;

After the transaction is finalized you will start to accrue a share of the validator's block rewards proportionally to your stake. You may topâ€¯up your bond at any time, in any amount.

On-chain effects:

Deducts the amount from the staker's account.
Updates bonded[delegator] (mapping staker â†’ validator).
Adds the amount to delegated[validator].
Increments the global staker counter (metadata[delegator_count], capped at 100,000).
important
The validator must be open (committee_state.is_open = true) and not in the unbonding (exiting) process.

info
Each address can be bonded to one validator at a time. Staker may bond to a new validator only after the previous bond has fully unbonded and the ACs has been claimed. Or simply use a new address.

Withdrawing stake
Stakers can withdraw bonded ACs at any time, provided the remaining bonded balance stays â‰¥â€¯10â€¯000. Any withdrawal that takes the bonded balance below 10â€¯000â€¯ACs immediately triggers a full unbond.

To withdraw a stake, the staker must first call the unbond_public function. This function initiates the unbonding process by specifying the staker's address and the amount of microcredits to unbond. The unbonding process allows the staker to either partially or fully unbond their stake. This can be done by using Leo CLI:

leo execute credits.aleo/unbond_public <staker_address> <amount> --network mainnet --endpoint https://api.explorer.provable.com/v1 --broadcast 


function unbond_public:
    // Input the staker's address.
    input r0 as address.public;
    // Input the amount of microcredits to unbond.
    input r1 as u64.public;

Called either by the staker's withdrawal address or the validator's withdrawal address.

Stakers may unbond partially or fully. If the remaining bond falls below 10 000 ACs, the entire bond is unbonded and the staker entry is removed.
Validators can unbond themselves or forcibly unbond a staker.
If unbonding causes the validator's total stake to drop below 10 millions ACs or self-bond below 100 ACs, the validator is removed from the committee.
The amount begins a 360-block cooldown stored in unbonding[staker].
Claiming unbonded stake
To claim your unbonded stake, make sure the 360 blocks cooldown has passed, then you can use the Leo CLI as follows:

leo execute credits.aleo/claim_unbond_public <staker_address> --network mainnet --endpoint https://api.explorer.provable.com/v1 --broadcast


function claim_unbond_public:
    // Input the staker's address.
    input r0 as address.public;

Anyone can trigger this once block.height â‰¥ unbonding[staker].height.
The unbonded amount is transferred to the staker's withdrawal address (account[withdrawal]).
The corresponding unbonding entry is cleared. If the staker has no remaining bond, their withdrawal address is also removed.
Liquid Staking
Liquid staking is an innovative approach that allows users to stake their Aleo Credits (ACs) while maintaining liquidity. Instead of locking up your ACs, you receive a liquid staking token (stToken) that represents your staked position. This enables you to participate in staking while still being able to use your tokens in other DeFi activities. Liquid staking platforms allow users to stake with less than 10,000 ACs, making staking more accessible to everyone.

Specifications
Overview
In the context of blockchain technology, specifications are detailed descriptions of the system's architecture, components, and operations. They serve as a blueprint for developers and engineers to understand and implement the system effectively. For Aleo, the specifications focus on two main areas: the consensus mechanism and the virtual machine.

AleoBFT
AleoBFT is the consensus algorithm that powers the Aleo blockchain. It is designed to ensure secure and reliable agreement among validators. AleoBFT builds on concepts from Narwhal and Bullshark, optimizing for dynamic validator committees and staking participation. Validators in AleoBFT collect transactions and submit proposals, which are then endorsed by others to form cryptographic certificates. These certificates are structured into a Directed Acyclic Graph (DAG), enabling efficient ordering of transactions and preventing forks, thus ensuring a robust and scalable consensus process.

AleoBFT Syncing
When a validator (re)joins the network it quickly learns what itâ€™s missing by exchanging compact â€œcheckpointâ€ and â€œrecentâ€ block summaries with peers via periodic pings. By comparing these locators, it detects any gaps in its local copy, then asks a rotating set of peers for the missing blocks in small batches. Each returned block is cross-checked against multiple peers and its embedded sub-DAG data is applied to rebuild the recent certificate graph. Once it has filled in all gaps, the validator is fully synced and can immediately take part in proposing and endorsing new blocks.

AleoVM
The Aleo Virtual Machine (AVM) is a computational platform integral to the Aleo blockchain, designed to run privacy-focused applications. It operates as a stack machine that executes queued instructions. Its primary function is to construct arithmetic circuits described as Rank-1 Constraint System (R1CS) from each instruction in a function. After constructing the R1CS, corresponding proofs are generated using a variation of the Marlin algorithm called Varuna. This approach allows for succinct verification of arbitrary computations by leveraging a universal and updatable Structured Reference String (SRS). The AVM is crucial for maintaining privacy and scalability on the Aleo network. It ensures that transactions and contracts are executed while maintaining the confidentiality of the data involved, using zk-SNARKs to verify the correctness of computations without revealing the inputs or internal state.



































